<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[原来你是这样的jsonp(原理与具体实现细节)]]></title>
      <url>https://qianlongo.github.io/2017/06/11/%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84jsonp%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/zepto-analysis/issues/4" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">仓库地址</a></p>
<blockquote>
<p>jsonp(JSON with padding)你一定不会陌生，前端向后端拿数据的方式之一，也是处理跨域请求的得利助手。</p>
<p>我们早已习惯，早已熟练了jQ或者zepto的ajax调用方式。但是有可能还不太它内部具体是如何实现一个jsonp的，从请求的发出，到指定的成功(success)或失败(error)回调函数的执行。</p>
</blockquote>
<ol>
<li>这中间前端需要做什么？</li>
<li>后端又需要做些什么来支持？</li>
<li>超时场景又该如何处理？</li>
<li>整个生命周期会有多个钩子可以被触发，而我们可以监听哪些钩子来得知请求的状况?</li>
</ol>
<p>让我们从zepto.js的源码出发，一步步揭开它的面纱。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/adsfdsf.png" alt=""></p>
<a id="more"></a>
<p>(该篇文章重点是想说jsonp实现过程，如果你想了解跨域相关的更多的知识，可以谷歌，度娘一把)</p>
<h2 id="絮叨一下jsonp的基本原理"><a href="#絮叨一下jsonp的基本原理" class="headerlink" title="絮叨一下jsonp的基本原理"></a>絮叨一下jsonp的基本原理</h2><blockquote>
<p>jsonp是服务器与客户端跨源通信的常用方法之一，具有简单易用，浏览器兼容性好等特点。</p>
</blockquote>
<p><strong>基本思想是啥呢</strong></p>
<ol>
<li><p>客户端利用<code>script</code>标签可以跨域请求资源的性质，向网页中动态插入<code>script</code>标签，来向服务端请求数据。</p>
</li>
<li><p>服务端会解析请求的<code>url</code>,至少拿到一个回调函数(比如<code>callback=myCallback</code>)参数,之后将数据放入其中返回给客户端。</p>
</li>
<li><p>当然jsonp不同于平常的<code>ajax</code>请求,它仅仅支持get类型的方式</p>
</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<p>这里简单的介绍一下zepto.js是如果使用jsonp形式请求数据的，然后从使用的角度出发一步步分析源码实现。</p>
</blockquote>
<p><strong>使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'http://www.abc.com/api/xxx'</span>, <span class="comment">// 请求的地址</span></div><div class="line">  type: <span class="string">'get'</span>, <span class="comment">// 当然参数可以省略</span></div><div class="line">  data: &#123; <span class="comment">// 传给服务端的数据，被加载url?的后面</span></div><div class="line">    name: <span class="string">'qianlongo'</span>,</div><div class="line">    <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">dataType</span>: <span class="string">'jsonp'</span>, <span class="comment">// 预期服务器返回的数据类型</span></div><div class="line">  jsonpCallback: <span class="string">'globalCallback'</span>, <span class="comment">// 全局JSONP回调函数的 字符串（或返回的一个函数）名</span></div><div class="line">  timeout: <span class="number">100</span>, <span class="comment">// 以毫秒为单位的请求超时时间, 0 表示不超时。</span></div><div class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">// 请求成功之后调用</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'successCallback'</span>)</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 请求出错时调用。 (超时，解析错误，或者状态码不在HTTP 2xx)</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'errorCallback'</span>)</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">// 请求完成时调用，无论请求失败或成功。</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'compelete'</span>)</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalCallback</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'globalCallback'</span>)</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在zepto中一个常见的jsonp请求配置就是这样了，大家都很熟悉了。但是不知道大家有没有发现.</p>
<ol>
<li>如果设置了<code>timeout</code>超时了，并且没有设置<code>jsonpCallback</code>字段，那么控制台几乎都会出现一处报错，如下图</li>
</ol>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E9%94%99%E8%AF%AF.png" alt=""></p>
<ol>
<li>同样还是发生在<code>timeout</code>,此时如果请求超时了，并且设置了<code>jsonpCallback</code>字段(注意这个时候是设置了)，但是如果请求在超时之后完成了，你的<code>jsonpCallback</code>还是会被执行。照理说这个函数应该是请求在超时时间内完成才会被执行啊！为毛这个时候超时了，还是会被执行啊！！！</li>
</ol>
<p>不急等我们一步步分析完就会知道这个答案了。</p>
<h2 id="先看一下完整的代码"><a href="#先看一下完整的代码" class="headerlink" title="先看一下完整的代码"></a>先看一下完整的代码</h2><blockquote>
<p><strong>因为zepto中完成jsonp请求的处理基本都在<code>$.ajaxJSONP</code>完成，我们直接从该函数出发开始分析。</strong>先整体看看这个函数,有一个大概的印象，已经加了大部分注释。或者可以<a href="https://github.com/qianlongo/zepto-analysis/blob/master/src/ajax.js" target="_blank" rel="external">点击这里查看</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> $.ajaxJSONP = <span class="function"><span class="keyword">function</span> (<span class="params">options, deferred</span>) </span>&#123;</div><div class="line">  <span class="comment">// 直接调ajaxJSONP没有传入type，去走$.ajax</span></div><div class="line">  <span class="keyword">if</span> (!(<span class="string">'type'</span> <span class="keyword">in</span> options)) <span class="keyword">return</span> $.ajax(options)</div><div class="line">  <span class="comment">// 获取callback函数名，此时未指定为undefined</span></div><div class="line">  <span class="keyword">var</span> _callbackName = options.jsonpCallback,</div><div class="line">    <span class="comment">// jsonpCallback可以是一个函数或者一个字符串</span></div><div class="line">    <span class="comment">// 是函数时，执行该函数拿到其返回值作为callback函数</span></div><div class="line">    <span class="comment">// 为字符串时直接赋值</span></div><div class="line">    <span class="comment">// 没有传入jsonpCallback，那么使用类似'Zepto3726472347'作为函数名</span></div><div class="line">    callbackName = ($.isFunction(_callbackName) ?</div><div class="line">      _callbackName() : _callbackName) || (<span class="string">'Zepto'</span> + (jsonpID++)),</div><div class="line">    <span class="comment">// 创建一个script标签用来发送请求  </span></div><div class="line">    script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>),</div><div class="line">    <span class="comment">// 先读取全局的callbackName函数，因为后面会对该函数重写，所以需要先保存一份</span></div><div class="line">    originalCallback = <span class="built_in">window</span>[callbackName],</div><div class="line">    responseData,</div><div class="line">    <span class="comment">// 中止请求，触发script元素上的error事件, 后面带的参数是回调函数接收的参数</span></div><div class="line">    abort = <span class="function"><span class="keyword">function</span> (<span class="params">errorType</span>) </span>&#123;</div><div class="line">      $(script).triggerHandler(<span class="string">'error'</span>, errorType || <span class="string">'abort'</span>)</div><div class="line">    &#125;,</div><div class="line">    xhr = &#123; <span class="attr">abort</span>: abort &#125;, abortTimeout</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (deferred) deferred.promise(xhr)</div><div class="line">  <span class="comment">// 给script元素添加load和error事件</span></div><div class="line">  $(script).on(<span class="string">'load error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e, errorType</span>) </span>&#123;</div><div class="line">    <span class="comment">// 清除超时定时器</span></div><div class="line">    clearTimeout(abortTimeout)</div><div class="line">    <span class="comment">// 移除添加的元素(注意这里还off了，不然超时这种情况，请求回来了，还是会走回调)</span></div><div class="line">    $(script).off().remove()</div><div class="line">    <span class="comment">// 请求出错或后端没有给callback中塞入数据，将触发error</span></div><div class="line">    <span class="keyword">if</span> (e.type == <span class="string">'error'</span> || !responseData) &#123;</div><div class="line">      ajaxError(<span class="literal">null</span>, errorType || <span class="string">'error'</span>, xhr, options, deferred)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 请求成功，调用成功回调，请塞入数据responseData[0]</span></div><div class="line">      ajaxSuccess(responseData[<span class="number">0</span>], xhr, options, deferred)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将originalCallback重新赋值回去</span></div><div class="line">    <span class="built_in">window</span>[callbackName] = originalCallback</div><div class="line">    <span class="comment">// 并且判断originalCallback是不是个函数，如果是函数，便执行</span></div><div class="line">    <span class="keyword">if</span> (responseData &amp;&amp; $.isFunction(originalCallback))</div><div class="line">      originalCallback(responseData[<span class="number">0</span>])</div><div class="line">    <span class="comment">// 清空闭包，释放空间</span></div><div class="line">    originalCallback = responseData = <span class="literal">undefined</span></div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ajaxBeforeSend(xhr, options) === <span class="literal">false</span>) &#123;</div><div class="line">    abort(<span class="string">'abort'</span>)</div><div class="line">    <span class="keyword">return</span> xhr</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 重写全局上的callbackName</span></div><div class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    responseData = <span class="built_in">arguments</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 将回调函数名追加到?后面</span></div><div class="line">  script.src = options.url.replace(<span class="regexp">/\?(.+)=\?/</span>, <span class="string">'?$1='</span> + callbackName)</div><div class="line">  <span class="comment">// 添加script元素</span></div><div class="line">  <span class="built_in">document</span>.head.appendChild(script)</div><div class="line">  <span class="comment">// 超时处理函数</span></div><div class="line">  <span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) abortTimeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    abort(<span class="string">'timeout'</span>)</div><div class="line">  &#125;, options.timeout)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> xhr</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参数的基本处理"><a href="#参数的基本处理" class="headerlink" title="参数的基本处理"></a>参数的基本处理</h2><blockquote>
<p>在执行原理的第一步时，zepto会先处理一下我们传入的参数。</p>
</blockquote>
<p>我们先来看看针对上面的例子我们发送请求的url最终会变成什么样子，而参数处理正是为了得到这条url</p>
<p><strong>传了jsonpCallback时的url</strong></p>
<p><code>http://www.abc.com/api/xxx?name=qianlongo&amp;sex=boy&amp;_=1497193375213&amp;callback=globalCallback</code></p>
<p><strong>没有传jsonpCallback时的url</strong></p>
<p><code>http://www.abc.com/api/xxx?name=qianlongo&amp;sex=boy&amp;_=1497193562726&amp;callback=Zepto1497193562723</code></p>
<p>相信你已经看出来这两条url有什么不同之处了。</p>
<p><strong>_后面跟的时间戳不一样</strong></p>
<p><strong>callback后面跟的回调函数名字不一样</strong></p>
<p>也就是说如果你指定了成功的回调函数就用你的，没指定他自己生成一个。</p>
<p><strong>上参数处理代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonpID = +<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"></div><div class="line"><span class="keyword">var</span> _callbackName = options.jsonpCallback,</div><div class="line">callbackName = ($.isFunction(_callbackName) ?</div><div class="line">  _callbackName() : _callbackName) || (<span class="string">'Zepto'</span> + (jsonpID++))</div></pre></td></tr></table></figure>
<p>对于回调函数名的处理其实挺简单的，根据你是否在参数中传了<code>jsonpCallback</code>，传了是个函数就用函数的返回值，不是函数就直接用。<br>否则的话，就生成类似<code>Zepto1497193562723</code>的函数名。</p>
<h2 id="继续看"><a href="#继续看" class="headerlink" title="继续看"></a>继续看</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个script标签用来发送请求 </span></div><div class="line">script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>),</div><div class="line"><span class="comment">// 先读取全局的callbackName函数，因为后面会对该函数重写，所以需要先保存一份</span></div><div class="line">originalCallback = <span class="built_in">window</span>[callbackName],</div><div class="line"><span class="comment">// 请求完成后拿到的数据</span></div><div class="line">responseData,</div><div class="line"><span class="comment">// 中止请求，触发script元素上的error事件, 后面带的参数是回调函数接收的参数</span></div><div class="line">abort = <span class="function"><span class="keyword">function</span> (<span class="params">errorType</span>) </span>&#123;</div><div class="line">  $(script).triggerHandler(<span class="string">'error'</span>, errorType || <span class="string">'abort'</span>)</div><div class="line">&#125;,</div><div class="line">xhr = &#123; <span class="attr">abort</span>: abort &#125;, abortTimeout</div><div class="line"><span class="comment">// 对.then或者.catch形式调用的支持，本文暂时不涉及这方面的解析</span></div><div class="line"><span class="keyword">if</span> (deferred) deferred.promise(xhr)</div></pre></td></tr></table></figure>
<p><strong>好啦，看到这里我们主要要关注的是</strong></p>
<ol>
<li><p><code>originalCallback = window[callbackName]</code></p>
</li>
<li><p><code>abort</code>函数</p>
</li>
</ol>
<p>对于1为什么要把全局的<code>callbackName</code>函数先保存一份呢？这里涉及到一个问题。</p>
<p><strong>请求回来的时候到底是不是直接执行的你传入的jsonpCallback函数？</strong></p>
<p>解决这个问题请看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写全局上的callbackName</span></div><div class="line"><span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  responseData = <span class="built_in">arguments</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zepto中把全局的<code>callbackName</code>函数给重写掉了，，导致后端返回数据时执行该函数，就干了一件事，就是把数据赋值给了<code>responseData</code>这个变量。</p>
<p>那说好的真正的<code>callbackName</code>函数呢？ 如果我传了<code>jsonpCallback</code>，我是会在里面做一些业务逻辑的啊，你都把我给重写了，我的逻辑怎么办？先留个疑问在这里</p>
<p>对于关注点2<code>abort函数</code>，这个函数的功能，就是手动触发添加在创建好的<code>script</code>元素身上的<code>error</code>事件的回调函数。后面的超时处理<code>timeout</code>以及请求出错都是利用的该函数。</p>
<h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><blockquote>
<p>在看监听<code>script</code>元素<code>on error</code>事件回调逻辑前，我们直接看最后一点东西</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将回调函数名追加到?后面</span></div><div class="line">script.src = options.url.replace(<span class="regexp">/\?(.+)=\?/</span>, <span class="string">'?$1='</span> + callbackName)</div><div class="line"><span class="comment">// 添加script元素</span></div><div class="line"><span class="built_in">document</span>.head.appendChild(script)</div><div class="line"><span class="comment">// 超时处理函数</span></div><div class="line"><span class="keyword">if</span> (options.timeout &gt; <span class="number">0</span>) abortTimeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  abort(<span class="string">'timeout'</span>)</div><div class="line">&#125;, options.timeout)</div></pre></td></tr></table></figure>
<p>代理做了简单的注释，这里除了将<code>script</code>元素插入网页还定义了一个超时处理函数，判断条件是传入的参数<code>timeout</code>是否大于0，所以当你传小于0或者负数啥的进去，是不会当做超时处理的。超时后其实就是触发了<code>script</code>元素的<code>error</code>事件，并传了参数<code>timeout</code></p>
<h2 id="真正的回调逻辑处理"><a href="#真正的回调逻辑处理" class="headerlink" title="真正的回调逻辑处理"></a>真正的回调逻辑处理</h2><blockquote>
<p>接下来就是本文的重点了，zepto通过监听<code>script</code>元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLScriptElement" target="_blank" rel="external"><code>load</code>事件</a>来监听请求是否完成，以及给<code>script</code>添加了<code>error</code>事件，方便请求出错和超时处理。而用户需要的成功和失败的处理也是在这里面完成</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">clearTimeout(abortTimeout)</div><div class="line">$(script).off().remove()</div><div class="line"><span class="keyword">if</span> (e.type == <span class="string">'error'</span> || !responseData) &#123;</div><div class="line">  ajaxError(<span class="literal">null</span>, errorType || <span class="string">'error'</span>, xhr, options, deferred)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ajaxSuccess(responseData[<span class="number">0</span>], xhr, options, deferred)</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>[callbackName] = originalCallback</div><div class="line"><span class="keyword">if</span> (responseData &amp;&amp; $.isFunction(originalCallback))</div><div class="line">  originalCallback(responseData[<span class="number">0</span>])</div><div class="line">originalCallback = responseData = <span class="literal">undefined</span></div></pre></td></tr></table></figure>
<p><code>script</code>元素真正的事件处理程序代码也不多，开头有这两句话</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清楚超时定时器</span></div><div class="line">clearTimeout(abortTimeout)</div><div class="line"><span class="comment">// 从网页中移除创建的script元素以及将挂在它上面的所有事件都移除</span></div><div class="line">$(script).off().remove()</div></pre></td></tr></table></figure>
<p>起什么作用呢？</p>
<p>第一句自然是针对超时处理，如果请求在指定超时时间之前完成，自然是要把他清除一下，不然指定的时间到了，超时的回调还是会执行，这是不对的。</p>
<p>第二句话，把创建的script元素从网页中给删除掉，绑定的事件(‘load error’)也全部移除，干嘛要把事件都给移除呢？你想想，一个请求已经发出去了，我们还能让他半途停止吗？该是不能吧，但是我们能够阻止请求回来之后要做的事情呀！而这个回调不就是请求回来之后要做的事情么。</p>
<p><strong>请求成功或失败的处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (e.type == <span class="string">'error'</span> || !responseData) &#123;</div><div class="line">  ajaxError(<span class="literal">null</span>, errorType || <span class="string">'error'</span>, xhr, options, deferred)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ajaxSuccess(responseData[<span class="number">0</span>], xhr, options, deferred)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么再接下来，就是请求的成功或失败的处理了。失败的条件就是触发了<code>error</code>事件(不管是超时还是解析错误，又或者状态码不在HTTP 2xx)，甚至如果后端没有正确给到数据<code>responseData</code>也是错误。</p>
<p><strong>再回顾一下responseData是怎么来的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写全局上的callbackName</span></div><div class="line"><span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  responseData = <span class="built_in">arguments</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ajaxErro函数究竟做了些啥事呢？</strong></p>
<p><code>ajaxError</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// type: "timeout", "error", "abort", "parsererror"</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxError</span>(<span class="params">error, type, xhr, settings, deferred</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> context = settings.context</div><div class="line">  <span class="comment">// 执行用户传进去的error函数，注意这里的context决定了error函数中的this执行</span></div><div class="line">  settings.error.call(context, xhr, type, error)</div><div class="line">  <span class="keyword">if</span> (deferred) deferred.rejectWith(context, [xhr, type, error])</div><div class="line">  <span class="comment">// 触发全局的钩子ajaxError</span></div><div class="line">  triggerGlobal(settings, context, <span class="string">'ajaxError'</span>, [xhr, settings, error || type])</div><div class="line">  <span class="comment">// 调用ajaxComplete函数</span></div><div class="line">  ajaxComplete(type, xhr, settings)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到他调用了我们穿进去的<code>error</code>函数,并且触发了全局的<code>ajaxError</code>钩子，所以我们其实可以在<code>document</code>上监听一个钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'ajaxError'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ajaxError'</span>)</div><div class="line">  <span class="built_in">console</span>.log(e)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个时候便可以拿到请求出错的信息了</p>
<p><code>ajaxComplete</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// status: "success", "notmodified", "error", "timeout", "abort", "parsererror"</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxComplete</span>(<span class="params">status, xhr, settings</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> context = settings.context</div><div class="line">  <span class="comment">// 调用传进来的complete函数</span></div><div class="line">  settings.complete.call(context, xhr, status)</div><div class="line">  <span class="comment">// 触发全局的ajaxComplete钩子</span></div><div class="line">  triggerGlobal(settings, context, <span class="string">'ajaxComplete'</span>, [xhr, settings])</div><div class="line">  <span class="comment">// 请求结束</span></div><div class="line">  ajaxStop(settings)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ajaxStop</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxStop</span>(<span class="params">settings</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (settings.global &amp;&amp; !(--$.active)) triggerGlobal(settings, <span class="literal">null</span>, <span class="string">'ajaxStop'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理我们可以监听<code>ajaxComplete</code>和<code>ajaxStop</code>钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'ajaxComplete ajaxStop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ajaxComplete'</span>)</div><div class="line">  <span class="built_in">console</span>.log(e)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>处理完失败的情况那么接下来就是成功的处理了,主要调用了<code>ajaxSuccess</code>函数</strong></p>
<p><code>ajaxSuccess</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxSuccess</span>(<span class="params">data, xhr, settings, deferred</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> context = settings.context, status = <span class="string">'success'</span></div><div class="line">  <span class="comment">// 调用传进来的成功的回调函数</span></div><div class="line">  settings.success.call(context, data, status, xhr)</div><div class="line">  <span class="keyword">if</span> (deferred) deferred.resolveWith(context, [data, status, xhr])</div><div class="line">  <span class="comment">// 触发全局的ajaxSuccess</span></div><div class="line">  triggerGlobal(settings, context, <span class="string">'ajaxSuccess'</span>, [xhr, settings, data])</div><div class="line">  <span class="comment">// 执行请求完成的回调，成功和失败都执行了该回调</span></div><div class="line">  ajaxComplete(status, xhr, settings)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来我们平时传入的<code>success</code>函数是在这里被执行的。但是有一个疑问啊！，我们知道我们是可以不传入<code>success</code>函数的，当我们指定<code>jsonpCallback</code>的时，请求成功同样会走<code>jsonpCallback</code>函数，但是好像<code>ajaxSuccess</code>没有执行这个函数，具体在处理的呢？</p>
<p><strong>继续往下看</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写全局上的callbackName</span></div><div class="line"><span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  responseData = <span class="built_in">arguments</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 将originalCallback重新赋值回去</span></div><div class="line"><span class="built_in">window</span>[callbackName] = originalCallback</div><div class="line"><span class="comment">// 并且判断originalCallback是不是个函数，如果是函数，便执行</span></div><div class="line"><span class="keyword">if</span> (responseData &amp;&amp; $.isFunction(originalCallback))</div><div class="line">  originalCallback(responseData[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p>为了彻底搞清楚zepto把我们指定的回调函数重写的原因，我再次加了重写的代码在这里。可以看出，重写的目的，就是为了拿到后端返回的数据，而拿到数据之后便方便我们在其他地方灵活的处理了，当然指定的回调函数还是要重新赋值回去(这也是开头要保留一份该函数的本质原因)，如果是个函数，就将数据，塞进去执行。</p>
<p>分析到这里我相信你已经几乎明白了jsonp实现的基本原理，文章顶部说的几个问题，我们也在这个过程中解答了。</p>
<ol>
<li>这中间前端需要做什么？</li>
<li>后端又需要做些什么来支持？(接下来以例子说明)</li>
<li>超时场景又该如何处理？</li>
<li>整个生命周期会有多个钩子可以被触发，而我们可以监听哪些钩子来得知请求的状况?</li>
</ol>
<p>砰砰砰！！！，亲们还记得开头的时候留了这两个问题吗？</p>
<p>在zepto中一个常见的jsonp请求配置就是这样了，大家都很熟悉了。但是不知道大家有没有发现.</p>
<ol>
<li>如果设置了<code>timeout</code>超时了，并且没有设置<code>jsonpCallback</code>字段，那么控制台几乎都会出现一处报错，如下图</li>
</ol>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E9%94%99%E8%AF%AF.png" alt=""></p>
<ol>
<li>同样还是发生在<code>timeout</code>,此时如果请求超时了，并且设置了<code>jsonpCallback</code>字段(注意这个时候是设置了)，但是如果请求在超时之后完成了，你的<code>jsonpCallback</code>还是会被执行。照理说这个函数应该是请求在超时时间内完成才会被执行啊！为毛这个时候超时了，还是会被执行啊！！！</li>
</ol>
<p>问题1：为什么会报错呢？</p>
<p>对于没有指定<code>jsonpCallback</code></p>
<p>此时我们给后端的回调函数名是类似<code>Zepto1497193562723</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>[callbackName] = originalCallback</div></pre></td></tr></table></figure>
<p>超时的时候同样会走<code>load error</code>的回调，当这句话执行的时候，<code>Zepto1497193562723</code>被设置成了undefined，当然后端返回数据的时候去执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Zepto1497193562723(&#123;<span class="attr">xxx</span>: <span class="string">'yyy'</span>&#125;)</div></pre></td></tr></table></figure>
<p>自然就报错了。</p>
<p>问题2呢？ 其实同样还是上面那句话，只不过此时我们指定了<code>jsonpCallback</code>,超时的时候虽然取消了<code>script</code>元素的的<code>load error</code>事件，意味着在超时之后请求即便回来了，也不会走到对应的回调函数中去。但是别忘记，超时我们手动触发了<code>script</code>元素的<code>error</code>事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(script).triggerHandler(<span class="string">'error'</span>, errorType || <span class="string">'abort'</span>)</div></pre></td></tr></table></figure>
<p>原本被重写的callback函数也会被重新赋值回去，此刻，即便<code>script</code>元素的<code>load error</code>回调不会被执行，但我们指定的<code>jsonpCallback</code>还是会被执行的。这也就解了问题2.</p>
<h2 id="用koa做服务端，zepto发jsonp请求"><a href="#用koa做服务端，zepto发jsonp请求" class="headerlink" title="用koa做服务端，zepto发jsonp请求"></a>用koa做服务端，zepto发jsonp请求</h2><blockquote>
<p>最后我们再用koa，模拟服务端的api，用zepto来请求他。</p>
</blockquote>
<p>如果你对源码感兴趣可以点击这里查看<a href="https://github.com/qianlongo/koa-todo-list" target="_blank" rel="external">koa-todo-list</a></p>
<p>找到根目录的<code>testJsonp.js</code>文件即是服务端主要代码</p>
<p><code>前端代码</code></p>
<p><code>html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>请求后端jsonp数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'button'</span>).on(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">  $.ajax(&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">    <span class="attr">url</span>: <span class="string">'/showData'</span>,</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">      <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">dataType</span>: <span class="string">"jsonp"</span>,</div><div class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>)</div><div class="line">      <span class="built_in">console</span>.log(res)</div><div class="line">      $(<span class="string">'&lt;pre&gt;'</span>).text(<span class="built_in">JSON</span>.stringify(res)).appendTo(<span class="string">'body'</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'error'</span>)</div><div class="line">      <span class="built_in">console</span>.log(res)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>服务端主要代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> route = <span class="built_in">require</span>(<span class="string">'koa-route'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> parse = <span class="built_in">require</span>(<span class="string">'co-body'</span>);</div><div class="line"><span class="keyword">var</span> render = <span class="built_in">require</span>(<span class="string">'./app/lib/render.js'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.use(route.get(<span class="string">'/showJsonpPage'</span>, showJsonpPage))</div><div class="line">app.use(route.get(<span class="string">'/showData'</span>, showData))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">showJsonpPage</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sHtml = <span class="keyword">yield</span> render(<span class="string">'jsonp'</span>)</div><div class="line">  <span class="keyword">this</span>.body = sHtml</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">showData</span> (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> &#123;callback, name, sex, randomNum&#125; = <span class="keyword">this</span>.query</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.type = <span class="string">'text/javascript'</span></div><div class="line">  <span class="keyword">let</span> callbackData = &#123;</div><div class="line">    <span class="attr">status</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'ok'</span>,</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">      name,</div><div class="line">      sex,</div><div class="line">      randomNum</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.body = <span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(callbackData)&#125;</span>)`</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.query)</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'listening port 3000'</span>);</div></pre></td></tr></table></figure>
<p>运行截图</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/jsonp.gif" alt=""></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p> 希望把jsonp的实现原理说清楚了，欢迎大家拍砖。</p>
</blockquote>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谁说你只是"会用"jQuery?]]></title>
      <url>https://qianlongo.github.io/2017/06/08/%E8%AF%B4%E8%B0%81%E4%BD%A0%E5%8F%AA%E6%98%AF%E4%BC%9A%E7%94%A8jQuery/</url>
      <content type="html"><![CDATA[<p>前言</p>
<blockquote>
<p>套用上篇文章<a href="https://github.com/qianlongo/zepto-analysis/issues/2" target="_blank" rel="external">向zepto.js学习如何手动触发DOM事件</a> 的开头😀😀😀</p>
</blockquote>
<p>前端在最近几年实在火爆异常，vue、react、angular各路框架层出不穷，咱们要是不知道个双向数据绑定，不晓得啥是虚拟DOM，也许就被鄙视了。火热的背后往往也是无尽的浮躁，学习这些先进流行的类库或者框架可以让我们走的更快，但是静下心来回归基础，把基石打牢固，却可以让我们走的更稳，更远。</p>
<p>最近一直在看zepto的源码，希望通过学习它掌握一些框架设计的技巧，也将很久不再拾起的js基础重新温习巩固一遍。如果你对这个系列感兴趣，欢迎<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击</a><code>watch</code>,随时关注动态。这篇文章主要想说一下zepto中事件模块(event.js)的添加事件<code>on</code>以及移除事件<code>off</code>实现原理，中间会详细地讲解涉及到的细节方面。</p>
<p>如果你想看event.js全文翻译版本，请<a href="https://github.com/qianlongo/zepto-analysis/blob/master/src/event.js" target="_blank" rel="external">点击这里查看</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis/issues/3" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">仓库地址</a></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/11111.jpg" alt=""></p>
<a id="more"></a>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><blockquote>
<p>在没有vue和react，甚至angular都没怎么接触的刀耕火种的时代，jQuery或者zepto是我们手中的利器，是刀刃，他让我们游刃有余地开发出兼容性好的漂亮的网页，我们膜拜并感叹作者带来的便利，沉浸其中，无法自拔。</p>
</blockquote>
<p>但是用了这么久的zepto你知道这样写代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log($(<span class="keyword">this</span>).html())</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>是怎么实现事件委托的吗？为啥此时的<code>this</code>就是你点中的<code>li</code>呢?</p>
<p>平常我们可能还会这样写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(<span class="string">'.list li'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</div><div class="line"></div><div class="line">$(<span class="string">'.list'</span>).delegate(<span class="string">'li'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</div><div class="line"></div><div class="line">$(<span class="string">'.list li'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</div><div class="line"></div><div class="line">$(<span class="string">'.list li'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</div></pre></td></tr></table></figure>
<p>写法有点多，也许你还有其他的写法，那么</p>
<p><code>on</code></p>
<p><code>bind</code></p>
<p><code>delegate</code></p>
<p><code>live</code></p>
<p><code>click()</code></p>
<p>这些添加事件的形式，有什么区别，内部之间又有什么联系呢？</p>
<p>相信你在面试过程中也遇到过类似的问题(<code>看完这边文章，你可以知道答案的噢😯</code>)？</p>
<p>接下来我们从源码的角度一步步去探究其内部实现的原理。</p>
<h2 id="一切从on开始"><a href="#一切从on开始" class="headerlink" title="一切从on开始"></a>一切从<code>on</code>开始</h2><blockquote>
<p>为什么选择从<code>on</code>添加事件的方式开始说起，原因在于其他写法几乎都是<code>on</code>衍生出来的，明白了<code>on</code>的实现原理，其他的也就差不多那么回事了。</p>
</blockquote>
<p><strong>祭出一张画了好久的图</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/on.png" alt=""></p>
<p>上面大概是zepto中<code>on</code>形式注册事件的大致流程，好啦开始看源码啦，首先是on函数，它主要做的事情是注册事件前的参数处理，真正添加事件是内部函数add。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">$.fn.on = <span class="function"><span class="keyword">function</span> (<span class="params">event, selector, data, callback, one</span>) </span>&#123;</div><div class="line">  <span class="comment">// 第一段</span></div><div class="line">  <span class="keyword">var</span> autoRemove, delegator, $<span class="keyword">this</span> = <span class="keyword">this</span></div><div class="line">  <span class="keyword">if</span> (event &amp;&amp; !isString(event)) &#123;</div><div class="line">    $.each(event, <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</div><div class="line">      $<span class="keyword">this</span>.on(type, selector, data, fn, one)</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> $<span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 第二段</span></div><div class="line">  <span class="keyword">if</span> (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== <span class="literal">false</span>)</div><div class="line">    callback = data, data = selector, selector = <span class="literal">undefined</span></div><div class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span> || data === <span class="literal">false</span>)</div><div class="line">    callback = data, data = <span class="literal">undefined</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (callback === <span class="literal">false</span>) callback = returnFalse</div><div class="line"></div><div class="line">  <span class="comment">// 以上为针对不同的调用形式，做好参数处理</span></div><div class="line">  </div><div class="line">  <span class="comment">// 第三段</span></div><div class="line">  <span class="keyword">return</span> $<span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params">_, element</span>) </span>&#123;</div><div class="line">    <span class="comment">// 处理事件只有一次生效的情况</span></div><div class="line">    <span class="keyword">if</span> (one) autoRemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">      remove(element, e.type, callback)</div><div class="line">      <span class="keyword">return</span> callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加事件委托处理函数</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (selector) delegator = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> evt, match = $(e.target).closest(selector, element).get(<span class="number">0</span>)</div><div class="line">      <span class="keyword">if</span> (match &amp;&amp; match !== element) &#123;</div><div class="line">        evt = $.extend(createProxy(e), &#123; <span class="attr">currentTarget</span>: match, <span class="attr">liveFired</span>: element &#125;)</div><div class="line">        <span class="keyword">return</span> (autoRemove || callback).apply(match, [evt].concat(slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)))</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使用add内部函数真正去给选中的元素注册事件</span></div><div class="line"></div><div class="line">    add(element, event, callback, data, selector, delegator || autoRemove)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接看到这么一大坨的代码不易于理解，我们分段进行阅读。</p>
<p><strong>第一段</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> autoRemove, delegator, $<span class="keyword">this</span> = <span class="keyword">this</span></div><div class="line">  <span class="keyword">if</span> (event &amp;&amp; !isString(event)) &#123;</div><div class="line">    $.each(event, <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</div><div class="line">      $<span class="keyword">this</span>.on(type, selector, data, fn, one)</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> $<span class="keyword">this</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这段代码主要是为了处理下面这种调用形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.list li'</span>).on(&#123;</div><div class="line">  <span class="attr">click</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log($(<span class="keyword">this</span>).html())</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mouseover</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="keyword">this</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'red'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mouseout</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="keyword">this</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'green'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这种写法我们平时写的比较少一点，但是确实是支持的。而zepto的处理方式则是循环调用<code>on</code>方法，以<code>key</code>为事件名，<code>val</code>为事件处理函数。</p>
<p>在开始第二段代码阅读前，我们先回顾一下，平时经常使用<code>on</code>来注册事件的写法一般有哪些</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这种我们使用的也许最多了</span></div><div class="line">on(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 可以预先添加数据data，然后在回调函数中使用e.data来使用添加的数据</span></div><div class="line">on(type, data, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 事件代理形式</span></div><div class="line">on(type, [selector], <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 当然事件代理的形式也可以预先添加data</span></div><div class="line">on(type, [selector], data, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; ... &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 当然也可以只让事件只有一次起效</span></div><div class="line"></div><div class="line">on(type, [selector], data, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>还会有其他的写法，但是常见的可能就是这些，第二段代码就是处理这些参数以让后续的事件正确添加。</p>
<p><strong>第二段</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// selector不是字符串形式，callback也不是函数</span></div><div class="line"><span class="keyword">if</span> (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== <span class="literal">false</span>)</div><div class="line">    callback = data, data = selector, selector = <span class="literal">undefined</span></div><div class="line">    <span class="comment">// 处理data没有传或者传了函数</span></div><div class="line">  <span class="keyword">if</span> (callback === <span class="literal">undefined</span> || data === <span class="literal">false</span>)</div><div class="line">    callback = data, data = <span class="literal">undefined</span></div><div class="line">    <span class="comment">// callback可以传false值，将其转换为returnFalse函数</span></div><div class="line">  <span class="keyword">if</span> (callback === <span class="literal">false</span>) callback = returnFalse</div></pre></td></tr></table></figure>
<p>三个if语句很好的处理了多种使用情况的参数处理。也许直接看不能知晓到底是如何做到的，可以试试每种使用情况都代入其中，找寻其是如何兼容的。</p>
<p><strong>接下来我们第三段</strong></p>
<p>这段函数做了非常重要的两件事</p>
<ol>
<li>处理one传入为true，事件只触发一次的场景</li>
<li>处理传入了selector，进行事件代理处理函数开发</li>
</ol>
<p>我们一件件看它如何实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (one) autoRemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  remove(element, e.type, callback)</div><div class="line">  <span class="keyword">return</span> callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部用了一个<code>remove</code>函数，这里先不做解析，只要知道他就是移除事件的函数就可以，当移除事件的时候，再执行了传进来的回调函数。进而实现只调用一次的效果。</p>
<p><strong>那么事件代理又是怎么实现咧？</strong></p>
<p>回想一下平常自己是怎么写事件代理的，一般是利用事件冒泡（当然也可以使用事件捕获）的性质，将子元素的事件委托到祖先元素身上，不仅可以实现事件的动态性，还可以减少事件总数，提高性能。</p>
<p><strong>举个例子</strong></p>
<p>我们把原本要添加到li上的事件委托到父元素ul上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> $list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>)</div><div class="line"></div><div class="line">$list.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  e = e || <span class="built_in">window</span>.event</div><div class="line">  <span class="keyword">let</span> target = e.target || e.srcElement</div><div class="line">  <span class="keyword">if</span> (target.tagName.toLowerCase() === <span class="string">'li'</span>) &#123;</div><div class="line">    target.style.background = <span class="string">'red'</span></div><div class="line">  &#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p><a href="https://qianlongo.github.io/zepto-analysis/example/event/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B.html">点击查看效果</a></p>
<p><strong>回到第三段</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (selector) delegator = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">   <span class="comment">// 这里用了closest函数，查找到最先符合selector条件的元素</span></div><div class="line">   <span class="keyword">var</span> evt, match = $(e.target).closest(selector, element).get(<span class="number">0</span>)</div><div class="line">   <span class="comment">// 查找到的最近的符合selector条件的节点不能是element元素</span></div><div class="line">   <span class="keyword">if</span> (match &amp;&amp; match !== element) &#123;</div><div class="line">     <span class="comment">// 然后将match节点和element节点，扩展到事件对象上去</span></div><div class="line">     evt = $.extend(createProxy(e), &#123; <span class="attr">currentTarget</span>: match, <span class="attr">liveFired</span>: element &#125;)</div><div class="line">     <span class="comment">// 最后便是执行回调函数</span></div><div class="line">     <span class="keyword">return</span> (autoRemove || callback).apply(match, [evt].concat(slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)))</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>zepto中实现事件代理的基本原理是：<strong>以当前目标元素<code>e.target</code>为起点向上查找到最先符合<code>selector</code>选择器规则的元素，然后扩展了事件对象，添加了一些属性，最后以找到的match元素作为回调函数的内部<code>this</code>作用域，并将扩展的事件对象作为回调函数的第一个参数传进去执行。</strong></p>
<p>这里需要知道<code>.closest(...)</code>api的具体使用，如果你不太熟悉，请<a href="http://www.runoob.com/manual/zeptojs.html#closest" target="_blank" rel="external">点击这里</a>查看</p>
<p>说道这里，事件还没有添加啊！到底在哪里添加的呢,on函数的最后一句，便是要进入事件添加了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">add(element, event, callback, data, selector, delegator || autoRemove)</div></pre></td></tr></table></figure>
<h2 id="参数处理完，开始真正的给元素添加事件了"><a href="#参数处理完，开始真正的给元素添加事件了" class="headerlink" title="参数处理完，开始真正的给元素添加事件了"></a>参数处理完，开始真正的给元素添加事件了</h2><blockquote>
<p>zepto的内部真正给元素添加事件的地方在add函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">element, events, fn, data, selector, delegator, capture</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = zid(element), </div><div class="line">      set = (handlers[id] || (handlers[id] = []))</div><div class="line"></div><div class="line">  events.split(<span class="regexp">/\s/</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event == <span class="string">'ready'</span>) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(fn)</div><div class="line">    <span class="keyword">var</span> handler = parse(event)</div><div class="line">    handler.fn = fn</div><div class="line">    handler.sel = selector</div><div class="line">    <span class="comment">// emulate mouseenter, mouseleave</span></div><div class="line">    <span class="keyword">if</span> (handler.e <span class="keyword">in</span> hover) fn = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> related = e.relatedTarget</div><div class="line">      <span class="keyword">if</span> (!related || (related !== <span class="keyword">this</span> &amp;&amp; !$.contains(<span class="keyword">this</span>, related)))</div><div class="line">        <span class="keyword">return</span> handler.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handler.del = delegator</div><div class="line">    <span class="keyword">var</span> callback = delegator || fn</div><div class="line">    handler.proxy = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">      e = compatible(e)</div><div class="line">      <span class="keyword">if</span> (e.isImmediatePropagationStopped()) <span class="keyword">return</span></div><div class="line">      e.data = data</div><div class="line">      <span class="keyword">var</span> result = callback.apply(element, e._args == <span class="literal">undefined</span> ? [e] : [e].concat(e._args))</div><div class="line">      <span class="keyword">if</span> (result === <span class="literal">false</span>) e.preventDefault(), e.stopPropagation()</div><div class="line">      <span class="keyword">return</span> result</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handler.i = set.length</div><div class="line">    set.push(handler)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="string">'addEventListener'</span> <span class="keyword">in</span> element)</div><div class="line">      element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的神，又是这么长长长长的一大坨，人艰不拆，看着心累啊啊啊啊！！！<br>不过不用急，只要一步步去看，最终肯定可以看懂的。</p>
<p><strong>开头有一句话</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> id = zid(element)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">zid</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> element._zid || (element._zid = _zid++)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>zepto中会给添加事件的元素身上加一个唯一的标志，_zid从1开始不断往上递增。后面的事件移除函数都是基于这个id来和元素建立关联的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码初始地方定义</span></div><div class="line"><span class="keyword">var</span> handlers = &#123;&#125;, </div><div class="line"></div><div class="line"></div><div class="line">set = (handlers[id] || (handlers[id] = []))</div></pre></td></tr></table></figure>
<p><code>handlers</code>便是事件缓冲池，以数字0, 1, 2, 3…保存着一个个元素的事件处理程序。来看看handlers长啥样。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/1111111.png" alt=""></p>
<p><code>html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>javascript</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="string">''</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e)</div><div class="line">&#125;, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>以上截图便是这段代码执行后得到的handlers，其本身是个对象，每个key(1, 2, 3 …)(这个key也是和元素身上的_zid属性一一对应的)都保存着一个数组，而数组中的每一项目都保存着一个与事件类型相关的对象。我们来看看,每个key的数组都长啥样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="attr">e</span>: <span class="string">'click'</span>, <span class="comment">// 事件名称</span></div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 用户传入的回调函数</span></div><div class="line">    i: <span class="number">0</span>, <span class="comment">// 该对象在该数组中的索引</span></div><div class="line">    ns: <span class="string">'qianlongo'</span>, <span class="comment">// 命名空间</span></div><div class="line">    proxy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 真正给dom绑定事件时执行的事件处理程序， 为del或者fn</span></div><div class="line">    sel: <span class="string">'.qianlongo'</span>, <span class="comment">// 进行事件代理时传入的选择器</span></div><div class="line">    del: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 事件代理函数</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">e</span>: <span class="string">'mouseover'</span>, <span class="comment">// 事件名称</span></div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 用户传入的回调函数</span></div><div class="line">    i: <span class="number">1</span>, <span class="comment">// 该对象在该数组中的索引</span></div><div class="line">    ns: <span class="string">'qianlongo'</span>, <span class="comment">// 命名空间</span></div><div class="line">    proxy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 真正给dom绑定事件时执行的事件处理程序， 为del或者fn</span></div><div class="line">    sel: <span class="string">'.qianlongo'</span>, <span class="comment">// 进行事件代理时传入的选择器</span></div><div class="line">    del: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 事件代理函数</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这样的设置给后面事件的移除带了很大的便利。画个简单的图，看看元素添加的事件和handlers中的映射关系。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/guanxi.png" alt=""></p>
<p>明白了他们之间的映射关系，我们再回到源码处，继续看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">events.split(<span class="regexp">/\s/</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>暂时去除了一些内部代码逻辑，我们看到其对<code>event</code>做了切分，并循环添加事件，这也是我们像下面这样添加事件的原因</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'li'</span>).on(<span class="string">'click mouseover mouseout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</div></pre></td></tr></table></figure>
<p>那么接下来我们要关注的就是循环的内部细节了。添加了部分注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果是ready事件，就直接调用ready方法(这里的return貌似无法结束forEach循环吧)</span></div><div class="line"><span class="keyword">if</span> (event == <span class="string">'ready'</span>) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(fn)</div><div class="line"><span class="comment">// 得到事件和命名空间分离的对象 'click.qianlongo' =&gt; &#123;e: 'click', ns: 'qianlongo'&#125;</span></div><div class="line"><span class="keyword">var</span> handler = parse(event)</div><div class="line"><span class="comment">// 将用户输入的回调函数挂载到handler上</span></div><div class="line">handler.fn = fn</div><div class="line"><span class="comment">// 将用户传入的选择器挂载到handler上（事件代理有用）</span></div><div class="line">handler.sel = selector</div><div class="line"><span class="comment">// 用mouseover和mouseout分别模拟mouseenter和mouseleave事件</span></div><div class="line"><span class="comment">// https://qianlongo.github.io/zepto-analysis/example/event/mouseEnter-mouseOver.html(mouseenter与mouseover为何这般纠缠不清？)</span></div><div class="line"><span class="comment">// emulate mouseenter, mouseleave</span></div><div class="line"><span class="keyword">if</span> (handler.e <span class="keyword">in</span> hover) fn = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> related = e.relatedTarget</div><div class="line">  <span class="keyword">if</span> (!related || (related !== <span class="keyword">this</span> &amp;&amp; !$.contains(<span class="keyword">this</span>, related)))</div><div class="line">    <span class="keyword">return</span> handler.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line">handler.del = delegator</div><div class="line"><span class="comment">// 注意需要事件代理函数（经过一层处理过后的）和用户输入的回调函数优先使用事件代理函数</span></div><div class="line"><span class="keyword">var</span> callback = delegator || fn</div><div class="line"><span class="comment">// proxy是真正绑定的事件处理程序</span></div><div class="line"><span class="comment">// 并且改写了事件对象event</span></div><div class="line"><span class="comment">// 添加了一些方法和属性，最后调用用户传入的回调函数，如果该函数返回false，则认为需要阻止默认行为和阻止冒泡</span></div><div class="line">handler.proxy = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  e = compatible(e)</div><div class="line">  <span class="keyword">if</span> (e.isImmediatePropagationStopped()) <span class="keyword">return</span></div><div class="line">  e.data = data</div><div class="line">  <span class="keyword">var</span> result = callback.apply(element, e._args == <span class="literal">undefined</span> ? [e] : [e].concat(e._args))</div><div class="line">  <span class="comment">// 如果回调函数返回false，那么将阻止冒泡和阻止浏览器默认行为</span></div><div class="line">  <span class="keyword">if</span> (result === <span class="literal">false</span>) e.preventDefault(), e.stopPropagation()</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将该次添加的handler在set中的索引赋值给i</span></div><div class="line">handler.i = set.length</div><div class="line"><span class="comment">// 把handler保存起来,注意因为一个元素的同一个事件是可以添加多个事件处理程序的</span></div><div class="line">set.push(handler)</div><div class="line"><span class="comment">// 最后当然是绑定事件</span></div><div class="line"><span class="keyword">if</span> (<span class="string">'addEventListener'</span> <span class="keyword">in</span> element)</div><div class="line">  element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))</div></pre></td></tr></table></figure>
<p>至此，添加事件到这里告一段落了。让我们再回到文章初始的问题，</p>
<p><code>on</code></p>
<p><code>bind</code></p>
<p><code>delegate</code></p>
<p><code>live</code></p>
<p><code>click()</code></p>
<p>这些添加事件的形式，有什么区别，内部之间又有什么联系呢？其实看他们的源码大概就知道区别</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定事件</span></div><div class="line">$.fn.bind = <span class="function"><span class="keyword">function</span> (<span class="params">event, data, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.on(event, data, callback)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 小范围冒泡绑定事件</span></div><div class="line">$.fn.delegate = <span class="function"><span class="keyword">function</span> (<span class="params">selector, event, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.on(event, selector, callback)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将事件冒泡代理到body上  </span></div><div class="line">$.fn.live = <span class="function"><span class="keyword">function</span> (<span class="params">event, callback</span>) </span>&#123;</div><div class="line">  $(<span class="built_in">document</span>.body).delegate(<span class="keyword">this</span>.selector, event, callback)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 绑定以及触发事件的快件方式</span></div><div class="line"><span class="comment">// 比如 $('li').click(() =&gt; &#123;&#125;)</span></div><div class="line"></div><div class="line">; (<span class="string">'focusin focusout focus blur load resize scroll unload click dblclick '</span> +</div><div class="line">  <span class="string">'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '</span> +</div><div class="line">  <span class="string">'change select keydown keypress keyup error'</span>).split(<span class="string">' '</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    $.fn[event] = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> (<span class="number">0</span> <span class="keyword">in</span> <span class="built_in">arguments</span>) ?</div><div class="line">        <span class="comment">// click() 形式的调用内部还是用了bind</span></div><div class="line">        <span class="keyword">this</span>.bind(event, callback) :</div><div class="line">        <span class="keyword">this</span>.trigger(event)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>bind和click()函数都是直接将事件绑定到元素身上，live则代理到body元素身上，delegate是小范围是事件代理，性能在由于live，on就最厉害了，以上函数都可以用on实现调用。</p>
<h2 id="事件移除的具体实现"><a href="#事件移除的具体实现" class="headerlink" title="事件移除的具体实现"></a>事件移除的具体实现</h2><blockquote>
<p>事件移除的实现有赖于事件绑定的实现，绑定的时候，把真正注册的事件信息都和dom关联起来放在了handlers中，那么移除具体是如何实现的呢？我们一步步来看。</p>
</blockquote>
<p>同样先放一张事件移除的大致流程图</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/off.png" alt=""></p>
<p><strong>off函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> $.fn.off = <span class="function"><span class="keyword">function</span> (<span class="params">event, selector, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> $<span class="keyword">this</span> = <span class="keyword">this</span></div><div class="line">  <span class="comment">// &#123;click: clickFn, mouseover: mouseoverFn&#125;</span></div><div class="line">  <span class="comment">// 传入的是对象，循环遍历调用本身解除事件</span></div><div class="line">  <span class="keyword">if</span> (event &amp;&amp; !isString(event)) &#123;</div><div class="line">    $.each(event, <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</div><div class="line">      $<span class="keyword">this</span>.off(type, selector, fn)</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> $<span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ('click', fn)</span></div><div class="line">  <span class="keyword">if</span> (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== <span class="literal">false</span>)</div><div class="line">    callback = selector, selector = <span class="literal">undefined</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (callback === <span class="literal">false</span>) callback = returnFalse</div><div class="line">  <span class="comment">// 循环遍历删除绑定在元素身上的事件，如何解除，可以看remove</span></div><div class="line">  <span class="keyword">return</span> $<span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    remove(<span class="keyword">this</span>, event, callback, selector)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>off函数基本上和on函数是一个套路，先做一些基本的参数解析，然后把移除事件的具体工作交给remove函数实现，所以我们主要看remove函数。</p>
<p><strong>remove函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 删除事件，off等方法底层用的该方法</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">element, events, fn, selector, capture</span>) </span>&#123;</div><div class="line">  <span class="comment">// 得到添加事件的时候给元素添加的标志id</span></div><div class="line">  <span class="keyword">var</span> id = zid(element)</div><div class="line">  <span class="comment">// 循环遍历要移除的事件(所以我们用的时候，可以一次性移除多个事件)</span></div><div class="line">    ; (events || <span class="string">''</span>).split(<span class="regexp">/\s/</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">      <span class="comment">// findHandlers返回的是符合条件的事件响应集合</span></div><div class="line">      findHandlers(element, event, fn, selector).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</div><div class="line">        <span class="comment">// [&#123;&#125;, &#123;&#125;, &#123;&#125;]每个元素添加的事件形如该结构</span></div><div class="line">        <span class="comment">// 删除存在handlers上的响应函数</span></div><div class="line">        <span class="keyword">delete</span> handlers[id][handler.i]</div><div class="line">        <span class="comment">// 真正删除绑定在element上的事件及其事件处理函数</span></div><div class="line">        <span class="keyword">if</span> (<span class="string">'removeEventListener'</span> <span class="keyword">in</span> element)</div><div class="line">          element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续往下走，一个重要的函数<strong>findHandlers</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据给定的element、event等参数从handlers中查找handler，</span></div><div class="line"><span class="comment">// 主要用于事件移除(remove)和主动触发事件(triggerHandler)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findHandlers</span>(<span class="params">element, event, fn, selector</span>) </span>&#123;</div><div class="line">  <span class="comment">// 解析event，从而得到事件名称和命名空间</span></div><div class="line">  event = parse(event)</div><div class="line">  <span class="keyword">if</span> (event.ns) <span class="keyword">var</span> matcher = matcherFor(event.ns)</div><div class="line">  <span class="comment">// 读取添加在element身上的handler(数组)，并根据event等参数帅选</span></div><div class="line">  <span class="keyword">return</span> (handlers[zid(element)] || []).filter(<span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> handler</div><div class="line">      &amp;&amp; (!event.e || handler.e == event.e) <span class="comment">// 事件名需要相同</span></div><div class="line">      &amp;&amp; (!event.ns || matcher.test(handler.ns)) <span class="comment">// 命名空间需要相同</span></div><div class="line">      &amp;&amp; (!fn || zid(handler.fn) === zid(fn)) <span class="comment">// 回调函数需要相同（话说为什么通过zid()这个函数来判断呢？）</span></div><div class="line">      &amp;&amp; (!selector || handler.sel == selector) <span class="comment">// 事件代理时选择器需要相同</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为注册事件的时候回调函数不是用户传入的fn，而是自定义之后的proxy函数，所以需要将用户此时传入的fn和handler中保存的fn相比较是否相等。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>罗里吧嗦说了好多，不知道有没有把zepto中的事件处理部分说明白说详细，欢迎大家提意见。</p>
</blockquote>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
<p>如果对你有一点点帮助，<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">点击这里</a>,加一个小星星好不好呀</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[向zepto.js学习如何手动触发DOM事件]]></title>
      <url>https://qianlongo.github.io/2017/06/07/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91DOM%E4%BA%8B%E4%BB%B6%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前端在最近几年实在火爆异常，vue、react、angular各路框架层出不穷，咱们要是不知道个双向数据绑定，不晓得啥是虚拟DOM，也许就被鄙视了。火热的背后往往也是无尽的浮躁，学习这些先进流行的类库或者框架可以让我们走的更快，但是静下心来回归基础，把基石打牢固，却可以让我们走的更稳，更远。</p>
</blockquote>
<p>最近一直在看zepto的源码，希望通过学习它掌握一些框架设计的技巧，也将很久不再拾起的js基础重新温习巩固一遍。如果你对这个系列感兴趣，欢迎点击下方地址<code>watch</code>,随时关注动态。这篇文章主要想说一下zepto中事件模块(event.js)的<code>trigger</code>实现原理。</p>
<p><a href="https://github.com/qianlongo/zepto-analysis/issues/2" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">仓库地址</a></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/11111.jpg" alt=""></p>
<a id="more"></a>
<h2 id="event-js模块"><a href="#event-js模块" class="headerlink" title="event.js模块"></a>event.js模块</h2><blockquote>
<p>zepto中由许多小的模块组合合成，基础的<code>zepto.js</code>模块,<code>event.js</code>事件处理模块,<code>ajax.js</code>请求处理模块等等。其中<code>event.js</code>事件处理模块的核心完成了zepto中事件绑定<code>on</code>，移除<code>off</code>还有手动触发<code>trigger</code>等功能。我们简单回顾下如何使用zepto的这三大功能。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> $list = $(<span class="string">'.list'</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">e, name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>, name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cb2 = <span class="function"><span class="keyword">function</span> (<span class="params">e, name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>, name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">$list.on(<span class="string">'click'</span>, cb1)</div><div class="line">$list.on(<span class="string">'click'</span>, cb2)</div><div class="line"></div><div class="line"><span class="comment">// 移除事件</span></div><div class="line"></div><div class="line"><span class="comment">// 我们可以指定移除click事件的某个事件处理程序</span></div><div class="line">$list.off(<span class="string">'click'</span>, cb1)</div><div class="line"><span class="comment">// 也可以直接移除click事件</span></div><div class="line">$list.off(<span class="string">'click'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 手动触发事件</span></div><div class="line">$list.trigger(<span class="string">'click'</span>, <span class="string">'qianlongo'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://odssgnnpf.bkt.clouddn.com/timg2.jpeg" alt=""></p>
<p>哥们你逗我呢，jQuery，zepto多熟了，谁不会用这个啊！客观别急，我们今天主要是慢慢来看看它源码怎么实现的。</p>
<h2 id="一步步看trigger怎么实现"><a href="#一步步看trigger怎么实现" class="headerlink" title="一步步看trigger怎么实现"></a>一步步看trigger怎么实现</h2><blockquote>
<p>直接上代码</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$.fn.trigger = <span class="function"><span class="keyword">function</span> (<span class="params">event, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// 对传入的event进行处理，如果是字符串或者纯对象，得到一个自己创建的事件对象</span></div><div class="line">  <span class="comment">// 如果传入的已经是个经过$.Event处理的对象，则放入compatible再次改造(其实就是添加了几个方法，和重写了几个方法)</span></div><div class="line">  event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)</div><div class="line">  <span class="comment">// args传递给事件处理程序的参数</span></div><div class="line">  event._args = args</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// handle focus(), blur() by calling them directly</span></div><div class="line">    <span class="keyword">if</span> (event.type <span class="keyword">in</span> focus &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>[event.type] == <span class="string">"function"</span>) <span class="keyword">this</span>[event.type]()</div><div class="line">    <span class="comment">// items in the collection might not be DOM elements</span></div><div class="line">    <span class="comment">// 触发dom事件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'dispatchEvent'</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">this</span>.dispatchEvent(event)</div><div class="line">    <span class="comment">// 因为zepto对象内部的元素不一定是dom元素，此时直接触发回调函数</span></div><div class="line">    <span class="keyword">else</span> $(<span class="keyword">this</span>).triggerHandler(event, args)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>直接贴出trigger函数的代码可能我们是懵逼的</strong></p>
<p><code>$</code>是啥啊！！！</p>
<p><code>$.fn</code>是啥啊！！！</p>
<p><code>$.isPlainObject</code>又是啥啊！！！</p>
<p><code>$.Event</code>又是什么鬼？</p>
<p>仿佛有一连串的问题等待着我们解决。</p>
<p>为了直接切入不易理解，我们先来看看zepto中是如何给基础的<code>zepto.js</code>模块添加功能的</p>
<p><strong>首先看看zepto.js模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// xxxx</span></div><div class="line">  <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> $</div><div class="line"></div><div class="line">  zepto.Z.prototype = Z.prototype = $.fn</div><div class="line">  <span class="comment">// xxxx</span></div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto</div><div class="line"><span class="built_in">window</span>.$ === <span class="literal">undefined</span> &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</div></pre></td></tr></table></figure>
<p>尽量删除了一些不必要的代码，可以看到我们平时使用的<code>Zepto</code>其实就是其匿名函数自执行内部导出的一个函数。而<code>$.fn</code>就是其原型</p>
<p><strong>如何给zepto.js模块增添功能</strong></p>
<p><code>zepto.js</code>模块只有一些基础的功能，比如给dom添加事件的功能就没有，怎么添加呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  $.fn.on = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//xxxx&#125;</span></div><div class="line">  $.fn.off = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//xxxx&#125;</span></div><div class="line">  $.fn.trigger = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//xxxx&#125;</span></div><div class="line">  $.Event = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//xxx&#125;</span></div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;)(Zepto)</div></pre></td></tr></table></figure>
<p>最后缩减掉其他的干扰代码,可以看到所谓的给<code>zepto.js</code>模块增添功能，基本上就是在其原型上添加新的方法或者直接在$函数上定一些静态方法。</p>
<p>好啦我们已经解决了<code>$</code>,<code>$.fn</code>是啥的疑问了，现在回去开始一步步解读如何实现手动触发事件。</p>
<h2 id="重新看trigger函数源码"><a href="#重新看trigger函数源码" class="headerlink" title="重新看trigger函数源码"></a>重新看trigger函数源码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.fn.trigger = <span class="function"><span class="keyword">function</span> (<span class="params">event, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// 对传入的event进行处理，如果是字符串或者纯对象，得到一个自己创建的事件对象</span></div><div class="line">  <span class="comment">// 如果传入的已经是个经过$.Event处理的对象，则放入compatible再次改造(其实就是添加了几个方法，和重写了几个方法)</span></div><div class="line">  event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)</div><div class="line">  <span class="comment">// args传递给事件处理程序的参数</span></div><div class="line">  event._args = args</div><div class="line"></div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先把后面的一些代码给删除了，我们先理解这几句代码。其中非常重要的一个函数就是<code>$.Event</code>,至于</p>
<p><code>isString</code> =&gt; 判断是不是字符串</p>
<p><code>isPlainObject</code> =&gt; 判断是不是存粹的对象(必须是对象，window对象除外，该对象的原型必须和Object的原型一致)</p>
<p><code>compatible</code> =&gt; 其实就是对事件对象<code>event</code>做一些扩展，比如添加一些方法，重写一些方法之类的。</p>
<p>这几个方法暂时可以不需要太多关心.</p>
<p>我们主要看看<code>$.Event</code>,这里面几乎含有如何手动触发一个dom事件的大部分步骤和内容。</p>
<p>我们主要看看<code>$.Event</code>,这里面几乎含有如何手动触发一个dom事件的大部分步骤和内容。</p>
<p>我们主要看看<code>$.Event</code>,这里面几乎含有如何手动触发一个dom事件的大部分步骤和内容。</p>
<h2 id="Event是个啥"><a href="#Event是个啥" class="headerlink" title="$.Event是个啥"></a>$.Event是个啥</h2><blockquote>
<p> 创建并初始化一个指定的dom事件对象, 如果给定了props，则将其扩展到事件对象上</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> $.Event = <span class="function"><span class="keyword">function</span> (<span class="params">type, props</span>) </span>&#123;</div><div class="line">  <span class="comment">// 当type是个对象时,比如&#123;type: 'click', data: 'qianlongo'&#125;</span></div><div class="line">  <span class="keyword">if</span> (!isString(type)) props = type, type = props.type</div><div class="line">  <span class="comment">// click,mousedown,mouseup mousemove对应MouseEvent</span></div><div class="line">  <span class="comment">// 其他事件对应为Events</span></div><div class="line">  <span class="comment">// 并把bubbles设置为true，表示事件冒泡，为false则不冒泡</span></div><div class="line">  <span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(specialEvents[type] || <span class="string">'Events'</span>), bubbles = <span class="literal">true</span></div><div class="line">  <span class="comment">// 当props存在的时候，对props进行循环处理，将其属性扩展到event对象上</span></div><div class="line">  <span class="keyword">if</span> (props) <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> props) (name == <span class="string">'bubbles'</span>) ? (bubbles = !!props[name]) : (event[name] = props[name])</div><div class="line">  <span class="comment">// 初始化事件对象，第一个为事件类型，第二个为冒泡与否，第三个为是否可以通过preventDefault来阻止浏览器默认行为</span></div><div class="line">  event.initEvent(type, bubbles, <span class="literal">true</span>)</div><div class="line">  <span class="comment">// 再对创造出来的时间对象处理一番并返回</span></div><div class="line">  <span class="keyword">return</span> compatible(event)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注释已经写的很清楚了，这个函数就是返回一个经过初始化了的事件对象</strong></p>
<p>到这里我们直接归纳一下要手动触发一个dom事件的基本步骤</p>
<p>手动触发一个dom事件，需要3步，如果你对<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createEvent" target="_blank" rel="external">document.createEvent</a>,不是很熟悉，可以点击查看。</p>
<ol>
<li>创建一个事件对象 document.createEvent(event)</li>
<li>初始化事件对象 event.initEvent(type, bubbles, true)</li>
<li>分发事件  dom.dispatchEvent(event)</li>
</ol>
<p>到这里已经完成了前面两步，还剩最后一步了，在来看<code>trigger</code>剩下的代码</p>
<h2 id="手动触发dom事件最后一步"><a href="#手动触发dom事件最后一步" class="headerlink" title="手动触发dom事件最后一步"></a>手动触发dom事件最后一步</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> $.fn.trigger = <span class="function"><span class="keyword">function</span> (<span class="params">event, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// 对传入的event进行处理，如果是字符串或者纯对象，得到一个自己创建的事件对象</span></div><div class="line">  <span class="comment">// 如果传入的已经是个经过$.Event处理的对象，则放入compatible再次改造(其实就是添加了几个方法，和重写了几个方法)</span></div><div class="line">  event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)</div><div class="line">  <span class="comment">// args传递给事件处理程序的参数</span></div><div class="line">  event._args = args</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// handle focus(), blur() by calling them directly</span></div><div class="line">    <span class="keyword">if</span> (event.type <span class="keyword">in</span> focus &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>[event.type] == <span class="string">"function"</span>) <span class="keyword">this</span>[event.type]()</div><div class="line">    <span class="comment">// items in the collection might not be DOM elements</span></div><div class="line">    <span class="comment">// 触发dom事件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'dispatchEvent'</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">this</span>.dispatchEvent(event)</div><div class="line">    <span class="comment">// 因为zepto对象内部的元素不一定是dom元素，此时直接触发回调函数</span></div><div class="line">    <span class="keyword">else</span> $(<span class="keyword">this</span>).triggerHandler(event, args)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一步其实就是将当前选中的元素进行一次each遍历，然后判断要触发的事件是不是<code>focus</code>或者<code>blur</code>，如果是就直接执行。</p>
<p>再进一步，如果<code>dispatchEvent</code>方法在当前的dom元素属性中存在，那么便将该事件触发。(为什么要这一步呢？因为我们知道$()函数的使用方式有很多，有些方式得到的zepto对象是没有选中dom节点的)</p>
<p>最后还有一个else分支，这个分支处理走的不是手动触发事件，而是直接触发注册事件时添加的事件处理程序(因为这里涉及到zepto事件模块中如何管理元素与事件队列的映射关系，篇幅会比较长，会在接下来的文章中说，这里不展开说明)</p>
<h2 id="手动diy一个"><a href="#手动diy一个" class="headerlink" title="手动diy一个"></a>手动diy一个</h2><blockquote>
<p>根据上面的描述，手动触发DOM事件，原来并没有那么神奇，完成三步，即可达到目标。我们自己来手动写一个示例</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> $list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>)</div><div class="line"><span class="keyword">let</span> $item1 = <span class="built_in">document</span>.querySelector(<span class="string">'.item1'</span>)</div><div class="line"></div><div class="line">$list.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</div><div class="line">&#125;, <span class="literal">false</span>)</div><div class="line"></div><div class="line">$item1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</div><div class="line">&#125;, <span class="literal">false</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1. 创建一个事件对象 document.createEvent(event)</span></div><div class="line"><span class="keyword">let</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>)</div><div class="line"><span class="comment">// 2. 初始化事件对象 event.initEvent(type, bubbles, true)</span></div><div class="line">event.initEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">true</span>)</div><div class="line"><span class="comment">// 3. 分发事件  dom.dispatchEvent(event)</span></div><div class="line">$item1.dispatchEvent(event)</div></pre></td></tr></table></figure>
<p>这个时候控制台打印出了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"></div><div class="line">&lt;li class="item1"&gt;1&lt;/li&gt;</div><div class="line">&lt;li&gt;2&lt;/li&gt;</div><div class="line">&lt;li&gt;3&lt;/li&gt;</div></pre></td></tr></table></figure>
<p>1是item1的事件处理函数打印出来的。</p>
<p>后面的li那部分则是list打印出来的。</p>
<p>如果将initEvent的第二个参数设置为false，将不允许冒泡，则只会打印出1</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>如果这部分对你有点点帮助，点个star好不好呀！ 😀😀😀</p>
</blockquote>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">仓库地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mouseenter与mouseover为何这般纠缠不清？]]></title>
      <url>https://qianlongo.github.io/2017/06/05/mouseenter%E4%B8%8Emouseover%E4%B8%BA%E4%BD%95%E8%BF%99%E8%88%AC%E7%BA%A0%E7%BC%A0%E4%B8%8D%E6%B8%85%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/zepto-analysis/issues/1" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">项目地址</a></p>
<blockquote>
<p>不知道大家在面试或者工作过程中有没有被<code>mouseover</code>和<code>mouseenter</code>(对应的是<code>mouseout</code>和<code>mouseleave</code>)事件所困扰。自己之前在面试的时候就有被问到诸如mouseover和mouseenter事件的异同之类的问题？当时没有答出来，一直也对这两个事件有点模糊不清，趁着最近正在读<a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">zepto源码</a>，准备写一篇这方面的文章，如果有错误，请大家指正。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/-98ezXklczmayCw28gIX.png" alt=""></p>
<a id="more"></a>
<h2 id="mouseenter与mouseover的异同？"><a href="#mouseenter与mouseover的异同？" class="headerlink" title="mouseenter与mouseover的异同？"></a>mouseenter与mouseover的异同？</h2><blockquote>
<p>要说清楚mouseenter与mouseover有什么不同，也许可以从两方面去讲。</p>
</blockquote>
<ol>
<li>是否支持冒泡</li>
<li>事件的触发时机</li>
</ol>
<p>先来看一张图,对这两个事件有一个简单直观的感受。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170605-204232@2x.png" alt=""></p>
<p><strong>再看看官网对mouseenter的解释</strong></p>
<p><a href="https://msdn.microsoft.com/en-us/library/ms536945(v=vs.85" target="_blank" rel="external">mouseenter | onmouseenter event</a>.aspx)</p>
<blockquote>
<p>The event fires only if the mouse pointer is outside the boundaries of the object and the user moves the mouse pointer inside the boundaries of the object. If the mouse pointer is currently inside the boundaries of the object, for the event to fire, the user must move the mouse pointer outside the boundaries of the object and then back inside the boundaries of the object.</p>
</blockquote>
<p>大概意思是说：当鼠标从元素的边界之外移入元素的边界之内时，事件被触发。而当鼠标本身在元素边界内时，要触发该事件，必须先将鼠标移出元素边界外，再次移入才能触发。(英语比较渣😶，凑合看哈)</p>
<blockquote>
<p>Unlike the onmouseover event, the onmouseenter event does not bubble. </p>
</blockquote>
<p>大概意思是：和mouseover不同的是，mouseenter不支持事件冒泡 (英语比较渣😶，凑合看哈)</p>
<p><strong>由于mouseenter不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其mouseover和mouseout事件，但是却不会触发mouseenter和mouseleave事件</strong></p>
<p>我们用一张动图来看看他们的区别(<a href="https://qianlongo.github.io/zepto-analysis/example/event/mouseEnter-mouseOver.html">或者点击该链接体验</a>)。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/undefeind.gif" alt=""></p>
<p>我们给左右两边的ul分别添加了<code>mouseover</code>和<code>mouseenter</code>事件，当鼠标进入左右两边的ul时，<code>mouseover</code>和<code>mouseenter</code>事件都触发了，但是当移入各自的子元素li的时候，触发了左边ul上的mouseover事件，然而右边ul的mouseenter事件没有被触发。</p>
<p>造成以上现象本质上是<code>mouseenter</code>事件不支持冒泡所致。</p>
<h2 id="如何模拟mouseenter事件。"><a href="#如何模拟mouseenter事件。" class="headerlink" title="如何模拟mouseenter事件。"></a>如何模拟mouseenter事件。</h2><blockquote>
<p>可见mouseover事件因其具有冒泡的性质，在子元素内移动的时候，频繁被触发，如果我们不希望如此，可以使用mouseenter事件代替之，但是早期只有ie浏览器支持该事件，虽然现在大多数高级浏览器都支持了mouseenter事件，但是难免会有些兼容问题，所以如果可以自己手动模拟，那就太好了。</p>
</blockquote>
<p>关键因素: <strong>relatedTarget</strong> 要想手动模拟mouseenter事件，需要对mouseover事件触发时的事件对象event属性relatedTarget了解。</p>
<ol>
<li>relatedTarget事件属性返回与事件的目标节点相关的节点。</li>
<li>对于mouseover事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。</li>
<li>对于mouseout事件来说，该属性是离开目标时，鼠标指针进入的节点。</li>
<li>对于其他类型的事件来说，这个属性没有用。</li>
</ol>
<p>重新回顾一下文章最初的那张图，根据上面的解释，对于ul上添加的mouseover事件来说，relatedTarget只可能是</p>
<ol>
<li>ul的父元素wrap(移入ul时,此时也是触发mouseenter事件的时候, <strong>其实不一定，后面会说明</strong>)，</li>
<li>或者ul元素本身(在其子元素上移出时)，</li>
<li>又或者是子元素本身(直接从子元素A移动到子元素B)。</li>
</ol>
<p><img src="http://odssgnnpf.bkt.clouddn.com/hahha2.png" alt="relatedTarget"></p>
<p>根据上面的描述，我们可以对relatedTarget的值进行判断：如果值不是目标元素，也不是目标元素的子元素，就说明鼠标已移入目标元素而不是在元素内部移动。</p>
<p>条件1： <strong>不是目标元素</strong>很好判断<code>e.relatedTarget !== target(目标元素)</code></p>
<p>条件2：不是目标元素的子元素，这个应该怎么判断呢？</p>
<h2 id="ele-contains"><a href="#ele-contains" class="headerlink" title="ele.contains"></a>ele.contains</h2><blockquote>
<p> 这里需要介绍一个新的api <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/contains" target="_blank" rel="external">node.contains(otherNode) 
</a>, 表示传入的节点是否为该节点的后代节点, 如果 otherNode 是 node 的后代节点或是 node 节点本身.则返回true , 否则返回 false</p>
</blockquote>
<p><strong>用法案例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> $list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>)</div><div class="line"><span class="keyword">let</span> $item = <span class="built_in">document</span>.querySelector(<span class="string">'.item'</span>)</div><div class="line"><span class="keyword">let</span> $test = <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>)</div><div class="line"></div><div class="line">$list.contains($item) <span class="comment">// true</span></div><div class="line">$list.contains($test) <span class="comment">// false</span></div><div class="line">$list.contains($list) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>那么利用contains这个api我们便可以很方便的验证条件2，接下来我们封装一个<code>contains(parent, node)</code>函数，专门用来判断<code>node</code>是不是<code>parent</code>的子节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> contains = <span class="function"><span class="keyword">function</span> (<span class="params">parent, node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> parent !== node &amp;&amp; parent.contains(node)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用我们封装过后的<code>contains</code>函数再去试试上面的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">contains($list, $item) <span class="comment">// true</span></div><div class="line">contains($list, $test) <span class="comment">// false</span></div><div class="line">contains($list, $list) <span class="comment">// false (主要区别在这里)</span></div></pre></td></tr></table></figure>
<p>这个方法很方便地帮助我们解决了模拟mouseenter事件中的条件2，但是悲催的<code>ode.contains(otherNode)</code>,具有浏览器兼容性，在一些低级浏览器中是不支持的，为了做到兼容我们再来改写一下contains方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> contains = docEle.contains ? <span class="function"><span class="keyword">function</span> (<span class="params">parent, node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> parent !== node &amp;&amp; parent.contains(node)</div><div class="line">&#125; : <span class="function"><span class="keyword">function</span> (<span class="params">parent, node</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result = parent !== node</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!result) &#123; <span class="comment">// 排除parent与node传入相同的节点</span></div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (result) &#123;</div><div class="line">    <span class="keyword">while</span> (node &amp;&amp; (node = node.parentNode)) &#123;</div><div class="line">      <span class="keyword">if</span> (parent === node) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说了这么多，我们来看看用<code>mouseover</code>事件模拟<code>mouseenter</code>的最终代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// callback表示如果执行mouseenter事件时传入的回调函数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> emulateEnterOrLeave = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> relatedTarget = e.relatedTarget</div><div class="line">    <span class="keyword">if</span> (relatedTarget !== <span class="keyword">this</span> &amp;&amp; !contains(<span class="keyword">this</span>, relatedTarget)) &#123;</div><div class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>模拟mouseenter与原生mouseenter事件效果对比</strong></p>
<p><code>html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">  wrap, mouseenter</div><div class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"mouseenter list"</span>&gt;</span></div><div class="line">    count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">  wrap, emulate mouseenter,用mouseover模拟实现mouseenter</div><div class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"emulate-mouseenter list"</span>&gt;</span></div><div class="line">    count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>css</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">.wrap&#123;</div><div class="line">  width: 50%;</div><div class="line">  box-sizing: border-box;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.wrap, .list&#123;</div><div class="line">  border: solid 1px green;</div><div class="line">  padding: 30px;</div><div class="line">  margin: 30px 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.list&#123;</div><div class="line">  border: solid 1px red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.list li&#123;</div><div class="line">  border: solid 1px blue;</div><div class="line">  padding: 10px;</div><div class="line">  margin: 10px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.count&#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>javascript</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> $mouseenter = <span class="built_in">document</span>.querySelector(<span class="string">'.mouseenter'</span>)</div><div class="line"><span class="keyword">let</span> $emulateMouseenter = <span class="built_in">document</span>.querySelector(<span class="string">'.emulate-mouseenter'</span>)</div><div class="line"><span class="keyword">let</span> $enterCount = <span class="built_in">document</span>.querySelector(<span class="string">'.mouseenter .count'</span>)</div><div class="line"><span class="keyword">let</span> $emulateMouseenterCounter = <span class="built_in">document</span>.querySelector(<span class="string">'.emulate-mouseenter .count'</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> addCount = <span class="function"><span class="keyword">function</span> (<span class="params">ele, start</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ele.innerHTML = ++start</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> docEle = <span class="built_in">document</span>.documentElement</div><div class="line">  <span class="keyword">let</span> contains = docEle.contains ? <span class="function"><span class="keyword">function</span> (<span class="params">parent, node</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> parent !== node &amp;&amp; parent.contains(node)</div><div class="line">  &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">parent, node</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result = parent !== node</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!result) &#123;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (result) &#123;</div><div class="line">    <span class="keyword">while</span> (node &amp;&amp; (node = node.parentNode)) &#123;</div><div class="line">      <span class="keyword">if</span> (parent === node) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> emulateMouseenterCallback = addCount($emulateMouseenterCounter, <span class="number">0</span>)</div><div class="line">  </div><div class="line"><span class="keyword">let</span> emulateEnterOrLeave = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> relatedTarget = e.relatedTarget</div><div class="line">    <span class="keyword">if</span> (relatedTarget !== <span class="keyword">this</span> &amp;&amp; !contains(<span class="keyword">this</span>, relatedTarget)) &#123;</div><div class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$mouseenter.addEventListener(<span class="string">'mouseenter'</span>, addCount($enterCount, <span class="number">0</span>), <span class="literal">false</span>)</div><div class="line">$emulateMouseenter.addEventListener(<span class="string">'mouseover'</span>, emulateEnterOrLeave(emulateMouseenterCallback), <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p><strong>效果预览</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/emulateMouseenter2.gif" alt=""></p>
<p><a href="https://github.com/qianlongo/zepto-analysis/blob/master/example/event/emlateMouseenter.html" target="_blank" rel="external">详细代码点击</a></p>
<p><a href="https://qianlongo.github.io/zepto-analysis/example/event/emlateMouseenter.html">代码示例点击</a></p>
<p><strong>好了，我们已经通过mouseove事件完整的模拟了mouseenter事件，但是反过头来看看</strong></p>
<p>对于ul上添加的mouseover事件来说，relatedTarget只可能是</p>
<ol>
<li>ul的父元素wrap(移入ul时,此时也是触发mouseenter事件的时候, <strong>其实不一定，后面会说明</strong>)，</li>
<li>或者ul元素本身(在其子元素上移出时)，</li>
<li>又或者是子元素本身(直接从子元素A移动到子元素B)。</li>
</ol>
<p>我们通过排查2和3，最后只留下1，也就是mouseenter与mouseover事件一起触发的时机。既然这样我们为什么不像这样判断呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e.relatedTarget === <span class="keyword">this</span>.parentNode) &#123;</div><div class="line">    <span class="comment">// 执行mouseenter的回调要做的事情  </span></div><div class="line">  &#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>这样不是更加简单吗？，何必要折腾通过排查2和3来做？</p>
<p>原因是，target的父元素有一定的占位空间的时后，我们这样写是没有太大问题的，但是反之，这个时候<code>e.relatedTarget</code>就可能是target元素的父元素，又祖先元素中的某一个。我们无法准确判断e.relatedTarget到底是哪个元素。所以通过排除2和3应该是个更好的选择。</p>
<h2 id="用mouseout模拟mouseleave事件"><a href="#用mouseout模拟mouseleave事件" class="headerlink" title="用mouseout模拟mouseleave事件"></a>用mouseout模拟mouseleave事件</h2><blockquote>
<p>当mouseout被激活时，relatedTarget表示鼠标离开目标元素时，进入了哪个元素，我们同样可以对relatedTarget的值进行判断：如果值不是目标元素，也不是目标元素的子元素，就说明鼠标已移出目标元素</p>
</blockquote>
<p>我们同样可以用上面封装的函数完成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// callback表示如果执行mouseenter事件时传入的回调函数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> emulateEnterOrLeave = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> relatedTarget = e.relatedTarget</div><div class="line">    <span class="keyword">if</span> (relatedTarget !== <span class="keyword">this</span> &amp;&amp; !contains(<span class="keyword">this</span>, relatedTarget)) &#123;</div><div class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/qianlongo/zepto-analysis/blob/master/example/event/mouseEnter-mouseOver.html" target="_blank" rel="external">详细代码点击</a></p>
<p><a href="https://qianlongo.github.io/zepto-analysis/example/event/mouseEnter-mouseOver.html">代码示例点击</a></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>文中也许有些观点不够严谨，欢迎大家拍砖。</p>
</blockquote>
<p><a href="https://github.com/qianlongo/zepto-analysis/issues/1" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/zepto-analysis" target="_blank" rel="external">项目地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你要看看这些有趣的函数方法吗？]]></title>
      <url>https://qianlongo.github.io/2017/05/25/%E8%BF%99%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E4%BD%A0%E7%94%A8%E8%BF%87%E5%87%A0%E4%B8%AA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是underscore.js源码分析的第六篇，如果你对这个系列感兴趣，欢迎点击</p>
<p><a href="https://github.com/qianlongo/underscore-analysis/" target="_blank" rel="external">underscore-analysis/</a> watch一下，随时可以看到动态更新。</p>
<blockquote>
<p>下划线中有非常多很有趣的方法，可以用比较巧妙的方式解决我们日常生活中遇到的问题，比如<code>_.after</code>,<code>_.before</code>，<code>_.defer</code>…等，也许你已经用过他们了，今天我们来深入源码，一探究竟，他们到底是怎么实现的。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/ppt-on-functions-3-728.jpg" alt="function"></p>
<a id="more"></a>
<h2 id="指定调用次数-after-before"><a href="#指定调用次数-after-before" class="headerlink" title="指定调用次数(after, before)"></a>指定调用次数(<code>after</code>, <code>before</code>)</h2><blockquote>
<p>把这两个方法放在前面也是因为他们俩能够解决我们工作中至少以下两个问题</p>
</blockquote>
<ol>
<li><p>如果你要等多个异步请求完成之后才去执行某个操作<code>fn</code>,那么你可以用<code>_.after</code>，而不必写多层异步回调地狱去实现需求</p>
</li>
<li><p>有一些应用可能需要进行初始化操作而且仅需要一次初始化就可以，一般的做法是在入口处对某个变量进行判断，如果为真那么认为已经初始化过了直接<code>return</code>掉，如果为假那么进行参数的初始化工作，并在完成初始化之后设置该变量为真，那么下次进入的时候便不必重复初始化了。</p>
</li>
</ol>
<p><strong>对于问题1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> async1 = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'异步任务1结束了'</span>)</div><div class="line">    cb()</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> async2 = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'异步任务2结束了'</span>)</div><div class="line">    cb()</div><div class="line">  &#125;, <span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'我是两个任务都结束了才进行的任务'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要在任务1，和任务2都结束了才进行<code>fn</code>任务，我们一般的写法是啥？<br>可能会下面这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">async1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  async2(fn)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样确实可以保证任务<code>fn</code>是在前面两个异步任务都结束之后才进行，但是相信你是不太喜欢回调的写法的，这里举的异步任务只有两个，如果多了起来，恐怕就要蛋疼了。别疼，用下划线的<code>after</code>函数可以解救你。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fn = _.after(<span class="number">2</span>, fn)</div><div class="line"></div><div class="line">async1(fn)</div><div class="line">async2(fn)</div></pre></td></tr></table></figure>
<p><strong>运行截图</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170525-220029@2x.png" alt="after举例"></p>
<p>有木有很爽，不用写成回调地狱的形式了。那么接下来我们看看源码是怎么实现的。</p>
<p><strong>after源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.after = <span class="function"><span class="keyword">function</span>(<span class="params">times, func</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 只有返回的函数被调用times次之后才执行func操作</span></div><div class="line">    <span class="keyword">if</span> (--times &lt; <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>源码简单到要死啊，但是就是这么神奇，妥妥地解决了我们的问题1。</p>
<p><strong>对于问题2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> app = &#123;</div><div class="line">  init (name, sex) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initialized) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 进行参数的初始化工作</span></div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span>.sex = sex</div><div class="line">    <span class="comment">// 初始化完成，设置标志</span></div><div class="line">    <span class="keyword">this</span>.initialized = <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  showInfo () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.sex)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传参数进行应用的初始化</span></div><div class="line"></div><div class="line">app.init(<span class="string">'qianlonog'</span>, <span class="string">'boy'</span>)</div><div class="line">app.init(<span class="string">'xiaohuihui'</span>, <span class="string">'girl'</span>)</div><div class="line">app.showInfo() <span class="comment">// qianlonog boy 注意这里打印出来的是第一次传入的参数</span></div></pre></td></tr></table></figure>
<p>一般需要且只进行一次参数初始化工作的时候,我们可能会像上面那样做。但是其实如果用下划线中的<code>before</code>方法我们还可以这样做。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> app = &#123;</div><div class="line">  <span class="attr">init</span>: _.before(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">    <span class="comment">// 进行参数的初始化工作</span></div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span>.sex = sex</div><div class="line">  &#125;) ,</div><div class="line">  showInfo () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.sex)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传参数进行应用的初始化</span></div><div class="line"></div><div class="line">app.init(<span class="string">'qianlonog'</span>, <span class="string">'boy'</span>)</div><div class="line">app.init(<span class="string">'xiaohuihui'</span>, <span class="string">'girl'</span>)</div><div class="line">app.showInfo() <span class="comment">// qianlonog boy 注意这里打印出来的是第一次传入的参数</span></div></pre></td></tr></table></figure>
<p>好玩吧，让我们看看<code>_.before</code>是怎么实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个函数，这个函数调用次数不超过times次</span></div><div class="line"><span class="comment">// 如果次数 &gt;= times 则最后一次调用函数的返回值将被记住并一直返回该值</span></div><div class="line"></div><div class="line">_.before = <span class="function"><span class="keyword">function</span>(<span class="params">times, func</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> memo;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回的函数每次调用都times减1</span></div><div class="line">    <span class="keyword">if</span> (--times &gt; <span class="number">0</span>) &#123; </div><div class="line">      <span class="comment">// 调用func，并传入外面传进来的参数</span></div><div class="line">      <span class="comment">// 需要注意的是，后一次调用的返回值会覆盖前一次</span></div><div class="line">      memo = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 当调用次数够了，就将func销毁设置为null</span></div><div class="line">    <span class="keyword">if</span> (times &lt;= <span class="number">1</span>) func = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> memo;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="让函数具有记忆的功能"><a href="#让函数具有记忆的功能" class="headerlink" title="让函数具有记忆的功能"></a>让函数具有记忆的功能</h2><blockquote>
<p>在程序中我们经常会要进行一些计算的操作，当遇到比较耗时的操作时候，如果有一种机制，对于同样的输入，一定得到相同的输出，并且对于同样的输入，后续的计算直接从缓存中读取，不再需要将计算程序运行那就非常赞了。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> calculate = <span class="function">(<span class="params">num, num2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> result = <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">// 这里只是模拟耗时的操作</span></div><div class="line">    result += num</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">// 这里只是模拟耗时的操作</span></div><div class="line">    result += num2</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</div><div class="line">  <span class="built_in">console</span>.log(end - start)</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"></div><div class="line">calculate(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 30000000</span></div><div class="line"><span class="comment">// log 得到235</span></div><div class="line">calculate(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 30000000</span></div><div class="line"><span class="comment">// log 得到249</span></div></pre></td></tr></table></figure>
<p>对于上面这个calculate函数,同样的输入1, 2,两次调用的输出都是一样的，并且两次都走了两个耗时的循环，看看下划线中的<code>memoize</code>函数，如何为我们省去第二次的耗时操作，直接给出<code>300000</code>的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> calculate = _.memoize(<span class="function">(<span class="params">num, num2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</div><div class="line">  <span class="keyword">let</span> result = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">// 这里只是模拟耗时的操作</span></div><div class="line">    result += num</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10000000</span>; i++) &#123; <span class="comment">// 这里只是模拟耗时的操作</span></div><div class="line">    result += num2</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</div><div class="line">  <span class="built_in">console</span>.log(end - start)</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [].join.call(<span class="built_in">arguments</span>, <span class="string">'@'</span>) <span class="comment">// 这里是为了给同样的输入指定唯一的缓存key</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">calculate(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 30000000</span></div><div class="line"><span class="comment">// log 得到 238</span></div><div class="line">calculate(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 30000000</span></div><div class="line"><span class="comment">// log 啥也没有打印出，因为直接从缓存中读取了</span></div></pre></td></tr></table></figure>
<p><strong>源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> _.memoize = <span class="function"><span class="keyword">function</span>(<span class="params">func, hasher</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = memoize.cache;</div><div class="line">    <span class="comment">// 注意hasher，如果传了hasher，就用hasher()执行的结果作为缓存func()执行的结果的key</span></div><div class="line">    <span class="keyword">var</span> address = <span class="string">''</span> + (hasher ? hasher.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) : key); </div><div class="line">    <span class="comment">// 如果没有在cache中查找到对应的key就去计算一次，并缓存下来</span></div><div class="line">    <span class="keyword">if</span> (!_.has(cache, address)) cache[address] = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </div><div class="line">    <span class="comment">// 返回结果</span></div><div class="line">    <span class="keyword">return</span> cache[address];</div><div class="line">  &#125;;</div><div class="line">  memoize.cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> memoize; <span class="comment">// 返回一个具有cache静态属性的函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>相信你已经看懂了源码实现，是不是很简单，但是又很实用有趣。</p>
<h2 id="来一下延时-delay和-defer"><a href="#来一下延时-delay和-defer" class="headerlink" title="来一下延时(.delay和.defer)"></a>来一下延时(<em>.delay和</em>.defer)</h2><blockquote>
<p> 下划线中在原生延迟函数<code>setTimeout</code>的基础上做了一些改造，产生以上两个函数</p>
</blockquote>
<p><strong>_.delay(function, wait, *arguments)</strong></p>
<p>就是延迟<code>wait</code>时间去执行<code>function</code>，<code>function</code>需要的参数由<code>*arguments</code>提供</p>
<p><strong>使用举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> log = _.bind(<span class="built_in">console</span>.log, <span class="built_in">console</span>)</div><div class="line">_.delay(log, <span class="number">1000</span>, <span class="string">'hello qianlongo'</span>)</div><div class="line"><span class="comment">// 1秒后打印出 hello qianlongo</span></div></pre></td></tr></table></figure>
<p><strong>源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.delay = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait</span>) </span>&#123;</div><div class="line">  <span class="comment">// 读取第三个参数开始的其他参数</span></div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</div><div class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 执行func并将参数传入,注意apply的第一个参数是null护着undefined的时候，func内部的this指的是全局的window或者global</span></div><div class="line">    <span class="keyword">return</span> func.apply(<span class="literal">null</span>, args); </div><div class="line">  &#125;, wait);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不过有点需要注意的是<code>_.delay(function, wait, *arguments)``function</code>中的<code>this</code>指的是<code>window</code>或者<code>global</code></p>
<p><strong>_.defer(function, *arguments)</strong></p>
<p>延迟调用function直到当前调用栈清空为止，类似使用延时为0的setTimeout方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。 如果传递arguments参数，当函数function执行时， arguments 会作为参数传入</p>
<p><strong>源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.defer = _.partial(_.delay, _, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>所以主要还是看<code>_.partial</code>是个啥</p>
<h2 id="可以预指定参数的函数-partial"><a href="#可以预指定参数的函数-partial" class="headerlink" title="可以预指定参数的函数_.partial"></a>可以预指定参数的函数<code>_.partial</code></h2><blockquote>
<p>局部应用一个函数填充在任意个数的 参数，不改变其动态this值。和bind方法很相近。你可以在你的参数列表中传递_来指定一个参数 ，不应该被预先填充(<a href="http://www.bootcss.com/p/underscore/#partial" target="_blank" rel="external">underscore中文网翻译</a>)</p>
</blockquote>
<p><strong>使用举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">num1, num2, num3, num4</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> str = <span class="string">`num1=<span class="subst">$&#123;num1&#125;</span>`</span></div><div class="line">  str += <span class="string">`num2=<span class="subst">$&#123;num2&#125;</span>`</span></div><div class="line">  str += <span class="string">`num3=<span class="subst">$&#123;num3&#125;</span>`</span></div><div class="line">  str += <span class="string">`num4=<span class="subst">$&#123;num4&#125;</span>`</span></div><div class="line">  <span class="keyword">return</span> str</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn = _.partial(fn, <span class="number">1</span>, _, <span class="number">3</span>, _)</div><div class="line">fn(<span class="number">2</span>,<span class="number">4</span>)<span class="comment">// num1=1num2=2num3=3num4=4</span></div></pre></td></tr></table></figure>
<p>可以看到，我们传入了<code>_</code>(这里指的是下划线本身)进行占位，后续再讲2和4填充到对应的位置去了。</p>
<p><strong>源码具体怎么实现的呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_.partial = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取除了传进回调函数之外的其他预参数</span></div><div class="line">  <span class="keyword">var</span> boundArgs = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); </div><div class="line">  <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> position = <span class="number">0</span>, length = boundArgs.length;</div><div class="line">    <span class="comment">// 先创建一个和boundArgs长度等长的空数组</span></div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(length); </div><div class="line">    <span class="comment">// 处理占位元素_</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; </div><div class="line">      <span class="comment">// 如果发现boundArgs中有_的占位元素，就依次用arguments中的元素进行替换boundArgs</span></div><div class="line">      args[i] = boundArgs[i] === _ ? <span class="built_in">arguments</span>[position++] : boundArgs[i]; </div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把auguments中的其他元素添加到boundArgs中</span></div><div class="line">    <span class="keyword">while</span> (position &lt; <span class="built_in">arguments</span>.length) args.push(<span class="built_in">arguments</span>[position++]); </div><div class="line">    <span class="comment">// 最后执行executeBound，接下来看看executeBound是什么</span></div><div class="line">    <span class="keyword">return</span> executeBound(func, bound, <span class="keyword">this</span>, <span class="keyword">this</span>, args);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> bound;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上一篇文章<a href="https://github.com/qianlongo/underscore-analysis/issues/8" target="_blank" rel="external">如何写一个实用的bind？</a><br>有详细讲解，这里我们再回顾一下<br><strong>executeBound</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> executeBound = <span class="function"><span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果调用方式不是new func的形式就直接调用sourceFunc，并且给到对应的参数即可</span></div><div class="line">  <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args); </div><div class="line">   <span class="comment">// 处理new调用的形式</span></div><div class="line">  <span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</div><div class="line">  <span class="keyword">var</span> result = sourceFunc.apply(self, args);</div><div class="line">  <span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</div><div class="line">  <span class="keyword">return</span> self;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>先看一下这些参数都�代表什么含义</p>
<ol>
<li>sourceFunc：原函数，待绑定函数</li>
<li>boundFunc： 绑定后函数</li>
<li>context：绑定后函数this指向的上下文</li>
<li>callingContext：绑定后函数的执行上下文，通常就是 this</li>
<li>args：绑定后的函数执行所需参数</li>
</ol>
<p>这里其实就是执行了这句,所以关键还是如果处理预参数，和后续参数的逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sourceFunc.apply(context, args);</div></pre></td></tr></table></figure>
<h2 id="管道式函数组合"><a href="#管道式函数组合" class="headerlink" title="管道式函数组合"></a>管道式函数组合</h2><blockquote>
<p>你也许遇到过这种场景，任务A，任务B，任务C必须按照顺序执行，并且A的输出作为B的输入，B的输出作为C的输入，左后再得到结果。用一张图表示如下</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170526-001211@2x.png" alt="管道"></p>
<p>那么一般的做法是什么呢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> funcA = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str += <span class="string">'-A'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> funcB = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str += <span class="string">'-B'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> funcC = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str += <span class="string">'-C'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">funcC(funcB(funcA(<span class="string">'hello'</span>)))</div><div class="line"><span class="comment">// "hello-A-B-C"</span></div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` javascript</span></div><div class="line">用下划线中的`compose<span class="string">`方法怎么做呢</span></div><div class="line"></div><div class="line">`<span class="string">``</span> javascript</div><div class="line"><span class="keyword">let</span> fn = _.compose(funcC, funcB, funcA)</div><div class="line">fn(<span class="string">'hello'</span>)</div><div class="line"><span class="comment">// "hello-A-B-C"</span></div></pre></td></tr></table></figure>
<p>看起来没有一般的做法那样，层层绕进去了，而是以一种非常扁平的方式使用。</p>
<p>同样我们看看源码是怎么实现的。</p>
<p><strong>_.compose源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">  <span class="comment">// 从最后一个参数开始处理</span></div><div class="line">  <span class="keyword">var</span> start = args.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = start;</div><div class="line">    <span class="comment">// 执行最后一个函数,并得到结果result</span></div><div class="line">    <span class="keyword">var</span> result = args[start].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </div><div class="line">    <span class="comment">// 从后往前一个个调用传进来的函数，并将上一次执行的结果作为参数传进下一个函数</span></div><div class="line">    <span class="keyword">while</span> (i--) result = args[i].call(<span class="keyword">this</span>, result); </div><div class="line">    <span class="comment">// 最后将结果导出</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="给多个函数绑定同样的上下文-bindAll-object-methodNames"><a href="#给多个函数绑定同样的上下文-bindAll-object-methodNames" class="headerlink" title="给多个函数绑定同样的上下文(_.bindAll(object, *methodNames))"></a>给多个函数绑定同样的上下文<code>(_.bindAll(object, *methodNames))</code></h2><blockquote>
<p>将多个函数methodNames绑定上下文环境为<code>object</code></p>
</blockquote>
<p>😪 😪 😪，好困，写文章当真好要时间和精力，到这里已经快写了3个小时了，夜深，好像躺下睡觉啊！！！啊啊啊，再等等快说完了（希望不会误人子弟）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buttonView = &#123;</div><div class="line">  <span class="attr">label</span>  : <span class="string">'underscore'</span>,</div><div class="line">  <span class="attr">onClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">'clicked: '</span> + <span class="keyword">this</span>.label); &#125;,</div><div class="line">  <span class="attr">onHover</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'hovering: '</span> + <span class="keyword">this</span>.label); &#125;</div><div class="line">&#125;;</div><div class="line">_.bindAll(buttonView, <span class="string">'onClick'</span>, <span class="string">'onHover'</span>);</div><div class="line"></div><div class="line">$(<span class="string">'#underscore_button'</span>).bind(<span class="string">'click'</span>, buttonView.onClick);</div></pre></td></tr></table></figure>
<p>我们用官网给的例子说一下，默认的jQuery中<code>$(selector).on(eventName, callback)</code>callback中的<code>this</code>指的是当前的元素本身，当时经过上面的处理，会弹出<code>underscore</code>。</p>
<p><strong>_.bindAll源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> _.bindAll = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i, length = <span class="built_in">arguments</span>.length, key;</div><div class="line">  <span class="comment">// 必须要指定需要绑定到obj的函数参数</span></div><div class="line">  <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'bindAll must be passed function names'</span>);</div><div class="line">  <span class="comment">// 从第一个实参开始处理，这些便是需要绑定this作用域到obj的函数</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123; </div><div class="line">    key = <span class="built_in">arguments</span>[i];</div><div class="line">    <span class="comment">// 调用内部的bind方法进行this绑定</span></div><div class="line">    obj[key] = _.bind(obj[key], obj); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>内部使用了<code>_.bind</code>进行绑定，如果你对<code>_.bind</code>原生是如何实现的可以看这里<a href="https://github.com/qianlongo/underscore-analysis/issues/8" target="_blank" rel="external">如何写一个实用的bind？</a></p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><blockquote>
<p>最后关于underscore.js中function篇章还有两个函数说一下，另外节流函数<code>throttle</code>以及<code>debounce_</code>会另外单独写一篇文章介绍，欢迎前往<a href="https://github.com/qianlongo/underscore-analysis/" target="_blank" rel="external">underscore-analysis/</a> watch一下，随时可以看到动态更新。</p>
</blockquote>
<p><strong>_.wrap(function, wrapper)</strong></p>
<p>将第一个函数 function 封装到函数 wrapper 里面, 并把函数 function 作为第一个参数传给 wrapper. 这样可以让 wrapper 在 function 运行之前和之后 执行代码, 调整参数然后附有条件地执行.</p>
<p><strong>直接看源码实现吧</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">func, wrapper</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.partial(wrapper, func);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>还记得前面说的<code>partial</code>吧，他会返回一个函数，内部会执行<code>wrapper</code>，并且<code>func</code>会作为<code>wrapper</code>的一个参数被传入。</p>
<p><strong>_.negate(predicate)</strong></p>
<blockquote>
<p>将predicate函数执行的结果取反。</p>
</blockquote>
<p><strong>使用举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">_.negate(fn)() <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>看起来好像没什么软用，但是。。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line"><span class="keyword">let</span> findEven = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">arr.filter(findEven) <span class="comment">// [2, 4, 6]</span></div></pre></td></tr></table></figure>
<p>如果要找到奇数呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line"><span class="keyword">let</span> findEven = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">arr.filter(_.negate(findEven)) <span class="comment">// [1, 3, 5]</span></div></pre></td></tr></table></figure>
<p><strong>源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.negate = <span class="function"><span class="keyword">function</span>(<span class="params">predicate</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> !predicate.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>源码很简单，就是把你传进来的predicate函数执行的结果取反一下，但是应用还是蛮多的。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>这几个是underscore库中function相关的api，大部分已经说完了，如果对你有一点点帮助。</p>
</blockquote>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">点一个小星星吧😀😀😀</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">点一个小星星吧😀😀😀</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">点一个小星星吧😀😀😀</a></p>
<p>good night 🌙</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何写一个实用的bind？]]></title>
      <url>https://qianlongo.github.io/2017/05/20/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84bind%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是underscore.js源码分析的第五篇，如果你对这个系列感兴趣，欢迎点击</p>
<p><a href="https://github.com/qianlongo/underscore-analysis/" target="_blank" rel="external">underscore-analysis/</a> watch一下，随时可以看到动态更新。</p>
<blockquote>
<p>事情要从js中的<code>this</code>开始说起，你是不是也经常有种无法掌控和知晓它的感觉，对于初学者来说，<code>this</code>简直如同回调地狱般，神乎其神，让人无法捉摸透。但是通过原生js中的bind方法，我们可以显示绑定函数的<code>this</code>作用域，而无需担心运行时是否会改变而不符合自己的预期。当然了下划线中的bind也是模仿它的功能同样可以达到类似的效果。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/cxt.jpeg" alt="ctx"></p>
<a id="more"></a>
<h2 id="bind简单回顾"><a href="#bind简单回顾" class="headerlink" title="bind简单回顾"></a>bind简单回顾</h2><blockquote>
<p>我们从mdn上的介绍来回顾一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a>的使用方法。</p>
</blockquote>
<p><strong>bind方法创建一个新的函数, 当被调用时，它的this关键字被设置为提供的值。</strong></p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun.bind(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>
<p>简单地看一下这些参数的含义</p>
<ol>
<li><p>thisArg</p>
<blockquote>
<p>当绑定函数被调用时，该参数会作为原函数运行时的this指向,当使用new 操作符调用绑定函数时，该参数无效。</p>
</blockquote>
</li>
<li><p>arg1, arg2, …</p>
<blockquote>
<p>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>
</blockquote>
</li>
</ol>
<p><strong>绑定this作用域示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">'windowName'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  showName () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.showName() <span class="comment">// qianlongo</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> showName = obj.showName</div><div class="line">  showName() <span class="comment">// windowName</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> bindShowName = obj.showName.bind(obj)</div><div class="line">  bindShowName() <span class="comment">// qianlongo</span></div></pre></td></tr></table></figure>
<p>通过以上简单示例，我们知道了第一个参数的作用就是绑定函数运行时候的<code>this</code>指向</p>
<p><strong>第二个参数开始起使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(num1 + num2)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bindSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>)</div><div class="line">bindSum(<span class="number">2</span>) <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><strong>bind可以使一个函数拥有预设的初始参数。这些参数（如果有的话）作为bind的第二个参数跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。</strong></p>
<p>参数的使用基本上明白了，我们再来看看使用new去调用bind之后的函数是怎么回事。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// Person &#123;&#125;</span></div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">age</span>: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> bindPerson = Person.bind(obj, <span class="string">'qianlongo'</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> bindPerson(<span class="string">'boy'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p) <span class="comment">// Person &#123;name: "qianlongo", sex: "boy"&#125;</span></div></pre></td></tr></table></figure>
<p>有没有发现bindPerson内部的this不再是bind的第一个参数obj，此时obj已经不再起效了。</p>
<p>实际上bind的使用是有一定限制的，在一些低版本浏览器下不可用，你想不想看看下划线中是如何实现一个兼容性好的bind呢！！！come on</p>
<h2 id="下划线中bind实现"><a href="#下划线中bind实现" class="headerlink" title="下划线中bind实现"></a>下划线中bind实现</h2><p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> _.bind = <span class="function"><span class="keyword">function</span>(<span class="params">func, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果原生支持bind函数，就用原生的，并将对应的参数传进去</span></div><div class="line">  <span class="keyword">if</span> (nativeBind &amp;&amp; func.bind === nativeBind) <span class="keyword">return</span> nativeBind.apply(func, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">  <span class="comment">// 如果传入的func不是一个函数类型 就抛出异常</span></div><div class="line">  <span class="keyword">if</span> (!_.isFunction(func)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Bind must be called on a function'</span>);</div><div class="line">  <span class="comment">// 把第三个参数以后的值存起来，接下来请看executeBound</span></div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</div><div class="line">  <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeBound(func, bound, context, <span class="keyword">this</span>, args.concat(slice.call(<span class="built_in">arguments</span>)));</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> bound;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>executeBound实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> executeBound = <span class="function"><span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果调用方式不是new func的形式就直接调用sourceFunc，并且给到对应的参数即可</span></div><div class="line">  <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args); </div><div class="line">  <span class="comment">// 处理new调用的形式</span></div><div class="line">  <span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</div><div class="line">  <span class="keyword">var</span> result = sourceFunc.apply(self, args);</div><div class="line">  <span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</div><div class="line">  <span class="keyword">return</span> self;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的源码都做了相应的注释，我们着重来看一下<code>executeBound</code>的实现</p>
<p>先看一下这些参数都代表什么含义</p>
<ol>
<li>sourceFunc：原函数，待绑定函数</li>
<li>boundFunc： 绑定后函数</li>
<li>context：绑定后函数<code>this</code>指向的上下文</li>
<li>callingContext：绑定后函数的执行上下文，通常就是 this</li>
<li>args：绑定后的函数执行所需参数</li>
</ol>
<p>ok，我们来看一下第一句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args);</div></pre></td></tr></table></figure>
<p>这句话是为了判断绑定后的函数是以new关键字被调用还是普通的函数调用的方式，举个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'非new调用方式'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'new 调用方式'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person() <span class="comment">// 非new调用方式</span></div><div class="line"><span class="keyword">new</span> Person() <span class="comment">// new 调用方式</span></div></pre></td></tr></table></figure>
<p>所以如果你希望自己写的构造函数无论是<code>new</code>还是没用<code>new</code>都起效的话可以用下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, sex)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Person(<span class="string">'qianlongo'</span>, <span class="string">'boy'</span>) <span class="comment">// Person &#123;name: "qianlongo", sex: "boy"&#125;</span></div><div class="line"></div><div class="line">Person(<span class="string">'qianlongo'</span>, <span class="string">'boy'</span>) <span class="comment">// Person &#123;name: "qianlongo", sex: "boy"&#125;</span></div></pre></td></tr></table></figure>
<p>我们回到<code>executeBound</code>的解析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args);</div></pre></td></tr></table></figure>
<p><code>callingContext</code>是被绑定后的函数的<code>this</code>作用域，<code>boundFunc</code>就是那个被绑定后的函数，那么通过这个if判断，当为非<code>new</code>调用形式的时候，直接利用<code>apply</code>处理即可。</p>
<p>但是如果是用<code>new</code>调用的呢？我们看下面这段代码,别看短短的四行代码里面知识点挺多的呢！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里拿到的是一个空对象，且其继承于原函数的原型链prototype</span></div><div class="line"><span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</div><div class="line"><span class="comment">// 构造函数执行之后的返回值</span></div><div class="line"><span class="comment">// 一般情况下是没有返回值的，也就是undefined</span></div><div class="line"><span class="comment">// 但是有时候写构造函数的时候会显示地返回一个obj</span></div><div class="line"><span class="keyword">var</span> result = sourceFunc.apply(self, args);</div><div class="line"><span class="comment">// 所以去判断结果是不是object，如果是那么返回构造函数返回的object</span></div><div class="line"><span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</div><div class="line"><span class="comment">// 如果没有显示返回object，就返回原函数执行结束后的实例</span></div><div class="line"><span class="keyword">return</span> self;</div></pre></td></tr></table></figure>
<p>好，到这里，我有一个疑问，<code>baseCreate</code>是个什么鬼？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Ctor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果prototype不是object类型直接返回空对象</span></div><div class="line">  <span class="keyword">if</span> (!_.isObject(prototype)) <span class="keyword">return</span> &#123;&#125;;</div><div class="line">  <span class="comment">// 如果原生支持create则用原生的</span></div><div class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype); </div><div class="line">  <span class="comment">// 将prototype赋值为Ctor构造函数的原型</span></div><div class="line">  Ctor.prototype = prototype; </div><div class="line">  <span class="comment">// 创建一个Ctor实例对象</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor; </div><div class="line">  <span class="comment">// 为了下一次使用，将原型清空</span></div><div class="line">  Ctor.prototype = <span class="literal">null</span>; </div><div class="line">  <span class="comment">// 最后将实例返回</span></div><div class="line">  <span class="keyword">return</span> result; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>是不是好简单，就是实现了原生的Object.create用来做一些继承的事情。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>文章很简短，知道怎么实现一个原生的bind就行。如果你对apply、call和this感兴趣，欢迎查看</p>
</blockquote>
<p><a href="https://qianlongo.github.io/2016/04/26/js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E9%82%A3%E4%BA%9B%E4%BA%8B/">js中call、apply、bind那些事</a></p>
<p><a href="https://qianlongo.github.io/2016/12/31/this-%E6%83%B3%E8%AF%B4%E7%88%B1%E4%BD%A0%E4%B8%8D%E5%AE%B9%E6%98%93/#more">this-想说爱你不容易</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你知道koa中间件执行原理吗？]]></title>
      <url>https://qianlongo.github.io/2017/05/17/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/resume-native/issues/1" target="_blank" rel="external">原文地址</a></p>
<blockquote>
<p>最近几天花了比较长的时间在koa(1)的源码分析上面，初次看的时候，被中间件执行那段整的晕乎乎的，完全不知道所以，再次看，好像明白了些什么，再反复看，我去，简直神了，简直泪流满面，简直丧心病狂啊！！！</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f363339363931332f6b6f612f6c6f676f2e706e67.png" alt="koa"></p>
<a id="more"></a>
<h2 id="用在前面"><a href="#用在前面" class="headerlink" title="用在前面"></a>用在前面</h2><blockquote>
<p>下面的例子会在控制台中打印出一些信息(具体打印出什么？可以猜猜😀)，然后返回<code>hello world</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</div><div class="line"><span class="keyword">let</span> app = koa()</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> * (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'generate1----start'</span>)</div><div class="line">  <span class="keyword">yield</span> next</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'generate1----end'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> * (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'generate2----start'</span>)</div><div class="line">  <span class="keyword">yield</span> next</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'generate2----end'</span>)</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'hello world'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>)</div></pre></td></tr></table></figure>
<p>用过koa的同学都知道添加中间件的方式是使用koa实例的<code>use</code>方法，并传入一个generator函数，这个generator函数可以接受一个<code>next</code>(这个next到底是啥？这里先不阐明，在后面会仔细说明)。</p>
<p><strong>执行use干了嘛</strong></p>
<p>这是koa的构造函数，为了没有其他信息的干扰，我去除了一些暂时用不到的代码，这里我们把目光聚焦在<code>middleware</code>这个数组即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Application</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  <span class="keyword">this</span>.middleware = []; <span class="comment">// 这个数组就是用来装一个个中间件的</span></div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来我们要看use方法了</strong></p>
<p>同样去除了一些暂时不用的代码，可以看到每次执行use方法，就把外面传进来的generator函数push到middleware数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  <span class="keyword">this</span>.middleware.push(fn);</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>好啦！你已经知道koa中是预先通过use方法，将请求可能会经过的中间件装在了一个数组中。</strong></p>
<p><code>接下来我们要开始本文的重点了，当一个请求到来的时候，是怎样经过中间件，怎么跑起来的</code></p>
<p>首先我们只要知道下面这段<code>callback</code>函数就是请求到来的时候执行的回调即可（同样尽量去除了我们不用的代码）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">app.callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.experimental</div><div class="line">    ? compose_es7(<span class="keyword">this</span>.middleware)</div><div class="line">    : co.wrap(compose(<span class="keyword">this</span>.middleware));</div><div class="line"></div><div class="line">  <span class="comment">// xxx</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    <span class="comment">// xxx</span></div><div class="line"></div><div class="line">    fn.call(ctx).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      respond.call(ctx);</div><div class="line">    &#125;).catch(ctx.onerror);</div><div class="line"></div><div class="line">    <span class="comment">// xxx</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这段代码可以分成两个部分</p>
<ol>
<li>请求前的中间件初始化处理部分</li>
<li>请求到来时的中间件运行部分</li>
</ol>
<p>我们分部分来说一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fn = <span class="keyword">this</span>.experimental</div><div class="line">    ? compose_es7(<span class="keyword">this</span>.middleware)</div><div class="line">    : co.wrap(compose(<span class="keyword">this</span>.middleware));</div></pre></td></tr></table></figure>
<p>这段代码对<code>experimental</code>做了下判断，如果设置为了<code>true</code>那么koa中将可以支持传入async函数，否则就执行<code>co.wrap(compose(this.middleware))</code>。</p>
<p>只有一行初始化中间件就做完啦？</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/timg2.jpeg" alt=""></p>
<p><strong>我知道koa很屌，但也别这么屌好不好，所以说评价一个好的程序员不是由代码量决定的</strong></p>
<p>我们来看下这段代码到底有什么神奇的地方</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compose(<span class="keyword">this</span>.middleware)</div></pre></td></tr></table></figure>
<p>把装着中间件<code>middleware</code>的数组作为参数传进了<code>compose</code>这个方法，那么compose做了什么事呢？其实就是把原本毫无关系的一个个中间件给首尾串起来了，于是他们之间就有了千丝万缕的联系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">    <span class="comment">// 第一次得到next是由于*noop生成的generator对象</span></div><div class="line">    <span class="keyword">if</span> (!next) next = noop(); </div><div class="line"></div><div class="line">    <span class="keyword">var</span> i = middleware.length;</div><div class="line">    <span class="comment">// 从后往前开始执行middleware中的generator函数</span></div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="comment">// 把后一个中间件得到的generator对象传给前一个作为第一个参数存在</span></div><div class="line">      next = middleware[i].call(<span class="keyword">this</span>, next);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> *next;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">noop</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>文字解释一下就是，compose将中间件从最后一个开始处理，并一直往前直到第一个中间件。其中非常关键的就是将后一个中间件得到generator对象作为参数(<code>这个参数就是文章开头说到的next啦，也就是说next其实是一个generator对象</code>)传给前一个中间件。当然最后一个中间件的参数<code>next</code>是一个空的generator函数生成的对象。</p>
<p>我们自己来写一个简单的例子说明compose是如何将多个generator函数串联起来的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen1</span> (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen1'</span></div><div class="line">  <span class="keyword">yield</span> * next <span class="comment">// 开始执行下一个中间件</span></div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen1-end'</span> <span class="comment">// 下一个中间件执行完成再继续执行gen1中间件的逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen2</span> (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen2'</span></div><div class="line">  <span class="keyword">yield</span> * next <span class="comment">// 开始执行下一个中间件</span></div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen2-end'</span> <span class="comment">// 下一个中间件执行完成再继续执行gen2中间件的逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen3</span> (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen3'</span></div><div class="line">  <span class="keyword">yield</span> * next <span class="comment">// 开始执行下一个中间件</span></div><div class="line">  <span class="keyword">yield</span> <span class="string">'gen3-end'</span> <span class="comment">// 下一个中间件执行完成再继续执行gen3中间件的逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">noop</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> middleware = [gen1, gen2, gen3]</div><div class="line"><span class="keyword">var</span> len = middleware.length</div><div class="line"><span class="keyword">var</span> next = noop() <span class="comment">// 提供给最后一个中间件的参数</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>(len--) &#123;</div><div class="line">  next = middleware[len].call(<span class="literal">null</span>, next)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">letGo</span> (<span class="params">next</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> * next</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = letGo(next)</div><div class="line"></div><div class="line">g.next() <span class="comment">// &#123;value: "gen1", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: "gen2", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: "gen3", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: "gen3-end", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: "gen2-end", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: "gen1-end", done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>看到了吗？中间件被串起来之后执行的顺序是</p>
<p>gen1 -&gt; gen2 -&gt; gen3 -&gt; noop -&gt; gen3 -&gt; gen2 -&gt; gen1</p>
<p>从而首尾相连，进而发生了关系😈。</p>
<h2 id="co-wrap"><a href="#co-wrap" class="headerlink" title="co.wrap"></a>co.wrap</h2><blockquote>
<p>通过compose处理后返回了一个generator函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">co.wrap(compose(<span class="keyword">this</span>.middleware))</div></pre></td></tr></table></figure>
<p>所有上述代码可以理解为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">co.wrap(<span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>))</span></div></pre></td></tr></table></figure>
<p>好，我们再看看<code>co.wrap</code>做了什么,慢慢地一步步靠近了哦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>co.wrap</code>返回了一个普通函数<code>createPromise</code>,这个函数就是文章开头的<code>fn</code>啦。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">this</span>.experimental</div><div class="line">    ? compose_es7(<span class="keyword">this</span>.middleware)</div><div class="line">    : co.wrap(compose(<span class="keyword">this</span>.middleware));</div></pre></td></tr></table></figure>
<h2 id="中间件开始跑起来啦"><a href="#中间件开始跑起来啦" class="headerlink" title="中间件开始跑起来啦"></a>中间件开始跑起来啦</h2><blockquote>
<p>前面已经说完了，中间件是如何初始化的，即如果由不相干到关系密切了，接下来开始说请求到来时，初始化好的中间件是怎么跑的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fn.call(ctx).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  respond.call(ctx);</div><div class="line">&#125;).catch(ctx.onerror);</div></pre></td></tr></table></figure>
<p>这一段便是请求到来手即将要经过的中间件执行部分，fn执行之后返回的是一个Promise，koa通过注册成功和失败的回调函数来分别处理请求。</p>
<p>让我们回到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createPromise</code>里面的fn就是经过compose处理中间件后返回的一个generator函数，那么执行之后拿到的就是一个generator对象了，并把这个对象传经经典的co里面啦。如果你需要对co的源码了解欢迎查看昨天写的<a href="https://juejin.im/post/591b3389a0bb9f005f0bf270" target="_blank" rel="external">走一步再走一步，揭开co的神秘面纱</a>，好了，接下来就是看co里面如何处理这个被compose处理过的generator对象了</p>
<p><strong>再回顾一下co</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Mixed&#125; res</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Error&#125; err</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the next value in the generator,</div><div class="line">     * return a promise.</div><div class="line">     *</div><div class="line">     * @param &#123;Object&#125; ret</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们直接看一下<code>onFulfilled</code>,这个时候第一次进co的时候因为已经是generator对象所以会直接执行<code>onFulfilled()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ret;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ret = gen.next(res);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> reject(e);</div><div class="line">  &#125;</div><div class="line">  next(ret);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>gen.next</code>正是用于去执行中间件的业务逻辑，当遇到yield语句的时候，将紧随其后的结果返回赋值给<code>ret</code>,通常这里的ret，就是我们文中说道的<code>next</code>,也就是当前中间件的下一个中间件。</p>
<p>拿到下一个中间件后把他交给<code>next</code>去处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">  <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">    + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当中间件执行结束了，就把Promise的状态设置为成功。否则就将<code>ret</code>(也就是下一个中间件)再用co包一次。主要看<code>toPromise</code>的这几行代码即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意噢<code>toPromise</code>这个时候的返回值是一个Promise，这个非常关键，是下一个中间件执行完成之后回溯到上一个中间件中断执行处继续执行的关键</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">  <span class="comment">// 即通过前面toPromise返回的Promise实现，当后一个中间件执行结束，回退到上一个中间件中断处继续执行</span></div><div class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected); </div><div class="line">  <span class="comment">// xxx </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>看到这里，我们可以总结出，几乎koa的中间件都会被co给包装一次，而每一个中间件又可以通过Promise的then去监测其后一个中间件是否结束，后一个中间件结束后会执行前一个中间件用then监听的操作，这个操作便是执行该中间件yield next后面的那些代码</strong></p>
<p>打个比方：</p>
<p>当koa中接收到一个请求的时候，请求将经过两个中间件，分别是<code>中间件1</code>和<code>中间件2</code>，</p>
<p><strong>中间件1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 中间件1在yield 中间件2之前的代码</span></div><div class="line"></div><div class="line"><span class="keyword">yield</span> 中间件<span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 中间件2执行完成之后继续执行中间件1的代码</span></div></pre></td></tr></table></figure>
<p><strong>中间件2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 中间件2在yield noop中间件之前的代码</span></div><div class="line"></div><div class="line"><span class="keyword">yield</span> noop中间件</div><div class="line"></div><div class="line"><span class="comment">// noop中间件执行完成之后继续执行中间件2的代码</span></div></pre></td></tr></table></figure>
<p><strong>那么处理的过程就是co会立即调用onFulfilled来执行中间件1前半部分代码，遇到<code>yield 中间件2</code>的时候得到中间件2generator对象，紧接着，又把这个对象放到co里面继续执行一遍，以此类推下去知道最后一个中间件（我们这里的指的是那个空的noop中间件）执行结束，继而马上调用promise的resolve方法表示结束，ok，这个时候中间件2监听到noop执行结束了，马上又去执行了onFulfilled来执行yield noop中间件后半部分代码，好啦这个时候中间件2也执行结束了，也会马上调用promise的resolve方法表示结束,ok，这个时候中间件1监听到中间件2执行结束了，马上又去执行了onFulfilled来执行yield 中间件2后半部分代码，最后中间件全部执行完了，就执行respond.call(ctx);</strong></p>
<p>啊 啊 啊好绕，不过慢慢看，仔细想，还是可以想明白的。用代码表示这个过程有点类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">new Promise((resolve, reject) =&gt; &#123;</div><div class="line">  // 我是中间件1</div><div class="line">  yield new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    // 我是中间件2</div><div class="line">    yield new Promise((resolve, reject) =&gt; &#123;</div><div class="line">      // 我是body</div><div class="line">    &#125;)</div><div class="line">    // 我是中间件2</div><div class="line">  &#125;)</div><div class="line">  // 我是中间件1</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt="中间件执行顺序"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p> 罗里吧嗦说了一大堆，也不知道有没有把执行原理说明白。</p>
</blockquote>
<p>如果对你理解koa有些许帮助，不介意的话，点击源码地址点颗小星星吧</p>
<p>如果对你理解koa有些许帮助，不介意的话，点击源码地址点颗小星星吧</p>
<p>如果对你理解koa有些许帮助，不介意的话，点击源码地址点颗小星星吧</p>
<p><a href="https://github.com/qianlongo/resume-native" target="_blank" rel="external">源码地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[走一步再走一步，揭开co的神秘面纱]]></title>
      <url>https://qianlongo.github.io/2017/05/17/%E8%B5%B0%E4%B8%80%E6%AD%A5%E5%86%8D%E8%B5%B0%E4%B8%80%E6%AD%A5%EF%BC%8C%E6%8F%AD%E5%BC%80co%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/resume-native/blob/master/co-analysis.md" target="_blank" rel="external">原文地址</a></p>
<p><a href="https://github.com/qianlongo/resume-native/" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>了解<code>co</code>的前提是已经知晓<code>generator</code>是什么，可以看软大神的<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator 函数的语法</a>,<br>co是TJ大神写的能够使generator自动执行的函数库，而我们熟知的koa也用到了它管理异步流程控制，将异步任务书写同步化，爽的飞起，也摆脱了一直以来的回调地狱问题。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/ad51ce297e8dd51850842ff012bdc3cb.jpg" alt=""></p>
<a id="more"></a>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<p>首先我们根据<a href="https://github.com/tj/co" target="_blank" rel="external">co</a>的官方文档来稍做改变看下，到底如何使用co，再一步步进行源码分析工作(这篇文章分析的co版本是<code>4.6.0</code>)。</p>
</blockquote>
<p><strong>yield 后面常见的可以跟的类型</strong></p>
<ol>
<li>promises</li>
<li>array (parallel execution)</li>
<li>objects (parallel execution)</li>
<li>generator functions (delegation)</li>
</ol>
<p><strong>promises</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">let</span> genTimeoutFun = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">`delayTime: <span class="subst">$&#123;delay&#125;</span>`</span>)</div><div class="line">      &#125;, delay)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> timeout1 = genTimeoutFun(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> timeout2 = genTimeoutFun(<span class="number">200</span>)</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> timeout1()</div><div class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// delayTime: 1000</span></div><div class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> timeout2()</div><div class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// delayTime: 200</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">'end'</span></div><div class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>array</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">let</span> genTimeoutFun = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">`delayTime: <span class="subst">$&#123;delay&#125;</span>`</span>)</div><div class="line">      &#125;, delay)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> timeout1 = genTimeoutFun(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> timeout2 = genTimeoutFun(<span class="number">200</span>)</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> [timeout1(), timeout2()]</div><div class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// [ 'delayTime: 1000', 'delayTime: 200' ]</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'end'</span></div><div class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// end</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>objects</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">let</span> genTimeoutFun = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">`delayTime: <span class="subst">$&#123;delay&#125;</span>`</span>)</div><div class="line">      &#125;, delay)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> timeout1 = genTimeoutFun(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> timeout2 = genTimeoutFun(<span class="number">200</span>)</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> &#123;</div><div class="line">    <span class="attr">timeout1</span>: timeout1(),</div><div class="line">    <span class="attr">timeout2</span>: timeout2()</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// &#123; timeout1: 'delayTime: 1000',timeout2: 'delayTime: 200' &#125;</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'end'</span></div><div class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// end</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>generator functions</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">let</span> genTimeoutFun = <span class="function">(<span class="params">delay</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">`delayTime: <span class="subst">$&#123;delay&#125;</span>`</span>)</div><div class="line">      &#125;, delay)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> timeout1 = genTimeoutFun(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> timeout2 = genTimeoutFun(<span class="number">200</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> timeout1()</div><div class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// delayTime: 1000</span></div><div class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> timeout2()</div><div class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// delayTime: 200</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> gen()</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">'end'</span></div><div class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// end</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>最后说一下，关于执行传入的generator函数接收参数的问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// qianlongo</span></div><div class="line">&#125;, <span class="string">'qianlongo'</span>)</div></pre></td></tr></table></figure>
<p>从co函数的第二个参数开始，便是传入的generator函数可以接收的实参</p>
<h2 id="开始分析源码"><a href="#开始分析源码" class="headerlink" title="开始分析源码"></a>开始分析源码</h2><blockquote>
<p>你可以把以上代码拷贝至本地测试一番看看效果，接下来我们一步步开始分析co的源码</p>
</blockquote>
<p><strong>首先经过上面的例子可以发现，co函数本身接收一个generator函数，并且co执行后返回的是Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    <span class="comment">// xxx</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Promise的内部，先执行了外部传入的<code>gen</code>,执行的结果如果不具备next属性(且要是一个函数)，就直接返回，并将执行成功回调<code>resolve(gen)</code>,否则得到的是一个指针对象。</p>
<p><strong>接下来继续看…</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">onFulfilled();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * @param &#123;Mixed&#125; res</div><div class="line">  * @return &#123;Promise&#125;</div><div class="line">  * @api private</div><div class="line">  */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ret;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ret = gen.next(res); <span class="comment">// 用上面执行gen之后的generator生成器将指针指向下一个位置</span></div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> reject(e);</div><div class="line">  &#125;</div><div class="line">  next(ret); <span class="comment">// 紧接着执行next，正是它实现了反复调用自己，自动流程控制，注意ret(即上一次gen.next执行后返回的对象&#123;value: xxx, done: true or false&#125;)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * @param &#123;Error&#125; err</div><div class="line">  * @return &#123;Promise&#125;</div><div class="line">  * @api private</div><div class="line">  */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ret;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ret = gen.throw(err);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> reject(e);</div><div class="line">  &#125;</div><div class="line">  next(ret);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我觉得可以把 <code>onFulfilled</code> 和 <code>onRejected</code> 看成是返回的Promise的<code>resolve</code>和<code>reject</code>。</p>
<p>而<code>onFulfilled</code>也是将原生的generator生成器的next方法包装了一遍，大概是为了抓取错误吧(看到内部的try catch了吗)</p>
<p><strong>好，我们看到了co内部将指针移动到了第一个位置之后，接着执行了内部的next方法，接下来聚焦在该函数上</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果整个generator函数的内部状态已经表示走完，便将Promise的状态设置为成功状态，并执行resolve</span></div><div class="line">  <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">  <span class="comment">// 这一步是将ret的value转换为Promise形式</span></div><div class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">  <span class="comment">// 这里非常关键，是co实现自己调用自己，实现流程自动化的关键</span></div><div class="line">  <span class="comment">// 注意这里使用value.then，即为返回值添加成功和失败的回调，在成功的回调里面再去执行onFulfilled，紧接着就是调用内部的next函数</span></div><div class="line">  <span class="comment">// 那不是就保证了流程完全按照你写的顺序来了？</span></div><div class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">  <span class="comment">// 抛出错误，yield后只能跟着指定的下列这几种类型</span></div><div class="line">  <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">    + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>聪明的你，是不是已经明白了co是怎么将异步流程自动管理起来了</strong></p>
<p>但是我对next函数中的toPromise函数还有疑问，他到底做了什么事？使得co(generatorFun)中yield可以支持数组、对象、generator函数等形式。</p>
<p><strong>一步步来看</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// obj不存在，直接返回</span></div><div class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</div><div class="line">  <span class="comment">// 如果obj已经是Promise，则也是直接返回</span></div><div class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</div><div class="line">  <span class="comment">// 如果是个generator函数或者generator生成器，那就像你自己调用co函数一样，手动传到co里面去执行</span></div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="comment">// 如果obj既不是Promise，也不是isGeneratorFunction和isGenerator，要是一个普通的函数（需要符合thunk函数规范），就将该函数包装成Promise的形式</span></div><div class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="comment">// 如果是一个数组的形式，就去arrayToPromise包装一番</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先如果obj不存在，就直接返回，你想啊，co本来就是依赖上一次指针返回的value是Promise或者其他，这个时候如果返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">value</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">done</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那就没有必要再给一个false值转成Promise形式了吧。</p>
<p>接着，如果obj本身就是个Promise也是直接返回，用了内部的isPromise函数进行判断，我们看下他怎么实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是判断了obj的then属性是不是个函数</p>
<p><strong>再接着，如果是个generator函数或者generator生成器，那就像你自己调用co函数一样，手动传到co里面去执行。</strong></p>
<p><strong>isGeneratorFunction</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGeneratorFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = obj.<span class="keyword">constructor</span>;</div><div class="line">  if (!<span class="keyword">constructor</span>) return false;</div><div class="line">  if ('GeneratorFunction' === <span class="keyword">constructor</span>.name || 'GeneratorFunction' === <span class="keyword">constructor</span>.displayName) return true;</div><div class="line">  return isGenerator(<span class="keyword">constructor</span>.prototype);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过obj的constructor属性去判断其是否属于<code>GeneratorFunction</code>,最后如果constructor属性没判断出来，再去用isGenerator，判断obj的原型是不是generator生成器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGenerator</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.next &amp;&amp; <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.throw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>判断的条件也比较直接，需要符合两个条件，一个是obj.next要是一个函数，一个是obj.throw要是一个函数</strong></p>
<p><strong>接下来继续看</strong></p>
<p>如果obj既不是Promise，也不是isGeneratorFunction和isGenerator，要是一个普通的函数，就将该函数包装成Promise的形式，这里我们主要需要看<code>thunkToPromise</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkToPromise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="comment">// 将thunk函数包装成Promise</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">      <span class="comment">// 执行这个thunk函数</span></div><div class="line">    fn.call(ctx, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123; </div><div class="line">      <span class="comment">// 注意thunk函数内部接收的回调函数中传入的第一个参数是err，出现了err，当然需要走reject了</span></div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err); </div><div class="line">      <span class="comment">// 参数是两个以上的情况下，将参数整成一个数组</span></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) res = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">      <span class="comment">// 最后执行成功的回调</span></div><div class="line">      resolve(res);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来是重头戏了，co中如果处理yield后面跟一个数组呢？主要是arrayToPromise函数的作用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用到了Promise.all，将obj中多个promise实例(当然你也可以在数组中填thunk函数，generator函数等)重新包装成一个。最后返回一个新的Promise</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(obj.map(toPromise, <span class="keyword">this</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>还有最后一个判断，如果obj是个对象怎么办？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectToPromise</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="comment">// 构造一个和传入对象有相同构造器的对象, results也是</span></div><div class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.constructor();</div><div class="line">  <span class="comment">// 获取obj的keys</span></div><div class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">  <span class="comment">// 存储obj中是Promise的属性</span></div><div class="line">  <span class="keyword">var</span> promises = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> key = keys[i];</div><div class="line">    <span class="keyword">var</span> promise = toPromise.call(<span class="keyword">this</span>, obj[key]);</div><div class="line">    <span class="comment">// 如果是结果是Promise，则用defer函数对results进行修改</span></div><div class="line">    <span class="keyword">if</span> (promise &amp;&amp; isPromise(promise)) defer(promise, key);</div><div class="line">    <span class="comment">// 如果是非Promise就按原样返回</span></div><div class="line">    <span class="keyword">else</span> results[key] = obj[key];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 最后 使用到了Promise.all，将obj中多个promise实例</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defer</span>(<span class="params">promise, key</span>) </span>&#123;</div><div class="line">    <span class="comment">// predefine the key in the result</span></div><div class="line">    results[key] = <span class="literal">undefined</span>;</div><div class="line">    promises.push(promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="comment">// 运行成功之后再讲结果赋值给results</span></div><div class="line">      results[key] = res;</div><div class="line">    &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>到这里，co源码分析就告一段落了。总感觉有些没有说到位，欢迎大家拍砖，晚安。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[悄悄地说一个bug]]></title>
      <url>https://qianlongo.github.io/2017/05/11/%E6%82%84%E6%82%84%E5%9C%B0%E8%AF%B4%E4%B8%80%E4%B8%AAbug/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>underscore.js源码分析第四篇,前三篇地址分别是，如果你对这个系列感兴趣，欢迎点击watch，随时关注动态。</p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/6" target="_blank" rel="external">教你认清这8大杀手锏</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/5" target="_blank" rel="external">那些不起眼的小工具？</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/4" target="_blank" rel="external">(void 0)与undefined之间的小九九</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/7" target="_blank" rel="external">原文地址</a><br><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>逗我呢？哥！你要说什么bug，什么bug，什么bug，我最讨厌bug。去他妹的bug。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/ubiaoqing58b8358e002c33469.jpg" alt=""></p>
<a id="more"></a>
<p><strong>客观别急，今天真的是要说一个bug，也许你早已知晓，也许你时常躺枪于他手，悄悄地，我们慢慢开始。</strong></p>
<p><code>for in 遍历对象属性时存在bug</code></p>
<p><code>for in 遍历对象属性时存在bug</code></p>
<p><code>for in 遍历对象属性时存在bug</code></p>
<p>使用<code>for in</code>去遍历一个对象俺们再熟悉不过了，经常干这种事，那他到底可以遍历一个对象哪些类型的属性呢？ <code>长得帅的</code>还是<code>看起来美美的</code>,瞎说，它能够遍历的是对象身上那些可枚举标志(<strong>[[Enumerable]]</strong>)为<code>true</code>的属性。</p>
<ol>
<li><strong>对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 <code>true</code></strong></li>
<li><strong>对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false</strong></li>
</ol>
<p>举个例子哪些属性可以被枚举</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  showName () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;,</div><div class="line">  showSex () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.wrap = &#123;</div><div class="line">  sayHi () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'qianlongo'</span>, <span class="string">'sex'</span>)</div><div class="line"></div><div class="line">p1.sayBye = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'bye'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">p1.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'string'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(p1, <span class="string">'info'</span>, &#123;</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span>: <span class="string">'feDev'</span></div><div class="line">&#125;);Ï</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> p1) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// name</span></div><div class="line"><span class="comment">// sex</span></div><div class="line"><span class="comment">// sayBye</span></div><div class="line"><span class="comment">// constructor</span></div><div class="line"><span class="comment">// showName</span></div><div class="line"><span class="comment">// showSex</span></div><div class="line"><span class="comment">// toString</span></div></pre></td></tr></table></figure>
<ol>
<li>可以看到我们手动地用defineProperty，给某个对象设置属性时，enumerable为false此时该属性是不可枚举的</li>
<li>Person继承自Object构造函数，但是<code>for in</code>并没有枚举出Object原型上的一些方法</li>
<li>手动地覆盖对象原型上面的方法<code>toString</code>也是可枚举的</li>
</ol>
<h2 id="如何判断一个对象的属性是可枚举的"><a href="#如何判断一个对象的属性是可枚举的" class="headerlink" title="如何判断一个对象的属性是可枚举的"></a>如何判断一个对象的属性是可枚举的</h2><blockquote>
<p>方式其实很简单，使用原生js提供的<code>Object.propertyIsEnumerable</code>来判断</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj2 = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo2'</span>,</div><div class="line">  toString () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.propertyIsEnumerable(<span class="string">'name'</span>) <span class="comment">// true</span></div><div class="line">obj.propertyIsEnumerable(<span class="string">'toString'</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line">obj2.propertyIsEnumerable(<span class="string">'name'</span>) <span class="comment">// true</span></div><div class="line">obj2.propertyIsEnumerable(<span class="string">'toString'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>为什么obj判断toString为不可枚举属性，而obj2就是可枚举的了呢？原因很简单，obj2将<code>toString</code>重写了，而一个对象自身直接赋值的属性是可被枚举的</strong></p>
<p>说了这么多，接下来我们来看一下下划线中涉及到遍历的部分对象方法，come on！！！</p>
<h2 id="has-object-key"><a href="#has-object-key" class="headerlink" title="_.has(object, key)"></a>_.has(object, key)</h2><blockquote>
<p>判断对象obejct是否包含key属性</p>
</blockquote>
<p><strong>平时你可能经常这样去判断一个对象是否包含某个属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (obj &amp;&amp; obj.key) &#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这样做有缺陷，比如某个属性其对应的值为0，null,false,’’空字符串呢？这样明明obj有以下对应的属性，却因为属性值为<strong>假</strong>而通过不了验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">''</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">handsomeBoy</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">timer</span>: <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们可以采用下划线中的这种方式</p>
<p><strong>源码</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasOwnProperty = ObjProto.hasOwnProperty;</div><div class="line">_.has = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; hasOwnProperty.call(obj, key);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="keys-object"><a href="#keys-object" class="headerlink" title="_.keys(object)"></a>_.keys(object)</h2><blockquote>
<p>获取object对象所有的属性名称。</p>
</blockquote>
<p><strong>使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> keys = _.keys(obj)</div><div class="line"><span class="comment">// ["name", "sex"]</span></div></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.keys = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果obj不是object类型直接返回空数组</span></div><div class="line">  <span class="keyword">if</span> (!_.isObject(obj)) <span class="keyword">return</span> [];</div><div class="line">  <span class="comment">// 如果浏览器支持原生的keys方法，则使用原生的keys</span></div><div class="line">  <span class="keyword">if</span> (nativeKeys) <span class="keyword">return</span> nativeKeys(obj);</div><div class="line">  <span class="keyword">var</span> keys = [];</div><div class="line">  <span class="comment">// 注意这里1、for in会遍历原型上的键，所以用_.has来确保读取的只是对象本身的属性</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) keys.push(key);</div><div class="line">  <span class="comment">// Ahem, IE &lt; 9.</span></div><div class="line">  <span class="comment">// 这里主要处理ie9以下的浏览器的bug，会将对象上一些本该枚举的属性认为不可枚举，详细可以看collectNonEnumProps分析</span></div><div class="line">  <span class="keyword">if</span> (hasEnumBug) collectNonEnumProps(obj, keys); </div><div class="line">  <span class="keyword">return</span> keys;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="collectNonEnumProps函数分析"><a href="#collectNonEnumProps函数分析" class="headerlink" title="collectNonEnumProps函数分析"></a>collectNonEnumProps函数分析</h2><blockquote>
<p>该函数为下划线中的内部函数一枚，专门处理ie9以下的枚举bug问题,<code>for  in</code>到底有啥bug，终于可以说出来了。</p>
</blockquote>
<p><strong>简单地说就是如果对象将其原型上的类似<code>toString</code>的方法覆盖了的话，那么我们认为<code>toString</code>就是可枚举的了，但是在ie9以下的浏览器中还是认为是不可以枚举的，又是万恶的ie</strong></p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断浏览器是否存在枚举bug，如果有，在取反操作前会返回false</span></div><div class="line"><span class="keyword">var</span> hasEnumBug = !&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;.propertyIsEnumerable(<span class="string">'toString'</span>); </div><div class="line"><span class="comment">// 所有需要处理的可能存在枚举问题的属性</span></div><div class="line"><span class="keyword">var</span> nonEnumerableProps = [<span class="string">'valueOf'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'toString'</span>,</div><div class="line">                    <span class="string">'propertyIsEnumerable'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'toLocaleString'</span>]; </div><div class="line"></div><div class="line"><span class="comment">// 处理ie9以下的一个枚举bug                      </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectNonEnumProps</span>(<span class="params">obj, keys</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nonEnumIdx = nonEnumerableProps.length;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = obj.<span class="keyword">constructor</span>;</div><div class="line">  // 读取obj的原型</div><div class="line">  var proto = (_.isFunction(<span class="keyword">constructor</span>) &amp;&amp; <span class="keyword">constructor</span>.prototype) || ObjProto;  </div><div class="line"></div><div class="line">  // 这里我有个疑问，对于<span class="keyword">constructor</span>属性为什么要单独处理？</div><div class="line">  // Constructor is a special case.</div><div class="line">  var prop = '<span class="keyword">constructor</span>'; </div><div class="line">  if (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</div><div class="line"></div><div class="line">  while (nonEnumIdx--) &#123;</div><div class="line">    prop = nonEnumerableProps[nonEnumIdx];</div><div class="line">    <span class="comment">// nonEnumerableProps中的属性出现在obj中，并且和原型中的同名方法不等，再者keys中不存在该属性，就添加进去</span></div><div class="line">    <span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</div><div class="line">      keys.push(prop);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码看起来并不复杂，但是有一个小疑问，对于constructor属性为什么要单独处理呢？各个看官，如果知晓，请教我啊</strong></p>
<h2 id="allKeys-object"><a href="#allKeys-object" class="headerlink" title="_.allKeys(object)"></a>_.allKeys(object)</h2><blockquote>
<p>获取object中所有的属性，包括原型上的。</p>
</blockquote>
<p><strong>举个简单的例子说明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  showName () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'qianlongo'</span>, <span class="string">'boy'</span>)</div><div class="line"></div><div class="line">_.keys(p)</div><div class="line"><span class="comment">// ["name", "sex"] 只包括自身的属性</span></div><div class="line"></div><div class="line"></div><div class="line">_.allKeys(p)</div><div class="line"><span class="comment">// ["name", "sex", "constructor", "showName"] 还包括原型上的属性</span></div></pre></td></tr></table></figure>
<p>接下来看下源码是怎么干的</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 获取对象obj的所有的键</span></div><div class="line"><span class="comment">// 与keys不同，这里包括继承来的key</span></div><div class="line"></div><div class="line"><span class="comment">// Retrieve all the property names of an object.</span></div><div class="line">_.allKeys = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!_.isObject(obj)) <span class="keyword">return</span> [];</div><div class="line">  <span class="keyword">var</span> keys = [];</div><div class="line">  <span class="comment">// 直接读遍历取到的key，包括原型上的</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) keys.push(key); </div><div class="line">  <span class="comment">// Ahem, IE &lt; 9.</span></div><div class="line">  <span class="keyword">if</span> (hasEnumBug) collectNonEnumProps(obj, keys); <span class="comment">// 同样处理一下有枚举问题的浏览器</span></div><div class="line">  <span class="keyword">return</span> keys;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到和_.keys的唯一的不同就在于遍历obj的时候有没有用<code>hasOwnProperty</code>去判断</p>
<h2 id="values"><a href="#values" class="headerlink" title="_.values()"></a>_.values()</h2><blockquote>
<p>返回object对象所有的属性值。</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">_.values(obj)</div><div class="line"><span class="comment">// ["qianlongo", "boy"]</span></div></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Retrieve the values of an object's properties.</span></div><div class="line">_.values = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 用到了前面已经写好的keys函数，所以values认为获取的属性值，不包括原型</span></div><div class="line">  <span class="keyword">var</span> keys = _.keys(obj);</div><div class="line">  <span class="keyword">var</span> length = keys.length;</div><div class="line">  <span class="keyword">var</span> values = <span class="built_in">Array</span>(length);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">    values[i] = obj[keys[i]];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> values;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="invert-object"><a href="#invert-object" class="headerlink" title="_.invert(object)"></a>_.invert(object)</h2><blockquote>
<p>返回一个object副本，使其键（keys）和值（values）对换。</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">secName</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">_.invert(obj)</div><div class="line"></div><div class="line"><span class="comment">// &#123;100: "age", qianlongo: "secName"&#125;</span></div></pre></td></tr></table></figure>
<p><strong>注意哟，如果对象中有些属性值是相等的，那么翻转过来的对象其key取最后一个</strong></p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.invert = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = &#123;&#125;;</div><div class="line">  <span class="comment">// 所以也只是取对象本身的属性</span></div><div class="line">  <span class="keyword">var</span> keys = _.keys(obj); </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</div><div class="line">    <span class="comment">// 值为key，key为值，如果有值相等，后面的覆盖前面的</span></div><div class="line">    result[obj[keys[i]]] = keys[i]; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="functions-object"><a href="#functions-object" class="headerlink" title="_.functions(object)"></a>_.functions(object)</h2><blockquote>
<p>返回一个对象里所有的方法名, 而且是已经排序的(注意这里包括原型上的属性)</p>
</blockquote>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.functions = _.methods = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> names = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="comment">// 是函数，就装载进去</span></div><div class="line">    <span class="keyword">if</span> (_.isFunction(obj[key])) names.push(key);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> names.sort(); <span class="comment">// 最后返回经过排序的数组</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>夜深人静，悄悄地说一个bug这个鬼故事讲完了，各位good night。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[教你认清这8大杀手锏]]></title>
      <url>https://qianlongo.github.io/2017/05/10/%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85%E8%BF%998%E5%A4%A7%E6%9D%80%E6%89%8B%E9%94%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>underscore.js源码分析第三篇,前两篇地址分别是</p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/5" target="_blank" rel="external">那些不起眼的小工具？</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/4" target="_blank" rel="external">(void 0)与undefined之间的小九九</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis/issues/6" target="_blank" rel="external">本篇原文链接</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>😔看了很多篇技术文章，却依然写不好前端。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/145902-7a9b95469a275d2c.jpeg" alt=""></p>
<p>从步入程序猿这个大坑开始到现在，已经看过数不清的技术文章和书籍，有的是零散的知识，有的是系列权威的教程，但为毛还写不好挚爱的前端，听说过一句话，<strong>这个世界又不是只有你一个人深爱而不得</strong>。但纵使如此，我也要技术这条路上一路走到黑。直到天涯迷了路，海角翻了船。</p>
<a id="more"></a>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>今天想说几个类似我们平常的工作中经常用到的几个<strong>宝贝</strong>,姑且把他叫做杀手锏好了，因为实在是特别好用呀，他们分别是…</p>
</blockquote>
<ol>
<li>each</li>
<li>map</li>
<li>reduce</li>
<li>reduceRight</li>
<li>find</li>
<li>filter</li>
<li>every</li>
<li>some</li>
</ol>
<p>接下来我们从下划线underscore.js的视角，一步步看他们的内部运行的原理是什么….</p>
<h2 id="1-each-list-iteratee-context"><a href="#1-each-list-iteratee-context" class="headerlink" title="1 _.each(list, iteratee, [context])"></a>1 _.each(list, iteratee, [context])</h2><blockquote>
<p>遍历list中的所有元素，按顺序用遍历输出每个元素，如果传递了context，则将iteratee函数中的this绑定到context上。</p>
</blockquote>
<p><strong>先来看一下怎么使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="string">'name'</span>, <span class="string">'sex'</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不传入context</span></div><div class="line"><span class="comment">// 遍历数组</span></div><div class="line">_.each(arr, <span class="built_in">console</span>.log) </div><div class="line"><span class="comment">// name 0 (2) ["name", "sex"]</span></div><div class="line"><span class="comment">// sex 1 (2) ["name", "sex"]</span></div><div class="line"></div><div class="line"><span class="comment">// 遍历对象</span></div><div class="line">_.each(obj, <span class="built_in">console</span>.log)</div><div class="line"><span class="comment">// qianlongo name &#123;name: "qianlongo", sex: "boy"&#125;</span></div><div class="line"><span class="comment">// boy sex  &#123;name: "qianlongo", sex: "boy"&#125;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 传入context</span></div><div class="line">_.each(arr, <span class="function"><span class="keyword">function</span> (<span class="params">val, key, arr</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>[val])</div><div class="line">&#125;, obj)</div><div class="line"><span class="comment">// qianlongo</span></div><div class="line"><span class="comment">// boy</span></div></pre></td></tr></table></figure>
<p><strong>可以看出下划线的each和原生的数组forEach有些类似也有不同的地方</strong></p>
<p>原生的forEach只可以遍历数组，而下划线的each还可以遍历对象。接下来你想不想一起看下下划线是怎么实现的。come on！！！</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// 优化遍历函数iteratee，将iteratee中的this动态设置为context</span></div><div class="line">  iteratee = optimizeCb(iteratee, context); </div><div class="line">  <span class="keyword">var</span> i, length;</div><div class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123; <span class="comment">// 如果是类数组类型的obj</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</div><div class="line">      <span class="comment">// iteratee接收的三个参数分别是 数组的值，数组的索引，以及数组本身</span></div><div class="line">      iteratee(obj[i], i, obj); </div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 支持对象类型的数据迭代</span></div><div class="line">    <span class="keyword">var</span> keys = _.keys(obj); <span class="comment">// 拿到obj自身的所有keys</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</div><div class="line">      <span class="comment">// iteratee接收的三个参数分别是 obj的属性值，obj的属性，obj本身</span></div><div class="line">      iteratee(obj[keys[i]], keys[i], obj);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj; <span class="comment">// 最后将obj返回</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>😉，其实也没有那么难理解是吧！开始map函数之旅吧</p>
<h2 id="2-map-list-iteratee-context"><a href="#2-map-list-iteratee-context" class="headerlink" title="2 _.map(list, iteratee, [context])"></a>2 _.map(list, iteratee, [context])</h2><blockquote>
<p>通过iteratee将list中的每个值映射到一个新的数组中（注：产生一个新的数组。y = f(x),类似高中学过的知识，将x通过f()映射为一个新的数</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="string">'qianlongo'</span>, <span class="string">'boy'</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// list是个数组的时候</span></div><div class="line">_.map(arr, (val, index) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`hello : <span class="subst">$&#123;val&#125;</span>`</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// ["hello : qianlongo", "hello : boy"]</span></div><div class="line"></div><div class="line"><span class="comment">// list是个对象的时候</span></div><div class="line">_.map(obj, (val, key, obj) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`hello : <span class="subst">$&#123;val&#125;</span>`</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// ["hello : qianlongo", "hello : boy"]</span></div></pre></td></tr></table></figure>
<p><strong>当然还可以传入第三个参数context，其本质如each一般，也是让iteratee函数中的this动态设置为context</strong></p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> _.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// 可以将这里的内部cb函数理解为绑定iteratee的this到context</span></div><div class="line">  iteratee = cb(iteratee, context);</div><div class="line">  <span class="comment">// 非类数组对象就获取obj的keys，这里如果是类数组最后得到的keys为undefined</span></div><div class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">      length = (keys || obj).length,</div><div class="line">      results = <span class="built_in">Array</span>(length); <span class="comment">// 创建一个和obj长度空间一样的数组</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">    <span class="comment">// 注意这里，keys存在则代表obj是个对象，所以要拿到keys中的值，否则是类数组的话，直接用index索引就好了</span></div><div class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">    <span class="comment">// 看到了吗，这里将iteratee执行后的返回值塞到了results数组中</span></div><div class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results; <span class="comment">// 最后将映射之后的数组返回</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>通过源码可以看到map的实现思路</strong></p>
<ol>
<li>创建一个即将返回的数组</li>
<li>遍历list(可以为数组也可以为对象)，将list的元素输入到传进来的iteratee函数中，并将其执行后的返回值填充进数组。这个iteratee负责映射规则</li>
</ol>
<h2 id="3-every-list-predicate-context"><a href="#3-every-list-predicate-context" class="headerlink" title="3 _.every(list, [predicate], [context])"></a>3 _.every(list, [predicate], [context])</h2><blockquote>
<p>当list中的所有的元素都可以通过predicate的检测，那么结果返回true，否则false</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">-1</span>, <span class="number">-3</span>, <span class="number">-6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = _.every(arr, (val, key, arr) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val &gt; <span class="number">0</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = _.every(obj, (val, key, obj) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val.indexOf(<span class="string">'o'</span>) &gt; <span class="number">-1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>使用起来蛮简单的，传入一个谓词函数(返回值是一个布尔值的函数)，最后得到true或者false。</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_.every = _.all = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// 可以将这里的内部cb函数理解为绑定iteratee的this到context</span></div><div class="line">  predicate = cb(predicate, context);</div><div class="line">  <span class="comment">// 短路写法，非类数组则获取其keys</span></div><div class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">      length = (keys || obj).length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">    <span class="comment">// keys若能转化为"真" 则说明obj是对象类型</span></div><div class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index; </div><div class="line">    <span class="comment">// 只要有一个不满足就返回false，中断迭代</span></div><div class="line">    <span class="keyword">if</span> (!predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 否则所有元素都通过判断返回true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="4-some-list-predicate-context"><a href="#4-some-list-predicate-context" class="headerlink" title="4 _.some(list, [predicate], [context])"></a>4 _.some(list, [predicate], [context])</h2><blockquote>
<p>如果list中有任何一个元素通过 predicate的检测就返回true。否则返回false，和every恰好有点相反的意思。</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">-1</span>, <span class="number">-3</span>, <span class="number">-6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">sex</span>: <span class="string">''</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = _.some(arr, (val, key, arr) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val &gt; <span class="number">0</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// true 因为至少有一个元素 &gt;0</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = _.some(obj, (val, key, obj) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val.indexOf(<span class="string">'o'</span>) &gt; <span class="number">-1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// true 两个都包含'o' 当然返回true</span></div></pre></td></tr></table></figure>
<p>源码中是怎么实现的呢,与every唯一不同的地方在返回<code>true</code>还是<code>falase</code>之处？</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_.some = _.any = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</div><div class="line">  predicate = cb(predicate, context);</div><div class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">      length = (keys || obj).length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">    <span class="keyword">if</span> (predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只要有一个满足条件就返回true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 所有都不满足则返回false</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="5-find-list-predicate-context"><a href="#5-find-list-predicate-context" class="headerlink" title="5 _.find(list, predicate, [context])"></a>5 _.find(list, predicate, [context])</h2><blockquote>
<p>遍历list中的元素，返回第一个通过predicate函数检测的值。</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">-1</span>, <span class="number">-3</span>, <span class="number">-6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span>,</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> result = _.find(arr, (val, key, arr) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val &gt; <span class="number">0</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">let</span> result2 = _.find(obj, (val, key, obj) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val.indexOf(<span class="string">'o'</span>) &gt; <span class="number">-1</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// boy</span></div></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_.find = _.detect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key;</div><div class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</div><div class="line">    <span class="comment">// 当传入的是类数组的时候，调用findIndex方法，结果是&gt;= -1的数组</span></div><div class="line">    key = _.findIndex(obj, predicate, context);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 当传入的是一个对象的时候，调用findKey，结果是一个字符串属性或者undefined</span></div><div class="line">    key = _.findKey(obj, predicate, context);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回符合条件的value,否则没有返回值，即默认的undefined</span></div><div class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; key !== <span class="number">-1</span>) <span class="keyword">return</span> obj[key]; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>_.findIndex</code>和<code>_.findKey</code>在后面会一一分析，目前理解find函数知道他们怎么用就好。</p>
<h2 id="6-filter-list-predicate-context"><a href="#6-filter-list-predicate-context" class="headerlink" title="6 _.filter(list, predicate, [context])"></a>6 _.filter(list, predicate, [context])</h2><blockquote>
<p>遍历list，返回包含所有通过predicate检测的元素(结果是个数组)</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">-1</span>, <span class="number">-3</span>, <span class="number">-6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">sex</span>: <span class="string">'boy'</span>,</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlongo'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> result = _.filter(arr, (val, key, arr) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> val &gt; <span class="number">0</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// [3, 6, 9]</span></div><div class="line"><span class="keyword">let</span> result2 = _.filter(obj, (val, key, obj) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;val&#125;</span>`</span>.indexOf(<span class="string">'o'</span>) &gt; <span class="number">-1</span> <span class="comment">// 使用模板字符串是防止100没有indexOf方法而报错</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// ["boy", "qianlongo"]</span></div></pre></td></tr></table></figure>
<p>聪明的你是不是已经想到了源码是怎么实现的了 😉</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.filter = _.select = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> results = [];</div><div class="line">  <span class="comment">// 绑定predicate的this作用域到context</span></div><div class="line">  predicate = cb(predicate, context);</div><div class="line">  <span class="comment">// 用each方法对obj进行遍历</span></div><div class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</div><div class="line">    <span class="comment">// 符合predicate过滤条件的，就把对应的值塞到results数组中</span></div><div class="line">    <span class="keyword">if</span> (predicate(value, index, list)) results.push(value);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> results; <span class="comment">// 最后返回</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>最后是reduce和reduceRight，两个相对来说更难一些的api，虽然已经过了12点了，手动困乏😪， 我们咬咬牙坚持一下，把最后两个说完</strong></p>
<h2 id="7-reduce-list-iteratee-memo-context-，"><a href="#7-reduce-list-iteratee-memo-context-，" class="headerlink" title="7 _.reduce(list, iteratee, [memo], [context])，"></a>7 _.reduce(list, iteratee, [memo], [context])，</h2><blockquote>
<p>别名为 inject 和 foldl, reduce方法把list中元素归结为一个单独的数值。Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo, value 和 迭代的index（或者 key）和最后一个引用的整个 list</p>
</blockquote>
<h2 id="8-reduceRight-list-iteratee-memo-context"><a href="#8-reduceRight-list-iteratee-memo-context" class="headerlink" title="8 _.reduceRight(list, iteratee, memo, [context])"></a>8 _.reduceRight(list, iteratee, memo, [context])</h2><blockquote>
<p>reducRight是从右侧开始组合的元素的reduce函数</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</div><div class="line">  sum = _.reduce(arr, (init, cur, i, arr) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> init + cur;</div><div class="line">  &#125;);	</div><div class="line">  </div><div class="line">  <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>我们来看一下上面的执行过程是怎样的。</p>
<p><strong>第一回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为initialValue没有传入所以回调函数的第一个参数为数组的第一项</span></div><div class="line">init = <span class="number">0</span>;</div><div class="line">cur = <span class="number">1</span>;</div><div class="line">=&gt; init + cur = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p><strong>第二回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">1</span>;</div><div class="line">cur = <span class="number">2</span>;</div><div class="line">=&gt; init + cur = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p><strong>第三回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">3</span>;</div><div class="line">cur = <span class="number">3</span>;</div><div class="line">=&gt; init + cur = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p><strong>第四回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">6</span>;</div><div class="line">cur = <span class="number">4</span>;</div><div class="line">=&gt; init + cur = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p><strong>第五回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">10</span>;</div><div class="line">cur = <span class="number">5</span>;</div><div class="line">=&gt; init + cur = <span class="number">15</span>;</div></pre></td></tr></table></figure>
<p><strong>😭妈妈啊，终于执行完了，这么多回合才结束，哪像人家格斗高手瞬间就把太极大师整挂了</strong></p>
<p>知道了一步步执行流程，我们来看下源码到底是怎么实现的。</p>
<p><strong>源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源码还是通过调用createReduce生成的，所以主要是看createReduce这个函数</span></div><div class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p><strong>这尼玛看起来好吓人啊，不怕，我们一点点来分析</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReduce</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">    <span class="comment">// Optimized iterator function as using arguments.length</span></div><div class="line">    <span class="comment">// in the main function will deoptimize the, see #1991.</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">obj, iteratee, memo, keys, index, length</span>) </span>&#123; <span class="comment">// 真正执行迭代的地方</span></div><div class="line">      <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">        <span class="keyword">var</span> currentKey = keys ? keys[index] : index; <span class="comment">// 如果keys存在则认为是obj形式的参数，所以读取keys中的属性值，否则类数组只需要读取索引index即可</span></div><div class="line">        memo = iteratee(memo, obj[currentKey], currentKey, obj); <span class="comment">// 接着就是执行外部传入的回调了，并将结果赋值为memo，也就是我们最后要到的值</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> memo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">      iteratee = optimizeCb(iteratee, context, <span class="number">4</span>); <span class="comment">// 首先绑定一下this作用域</span></div><div class="line">      <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), <span class="comment">// 如果不是类数组就读取其keys</span></div><div class="line">          length = (keys || obj).length,</div><div class="line">          index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>; <span class="comment">// 默认开始迭代的位置，从左边第一个开始还是右边第一个</span></div><div class="line">      <span class="comment">// Determine the initial value if none is provided.</span></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123; <span class="comment">// 如果没有传入初始化值，则将第一个值(左边第一个或者右边第一个)作为初始值</span></div><div class="line">        memo = obj[keys ? keys[index] : index];</div><div class="line">        index += dir; <span class="comment">// 从索引为1开始或者索引为length - 2开始迭代</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> iterator(obj, iteratee, memo, keys, index, length); <span class="comment">// 接着开始进入自定义的迭代函数，请往上看</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>夜深人静，有点困乏了。希望这篇文章对大家有点作用。如果对前几篇源码分析的文章感兴趣，欢迎前往顶部地址查看</p>
</blockquote>
<p>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</p>
<p>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</p>
<p>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[那些不起眼的小工具？]]></title>
      <url>https://qianlongo.github.io/2017/05/09/%E9%82%A3%E4%BA%9B%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/underscore-analysis/issues/5" target="_blank" rel="external">原文链接</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>今天想写一篇关于下划线这个库中一些小工具函数的故事，我们都听过一句话，一个成功的男人背后一定有一个了不起的女人(😀，其实也不一定，也许还有男人呢)，那么一个经久不衰，为程序猿们所称道的库，框架的背后自然也有不少看起来不起眼，甚至你都懒得正眼瞧他的”小工具”存在。正是这些背后的无名英雄为类库和框架的形成，贡献了不可磨灭的力量。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/tool.jpeg" alt="工具图片"></p>
<a id="more"></a>
<p><strong>第一篇文章说了undefined，那我们也从undefined开始。</strong></p>
<h2 id="isUndefined-obj"><a href="#isUndefined-obj" class="headerlink" title="_.isUndefined(obj)"></a>_.isUndefined(obj)</h2><blockquote>
<p>判断obj等于undefined与否，是就返回true，反之false。</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="literal">null</span></div><div class="line"><span class="keyword">let</span> b = <span class="built_in">window</span>.b</div><div class="line"><span class="keyword">let</span> c = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div><div class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span></div><div class="line"><span class="keyword">let</span> e = <span class="keyword">void</span> <span class="number">0</span></div><div class="line"><span class="keyword">let</span> f = <span class="string">'qianlongo'</span></div><div class="line"><span class="keyword">let</span> g</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(a)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(b)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(c())) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(d)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(e)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(f)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(_.isUndefined(g)) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>对于一个对象上不存在的属性</strong></p>
<p><strong>对于一个没有返回值的函数</strong></p>
<p><strong>对于声明和却没有赋值的标量</strong></p>
<p><strong>对于直接赋值为undefined(非ie8以下)或者void 0</strong></p>
<p>_.isUndefined都会返回true，其他情况全都是返回false</p>
<p>需要特别注意的是，有时候我们会这样判断一个变量是都存在，<code>a == null</code><br><code>a == undefined</code>都可以通难过判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a == <span class="literal">null</span>) &#123; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是_.isUndefined用的是三等强制判断，所以null是通过不了的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isNull-obj"><a href="#isNull-obj" class="headerlink" title="_.isNull(obj)"></a>_.isNull(obj)</h2><blockquote>
<p>判断obj等于null与否，是就返回true，反之false。</p>
</blockquote>
<p>这个没啥说的，只有obj输入<code>null</code>,结果输出才为true，因为内部判断也是用的三等判断，不仅值要相等，类型也要相同。</p>
<h2 id="noConflict"><a href="#noConflict" class="headerlink" title="_.noConflict()"></a>_.noConflict()</h2><blockquote>
<p>防止全局变量冲突的一种常见解决方案，将<em>的使用权交换给上一个占用</em>坑位的人。</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script src=<span class="string">"lodash.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"underscore.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(_)</div></pre></td></tr></table></figure>
<p>遇见重名的事不新鲜对吧，全国有多少个小明啊，我们从小到大课本里到处都是小明和小红。</p>
<p>这里后面引入的underscore.js把lodash.js给覆盖了，因为两个库都想占用全局的_,结果后来者居上。</p>
<p>如果不想lodash被覆盖怎么办，总的有个先来后到啊。只需要调用noConflict方法便将占着的<em>坑位重新归还给了lodash，而之后我们用my</em>即可访问所有underscore.js的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> my_ = _.noConflict()</div></pre></td></tr></table></figure>
<p><strong>接下来我们看下源码怎么实现的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> previousUnderscore = _ <span class="comment">// 在源码的顶部，保存了前一个占着_坑位的人</span></div><div class="line"> _.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    root._ = previousUnderscore; <span class="comment">// 将_重新赋值给前一个占着_坑位的人</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 并将_返回以供后续使用</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<h2 id="identity-value"><a href="#identity-value" class="headerlink" title="_.identity(value)"></a>_.identity(value)</h2><blockquote>
<p>返回与传入的参数value一样的值</p>
</blockquote>
<p><strong>这个函数看起来没有什么软用，但是在后面能够起非常大的作用，也正体现了，工具虽小，能量却大</strong></p>
<p>我们先来简单地看下它的应用，在后续的源码分析中遇到再仔细讲解。</p>
<ol>
<li>过滤一个数组中为”真”的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="literal">null</span>, <span class="string">'false'</span>, <span class="number">0</span>, <span class="string">'c'</span>, <span class="string">''</span>, <span class="literal">false</span>, &#123;&#125;]</div><div class="line"><span class="keyword">let</span> arr2 = arr.filter(_.identity) <span class="comment">// ["a", "b", "false", "c", &#123;&#125;]</span></div></pre></td></tr></table></figure>
<ol>
<li>复制数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="literal">null</span>, <span class="string">'false'</span>, <span class="number">0</span>, <span class="string">'c'</span>, <span class="string">''</span>, <span class="literal">false</span>, &#123;&#125;]</div><div class="line"><span class="keyword">let</span> arr2 = arr.map(_.identity) <span class="comment">// ["a", "b", null, "false", 0, "c", "", false, &#123;&#125;]</span></div></pre></td></tr></table></figure>
<h2 id="constant-value"><a href="#constant-value" class="headerlink" title="_.constant(value)"></a>_.constant(value)</h2><blockquote>
<p>返回一个函数fn，fn执行之后再返回当初传进来的value</p>
</blockquote>
<p>我们来看一段github上关于下划线的一个<a href="https://github.com/jashkenas/underscore/issues/402" target="_blank" rel="external">issue</a>，挺有意思的。也许我们比较难列举出这个函数的应用，但是至少下面这个例子是比较好的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> age = <span class="number">18</span></div><div class="line"><span class="keyword">let</span> cacheAge = _.constant(age)</div><div class="line"></div><div class="line">age += <span class="number">10</span></div><div class="line"><span class="built_in">console</span>.log(cacheAge()) <span class="comment">// 18</span></div></pre></td></tr></table></figure>
<p>为什么可以缓存住18，我们看下源码大概就知道了，源码创建了常见的闭包，闭包常见的作用之一就是让外面通过函数调用的形式去访问内部的变量，以及在一定的生命周期内，缓存住变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.constant = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> value;</div><div class="line">   &#125;;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<h2 id="noop"><a href="#noop" class="headerlink" title="_.noop()"></a>_.noop()</h2><blockquote>
<p>一个空函数，啥也不干，调用了就返回undefined给你，可以作为默认的回调参数</p>
</blockquote>
<p>又是一个看起来啥用都没有的函数，然而事实真的是这样吗？请移步以下几个链接</p>
<ol>
<li><a href="http://stackoverflow.com/questions/21572738/what-is-the-use-of-jquery-noop-function" target="_blank" rel="external">What is the use of jQuery.noop() function?</a></li>
<li><a href="http://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation" target="_blank" rel="external">What is the JavaScript convention for no operation?</a></li>
</ol>
<p>例子不用多，总结一下</p>
<p><strong>1. 给一个变量赋值为一个空函数，在后续的调用中你不需要去检测他是不是undefined</strong></p>
<p><strong>2. 为什么不给需要的变量重新设置一个空函数？ _.noop已经创建了一个函数空间，让其他变量也指向这个函数，可以减少js中不必要的花销</strong></p>
<h2 id="times-n-iteratee-context"><a href="#times-n-iteratee-context" class="headerlink" title="_.times(n, iteratee, context)"></a>_.times(n, iteratee, context)</h2><blockquote>
<p>调用给定的iteratee迭代函数n次，iteratee每次都接收一个索引值index，最后返回一个数组，数组中存着这几次iteratee的回调结果</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">0</span></div><div class="line"><span class="keyword">let</span> result = _.times(<span class="number">6</span>, (i) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(++count)</div><div class="line">  <span class="keyword">return</span> <span class="string">`hello:<span class="subst">$&#123;i&#125;</span>`</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result) <span class="comment">// ["hello:0", "hello:1", "hello:2", "hello:3", "hello:4", "hello:5"]</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>可以看到传进去的函数执行执行了6次，并将对应的每次执行的结果存在了数组中返回。</p>
<h2 id="random-min-max"><a href="#random-min-max" class="headerlink" title="_.random(min, max)"></a>_.random(min, max)</h2><blockquote>
<p>返回一个[min, max]之间的随机整数，如果没有传max，则区间是[0, min]</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let num1 = _.random(10, 20) // maybe 13 or other</div><div class="line">let num2 = _.random(10) // maybe 6 or other</div></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_.random = function(min, max) &#123;</div><div class="line">  if (max == null) &#123; // 如果只有一个参数</div><div class="line">    max = min; // 就把第一个参数当最大值</div><div class="line">    min = 0; // 0作为最小值</div><div class="line">  &#125;</div><div class="line">  return min + Math.floor(Math.random() * (max - min + 1));</div><div class="line">  // 试想我们要求取[4, 10)之间的某个整数</div><div class="line">  // (min) 就是保证最小值可以取到4</div><div class="line">  // (max - min + 1) =&gt; (10 - 4 + 1) =&gt; 7</div><div class="line">  // Math.random() * 7 =&gt; [0, 1) * 7 =&gt; [0, 7)</div><div class="line">  // Math.floor([0, 7)) =&gt; 最小取0， 最大取6</div><div class="line">  // 最后变成 4 + [0, 6] =&gt; [4, 10]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>当然啦，如果你传入非整数，或者max &lt; min的数，那结果就有可能不能按照预期出现了</strong></p>
<h2 id="uniqueId-prefix"><a href="#uniqueId-prefix" class="headerlink" title="_.uniqueId(prefix)"></a>_.uniqueId(prefix)</h2><blockquote>
<p>生成唯一的id，如果prefix不存在则直接将数字id返回，这个函数在给dom添加唯一的id的时候比较有用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let pre = &apos;qianlongo&apos;</div><div class="line">let id1 = _.uniqueId() // 1</div><div class="line">let id2 = _.uniqueId(pre) // qianlongo2</div></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var idCounter = 0;</div><div class="line">_.uniqueId = function(prefix) &#123;</div><div class="line">  var id = ++idCounter + &apos;&apos;; // 转成字符串</div><div class="line">  return prefix ? prefix + id : id;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="now"><a href="#now" class="headerlink" title="_.now()"></a>_.now()</h2><blockquote>
<p>一个优化的方式来获得一个当前时间的整数时间戳。</p>
</blockquote>
<p><strong>直接看源码</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.now = Date.now || function() &#123; // 如果原生支持now就用原生的，否知自己实现一个</div><div class="line">  return new Date().getTime();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>暂时就介绍这些看起来并不起眼的工具函数，在以后的文章和源码分析中遇到其他的会陆续更新到这篇文章中来。写一篇文章真够耗费时间的，陆陆续续用了好几个小时才写这么点。</p>
</blockquote>
<p><strong>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</strong></p>
<p><strong>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</strong></p>
<p><strong>不介意的话，在文章开头的源码地址那里点一个小星星吧😀</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(void 0)与undefined之间的小九九]]></title>
      <url>https://qianlongo.github.io/2017/05/08/%E4%B8%8Eundefined%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B0%8F%E4%B9%9D%E4%B9%9D/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/qianlongo/underscore-analysis/issues/4" target="_blank" rel="external">原文链接</a></p>
<p><a href="https://github.com/qianlongo/underscore-analysis" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>这是underscore.js源码分析的第一篇文章，为什么选择写这篇文章呢？其实主要有两点 </p>
</blockquote>
<ol>
<li>下划线源码中通篇可见这样的判断<code>obj === void 0</code>,初次看这样的写法完全不知道什么意思，所以想整明白它。</li>
<li>决定写一个系列把下划线分析完整，希望由浅入深，柿子捡软的捏，先从简单的开始入手(😀)</li>
</ol>
<p>写完这篇文章希望达到什么样的效果呢？</p>
<ol>
<li><p><strong>说明白为什么用(void 0)代替undefined</strong></p>
</li>
<li><p><strong>(void 0)的一些简单应用</strong></p>
</li>
</ol>
<p><img src="http://odssgnnpf.bkt.clouddn.com/aa36597c9b81cb72.jpg" alt="http://odssgnnpf.bkt.clouddn.com/aa36597c9b81cb72.jpg"></p>
<a id="more"></a>
<h2 id="void-0是个啥"><a href="#void-0是个啥" class="headerlink" title="void 0是个啥"></a>void 0是个啥</h2><blockquote>
<p>void 0是个啥，为毛它可以直接代替undefined关键字来做判断呢？我们可以看下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">mdn</a>上的解释</p>
</blockquote>
<p>The void operator evaluates the given expression and then returns undefined.</p>
<p><code>void 运算符 对给定的表达式进行求值，然后返回 undefined</code></p>
<p>啥？去执行了一段表达式，最后却得到undefined，那要是表达式执行的结果是2、3、8、毛主席万岁，也是返回undefined吗？答案是：对的。他就是这么个东西，不管你表达式里写的是个啥，我最后就是给你个undefined。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/timg2.jpeg" alt="黑人问号"></p>
<h2 id="undefined又是啥"><a href="#undefined又是啥" class="headerlink" title="undefined又是啥"></a>undefined又是啥</h2><blockquote>
<p>undefined是js原始类型值之一，也是全局对象window的属性，在部分低级别的浏览器中可以被修改，在局部作用域中也可以被修改。</p>
</blockquote>
<p><strong>首先我们来看这一段断码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'qianlongo'</span></div><div class="line">alert(<span class="literal">undefined</span>)</div></pre></td></tr></table></figure>
<p>最后console出来的是啥呢？<code>undefined</code> : <code>qianlongo</code>,<br>没图你说个js，接下来截取部分浏览器运行后的截图</p>
<p><strong>ie7</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170509-130124.png" alt="ie7"></p>
<p><strong>ie8</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170509-130142.png" alt="ie8"></p>
<p><strong>ie9</strong></p>
<p>测试结果为undefined</p>
<p><strong>ie10</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170509-130504.png" alt="ie10"></p>
<p><strong>chrome</strong></p>
<p>在最新的版本58.0.3029.81测试结果为undefined</p>
<p><strong>firefox</strong></p>
<p>在最新的版本52.0.2测试结果为undefined</p>
<p><strong>欧朋浏览器</strong></p>
<p>在最新的版本39.0.2256.48测试结果为undefined</p>
<p>你看ie老版本中就是那么任性，在全局作用域中可以直接改写undefined，也就是说当你想知道一个变量是不是等于undefined的时候直接这样判断已经不安全了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (obj === <span class="literal">undefined</span>) &#123;</div><div class="line">  <span class="comment">// xxx</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>接下来我们再看一段js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> testUndefined = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;</div><div class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'underscore'</span></div><div class="line">  <span class="keyword">var</span> <span class="built_in">window</span> = &#123;</div><div class="line">    <span class="string">'undefined'</span>: <span class="string">'qianlongo'</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>) <span class="comment">// &#123;'undefined': 'qianlongo'&#125;</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// underscore</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.undefined) <span class="comment">// qianlongo</span></div><div class="line">  <span class="built_in">console</span>.log(obj.name === <span class="literal">undefined</span>) <span class="comment">// false</span></div><div class="line">  <span class="built_in">console</span>.log(obj.name === <span class="built_in">window</span>.undefined) <span class="comment">// false</span></div><div class="line">  <span class="built_in">console</span>.log(obj.name === (<span class="keyword">void</span> <span class="number">0</span>)) <span class="comment">// true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">testUndefined()</div></pre></td></tr></table></figure>
<p><strong>可以得出，window，undefined本身在局部作用域中是可以被重写掉的</strong>，同样的道理，如果你在局部作用域中同样用以下代码来判断obj是不是undefined，是有风险的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (obj === undefined) &#123;</div><div class="line">  // xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为啥要用void-0来代替undefined"><a href="#为啥要用void-0来代替undefined" class="headerlink" title="为啥要用void 0来代替undefined"></a>为啥要用void 0来代替undefined</h2><blockquote>
<p>为啥要用void 0来代替undefined，基于以上介绍，原因就在这里了，void 0无论何时何地，后面跟了什么，结果都得到undefined，这正好是我们需要的。所以将上面的判断改写一下</p>
</blockquote>
<p>当然了还要另一个原因void 0 比undefined短</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (obj === void 0) &#123;</div><div class="line">  // xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="void-0的一些其他应用"><a href="#void-0的一些其他应用" class="headerlink" title="void 0的一些其他应用"></a>void 0的一些其他应用</h2><ol>
<li>填充a标签的href</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div style="height: 10000px;"&gt;&lt;/div&gt;</div><div class="line">&lt;a href="#"&gt;xxxx&lt;/a&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  console.log('xxxx')</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>上面这段代码使用一个#号来填充a标签的href属性，这其实是有一些弊端的，比如用户点击的时候，页面会回到顶部(<strong>网上有人说会刷新页面，但是自己试了好像不会</strong>)，试想我好不容易滚啊滚啊滚到xxxx这几个文字的地方，一不留神手贱点了一下，瞬间页面又回到顶部了，是不是要哭死😭。</p>
<p>所以常见的解决方法是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div style="height: 10000px;"&gt;&lt;/div&gt;</div><div class="line">&lt;a href="javascript:void(0)"&gt;xxxx&lt;/a&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  console.log('xxxx')</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<ol>
<li><a href="http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src" target="_blank" rel="external">What’s the valid way to include an image with no src?</a>,在这个问题中提到用void 0去替代image标签的空src属性会减少页面请求(是否属实有待考证)</li>
</ol>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>第一篇暂时写完了，欢迎大家吐槽和提意见。</p>
</blockquote>
<p>参考文章链接：</p>
<p><a href="http://stackoverflow.com/questions/7452341/what-does-void-0-mean" target="_blank" rel="external">What does “javascript:void(0)” mean?</a></p>
<p><a href="http://stackoverflow.com/questions/4806286/difference-between-void-0-and-undefined" target="_blank" rel="external">difference between “void 0 ” and “undefined”</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">void operator</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用原生js写一个多动症的简历]]></title>
      <url>https://qianlongo.github.io/2017/05/03/%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%9A%E5%8A%A8%E7%97%87%E7%9A%84%E7%AE%80%E5%8E%86/</url>
      <content type="html"><![CDATA[<h2 id="用原生js写一个”多动症”的简历"><a href="#用原生js写一个”多动症”的简历" class="headerlink" title="用原生js写一个”多动症”的简历"></a>用原生js写一个”多动症”的简历</h2><p><a href="https://qianlongo.github.io/resume-native/dist/">预览地址</a><br><a href="https://github.com/qianlongo/resume-native" target="_blank" rel="external">源码地址</a></p>
<blockquote>
<p>最近在知乎上看到@方应杭用vue写了一个<a href="https://zhuanlan.zhihu.com/p/25541520" target="_blank" rel="external">会动的简历</a>，觉得挺好玩的，研究一下其实现思路，决定试试用原生js来实现。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/160529jhf0hrzhffcl8jh4.jpg" alt="http://odssgnnpf.bkt.clouddn.com/return.gif"></p>
<a id="more"></a>
<h2 id="会动的简历实现思路"><a href="#会动的简历实现思路" class="headerlink" title="会动的简历实现思路"></a>会动的简历实现思路</h2><blockquote>
<p>这张会<code>动</code>的简历，就好像一个打字员在不断地录入文字，页面呈现动态效果。又好像一个早已经录制好影片，而我们只是坐在放映机前观看。</p>
</blockquote>
<p><strong>原理分两个部分</strong></p>
<ol>
<li>页面能看见的不断跳动着的增加的文字，由innerHTML控制</li>
<li>页面的布局效果由藏在”背后的”<code>style</code>标签完成</li>
</ol>
<p><strong>想象一下你要往一张网页每间隔0.1秒增加一个<code>啊</code>字，是不是开个定时器，间断地往body里面塞<code>啊</code>，就可以啊！没错，做到这一步就完成了原理的第一部分</strong></p>
<p><strong>再想象一下，在往页面里面塞<code>啊</code>的时候，我还想改变啊字的字体颜色以及网页背景颜色，那应该怎么做呢，是不是执行下面的代码就可以呢，没错，只不过更改字体和背景色不是突然改变的，而是也是开个定时器，间断地往<code>style</code>标签中塞入以下代码，这样就完成了原理的第二步，是不是好简单 😀😀😀， 接下来让我们一步步完成它</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.xxx&#123;</div><div class="line">  color: blue;</div><div class="line">  background: red; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><blockquote>
<p>在这个项目中我们</p>
</blockquote>
<ol>
<li>使用webpack2来完成项目的构建</li>
<li>使用yarn来处理依赖包的管理</li>
<li>使用es6的写法</li>
<li>使用部分原生dom操作api</li>
<li>standard.js(代码风格约束利器)</li>
</ol>
<p>目录结构如下</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170503-013138@2x.png" alt="目录结构"></p>
<p>最重要的几个模块分别是<code>resumeEditor(简历编辑模块)</code> 、 <code>stylesEditor(简历样式编辑模块)</code> 、 <code>以及vQuery(封装的dom操作模块)</code><br>最后<code>app.js(入口模块)</code>再将几个模块的功能结合起来完成整个项目。</p>
<h2 id="vQuery-封装的dom操作模块"><a href="#vQuery-封装的dom操作模块" class="headerlink" title="vQuery(封装的dom操作模块)"></a>vQuery(封装的dom操作模块)</h2><blockquote>
<p>因为后面的几个模块都要依赖这个小模块，所以我们先简单的看下。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vquery</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> (selector, context) &#123;</div><div class="line">    <span class="keyword">this</span>.elements = getEles(selector, context)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  optimizeCb (callback) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get (index) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  html (sHtml) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addClass (iClass) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  css (styles) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  height (h) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  scrollTop (top) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> (selector, context) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vquery(selector, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>可以看出它做的事就是封装一个构造函数Vquery，它的实例会有一些简单的dom操作方法，最后为了能够像jQuery那样使用$().funcName的形式去使用，我们导出了一个匿名函数，在匿名函数中去new Vquery</strong></p>
<h3 id="stylesEditor-简历样式编辑模块"><a href="#stylesEditor-简历样式编辑模块" class="headerlink" title="stylesEditor(简历样式编辑模块)"></a>stylesEditor(简历样式编辑模块)</h3><blockquote>
<p>简历所展现的布局效果都是由这个模块完成的,核心方法是showStyles。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> showStyles = <span class="function">(<span class="params">num, callback</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> style = styles[num]</div><div class="line">  <span class="keyword">let</span> length</div><div class="line">  <span class="keyword">let</span> prevLength</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!style) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  length = styles.filter(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123; <span class="comment">// 计算数组styles前n个元素的长度</span></div><div class="line">    <span class="keyword">return</span> i &lt;= num</div><div class="line">  &#125;).reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> &#123;</div><div class="line">    result += item.length</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line">  prevLength = length - style.length</div><div class="line"></div><div class="line">  clearInterval(timer)</div><div class="line">  timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> start = currentStyle.length - prevLength</div><div class="line">    <span class="keyword">let</span> char = style.substring(start, start + <span class="number">1</span>) || <span class="string">''</span></div><div class="line">    currentStyle += char</div><div class="line">    <span class="keyword">if</span> (currentStyle.length === length) &#123; <span class="comment">// 数组styles前n个元素已经全部塞入，则关闭定时器，并且执行外面传进来的回调，进而执行下一步操作</span></div><div class="line">      clearInterval(timer)</div><div class="line">      callback &amp;&amp; callback()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">let</span> top = $stylePre.height() - MAX_HEIGHT</div><div class="line">      <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123; <span class="comment">// 当塞入的内容已经超过了容器的高度，我们需要设置一下滚动距离才方便演示接下来的内容</span></div><div class="line">        goBottom(top)</div><div class="line">      &#125;</div><div class="line">      $style.html(currentStyle)</div><div class="line">      $stylePre.html(Prism.highlight(currentStyle, Prism.languages.css))</div><div class="line">    &#125;</div><div class="line">  &#125;, delay)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="stylesEditor-简历样式编辑模块-1"><a href="#stylesEditor-简历样式编辑模块-1" class="headerlink" title="stylesEditor(简历样式编辑模块)"></a>stylesEditor(简历样式编辑模块)</h2><blockquote>
<p>简历编辑模块用来展示简历内容，主要会经历由markdown格式往html页面形式的转换。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const markdownToHtml = (callback) =&gt; &#123;</div><div class="line">  $resumeMarkdown.css(&#123;</div><div class="line">    display: &apos;none&apos;</div><div class="line">  &#125;)</div><div class="line">  $resumeWrap.addClass(iClass)</div><div class="line">  $resumetag.html(marked(resumeMarkdown)) // 借助marked工具将markdown转化为html</div><div class="line">  callback &amp;&amp; callback() // 执行后续的回调</div><div class="line">&#125;</div><div class="line"></div><div class="line">const showResume = (callback) =&gt; &#123; // 原理基本上同stylesEditor， 不断地往简历编辑的容器中塞入事先准备好的简历内容，当全部塞入的时候再关闭定时器，并执行后续的回调操作</div><div class="line">  clearInterval(timer)</div><div class="line">  timer = setInterval(() =&gt; &#123;</div><div class="line">    currentMarkdown += resumeMarkdown.substring(start, start + 1)</div><div class="line">    if (currentMarkdown.length === length) &#123;</div><div class="line">      clearInterval(timer)</div><div class="line">      callback &amp;&amp; callback()</div><div class="line">    &#125; else &#123;</div><div class="line">      $resumeMarkdown.html(currentMarkdown)</div><div class="line">      start++</div><div class="line">    &#125;</div><div class="line">  &#125;, delay)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="app-入口模块"><a href="#app-入口模块" class="headerlink" title="app(入口模块)"></a>app(入口模块)</h2><blockquote>
<p>最后由app入口模块将以上几个模块整合完成项目的功能，我们找出其中的核心代码来, 😀，你没看错，传说中的回调地狱，亮瞎了我的狗眼啊。想必大家和我一样都是不愿意看到这坨恶心的代码的，但对于处理异步问题，回调又的确是一直以来的解决方案之一。</p>
</blockquote>
<p><strong>因为定时器的操作是异步行为，而我们的简历生成过程会涉及到多个异步操作，所以为了看到如首页预览链接的效果，必须等前一个步骤完成之后，才能执行下一步步骤，这里首先使用的回调函数的解决方案，大家可以从github上拉取代码，分别切换以下几个分支来查看不同的解决方案</strong></p>
<ol>
<li>master(使用回调函数处理)</li>
<li>promise(使用promise处理)</li>
<li>generator-thunk(使用generator + thunk函数处理)</li>
<li>generator-promise(使用generator + promise处理)</li>
<li>async(使用async处理)</li>
</ol>
<p><img src="http://odssgnnpf.bkt.clouddn.com/400-5.jpg" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">showStyles(<span class="number">0</span>, () =&gt; &#123;</div><div class="line">  showResume(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    showStyles(<span class="number">1</span>, () =&gt; &#123;</div><div class="line">      markdownToHtml(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        showStyles(<span class="number">2</span>)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="解决回调地狱之promise"><a href="#解决回调地狱之promise" class="headerlink" title="解决回调地狱之promise"></a>解决回调地狱之promise</h2><blockquote>
<p>回调方式能够解决异步操作问题，但是代码写起来非常的不美观，可读性差，代码呈横向发展趋势…伟大的程序员们开疆扩土发明了promise的解决方案。我们来看一下promise分支中app模块最终的写法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">showStylesWrap(<span class="number">0</span>)</div><div class="line">  .then(showResumeWrap)</div><div class="line">  .then(showStylesWrap.bind(<span class="literal">null</span>, <span class="number">1</span>))</div><div class="line">  .then(markdownToHtmlWrap)</div><div class="line">  .then(showStylesWrap.bind(<span class="literal">null</span>, <span class="number">2</span>))</div></pre></td></tr></table></figure>
<p><strong>可以看到，代码清爽了很多，纵向发展，应用第一步第二步第三步…一眼就能够看出来，当然实现的逻辑是将原来的相关的模块用Promise包装起来，并且在原来回调函数执行的地方resolve即可，详细实现，欢迎查看项目源码</strong></p>
<h2 id="解决回调地狱之generator-thunk，generator-promise"><a href="#解决回调地狱之generator-thunk，generator-promise" class="headerlink" title="解决回调地狱之generator-thunk，generator-promise"></a>解决回调地狱之generator-thunk，generator-promise</h2><blockquote>
<p>两种方式比较类似，都要用到es6中的generator。关于什么是generator，thunk函数，可以查看软大神关于<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a>,这里简要地讲述一下，其如何处理异步操作问题使得可以将异步行为写起来如同步般爽。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut1</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</div><div class="line">     g.next()</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut2</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>)</div><div class="line">  &#125;, <span class="number">200</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> timeOut1()</div><div class="line">  <span class="keyword">yield</span> timeOut2()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> g = gen()</div><div class="line">g.next()</div></pre></td></tr></table></figure>
<p><strong>上面的代码在过了200毫秒会log出2222，过了1秒钟之后log出1111</strong></p>
<p>这，要😭了，你不是说generator写起来同步可以解决异步问题吗，为毛这里timeOut2没有在timeOut1之后执行呢，毕竟gen函数中看起来是希望这样的嘛。</p>
<p>其实不然，timeOut2啥时候执行取决于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">g.next()</div><div class="line">g.next()</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">试想两个函数几乎同时执行，那在定时器中当然是200毫秒后的timeOut2先打印出2222来，但是有没有办法，让timeOut2在timeOut1后执行呢？答案是有的</div><div class="line"></div><div class="line">`<span class="string">``</span> javascript</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut1</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut2</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>)</div><div class="line">  &#125;, <span class="number">200</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> timeOut1()</div><div class="line">  <span class="keyword">yield</span> timeOut2()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> g = gen()</div><div class="line">g.next()</div><div class="line">g.next()</div></pre></td></tr></table></figure>
<p>可以看到我们在timeOut1执行完成之后，再将指针指向下一个位置，即timeOut2再去执行，这样的结果就和gen函数中两个yield的写起来同步感觉一样了。但是含有一个问题，如果涉及到很多个异步操作，我们是很难通过上面的方式将异步流程管理起来的。于是我们需要做下面一件事</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> gen = fn();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = gen.next(data);</div><div class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</div><div class="line">    result.value(next); <span class="comment">// thunk和promise不同地方之一在这里， promise是result.value.then(next)</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部的next函数就是 thunk 的回调函数。next函数先将指针移到 generator 函数的下一步（gen.next方法），然后判断 generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 thunk 函数（result.value属性），否则就直接退出。</p>
<p><strong>最后我们在看一下通过co函数的写法完成上面的例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="number">1111</span>)</div><div class="line">      callback()</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="number">2222</span>)</div><div class="line">      callback()</div><div class="line">    &#125;, <span class="number">200</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> gen = fn();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = gen.next(data);</div><div class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</div><div class="line">    result.value(next); <span class="comment">// thunk和promise不同地方之一在这里， promise是result.value.then(next)</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> timeOut1()</div><div class="line">  <span class="keyword">yield</span> timeOut2()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="解决回调地狱之async"><a href="#解决回调地狱之async" class="headerlink" title="解决回调地狱之async"></a>解决回调地狱之async</h2><blockquote>
<p>async其实就是generator函数的语法糖。大家如果把generator弄明白了，使用它一定不再话下，关于这个项目的用法，欢迎查看async分支源代码，这里不再赘述。</p>
</blockquote>
<h2 id="尾述"><a href="#尾述" class="headerlink" title="尾述"></a>尾述</h2><blockquote>
<p>本文中可能存在阐述不当的地方，欢迎大家指正。😀😀😀，最后点个赞，点个star好不好呀。<br><a href="https://github.com/qianlongo/resume-native" target="_blank" rel="external">源码地址</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出ES6（二）：迭代器和for-of循环]]></title>
      <url>https://qianlongo.github.io/2017/04/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAES6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.infoq.com/cn/es6-in-depth/" target="_blank" rel="external">原文线上地址</a></p>
<blockquote>
<p>最近经常去听门户的小伙伴的分享，非常的实用，内容属干货一类，都是实际工作中总结出来的东西，很值得学习。其中有小伙伴推荐一本es6深入浅出的书，看后觉得不错，现将相应的笔记记录下来。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/timg.jpeg" alt="es6"></p>
<a id="more"></a>
<h2 id="从迭代和循环说起"><a href="#从迭代和循环说起" class="headerlink" title="从迭代和循环说起"></a>从迭代和循环说起</h2><blockquote>
<p>很久很久以前，我们经常用如下的代码来访问数组中的元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(myArray[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>有一天es5、es6来临后，我们可以这样</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>有木有觉得这种写法简洁了许多，爽了许多，再也不用写该死的循环了</p>
<p><strong>但是你不能使用break语句中断循环，也不能使用return语句返回到外层函数。</strong></p>
<p><strong>但是你不能使用break语句中断循环，也不能使用return语句返回到外层函数。</strong></p>
<p><strong>但是你不能使用break语句中断循环，也不能使用return语句返回到外层函数。</strong></p>
<p>重要的话说三遍</p>
<h2 id="不要用for-in去遍历数组"><a href="#不要用for-in去遍历数组" class="headerlink" title="不要用for in去遍历数组"></a>不要用<code>for in</code>去遍历数组</h2><ol>
<li><p>在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。</p>
</li>
<li><p>作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">  arr.sex = <span class="string">'boy'</span></div><div class="line">	 </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[key]) <span class="comment">// 1, 2, 3, 4, boy</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。</li>
<li>简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。</li>
</ol>
<h2 id="强大的for-of循环"><a href="#强大的for-of循环" class="headerlink" title="强大的for-of循环"></a>强大的for-of循环</h2><blockquote>
<p>es6中我们还可以通过另外一种方式去遍历数组元素，便是<code>for of</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> arr) &#123;</div><div class="line">  <span class="built_in">console</span>.log(val) <span class="comment">// 1, 2, 3, 4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优势</strong></p>
<ol>
<li>最简洁、最直接的遍历数组的方式</li>
<li>这种方式避开了for in的所有缺陷</li>
<li>与forEach方式不同，其可以continue breack和return</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写一个node小爬虫]]></title>
      <url>https://qianlongo.github.io/2017/02/21/%E5%86%99%E4%B8%80%E4%B8%AAnode%E5%B0%8F%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>说起写node爬虫的原因，真是羞羞呀。一天，和往常一样，晚上吃过饭便刷起知乎来，首页便是推荐的<code>你见过最漂亮的女生长什么样？</code>,点进去各种漂亮的妹纸爆照啊！！!,看的我好想把这些好看的妹纸照片都存下来啊！一张张点击保存，就在第18张得时候，突然想起。我特么不是程序员么，这种手动<code>草</code>做的事，怎么能做，不行我不能丢程序员的脸了，于是便开始这次爬虫之旅。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/160529jhf0hrzhffcl8jh4.jpg" alt=""></p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>初入爬虫的坑，没有太多深奥的理论知识，要获取知乎上帖子中的一张图片，我把它归结为以下几步。</p>
</blockquote>
<ol>
<li>准备一个url(<code>当然是诸如你见过最漂亮的女生长什么样？😄</code>)</li>
<li>获取这个url的html内容，并分析其中的dom结构，遍历找到这些漂亮的妹纸图片url</li>
<li>获取图片内容</li>
<li>将图片内容写入本地文件</li>
</ol>
<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><blockquote>
<p>大概知道原理之后我们就可以开干了</p>
</blockquote>
<p><strong>准备一个url</strong></p>
<p>这个最简单了，去知乎随便一搜就是一大把，我们以</p>
<p><a href="https://www.zhihu.com/question/34078228" target="_blank" rel="external">发一张你认为很漂亮的美女照片？</a></p>
<p>为例子，先来分析一下这个页面的dom结构,其实很简单，知乎的一个页面中会包含很多种类型的图片，有头像，用户评价上传的图片啥的。基本上在<code>noscript</code>种都可以找到对应的图片地址。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/QQ20170401-000306@2x.png" alt=""></p>
<p><strong>获取这个url的html内容,并且拿到当前页面noscript中的img链接</strong></p>
<p>这一步我们需要会点简单的nodejs的知识，以及用到一个库叫<code>cheerio</code>,这个库具体是用来做什么的，详细请移步<a href="https://cheerio.js.org/" target="_blank" rel="external">cheerio</a>。</p>
<p>简单来说就是可以在命令行中使用jQuery来搜索遍历获取相应的元素。</p>
<p><strong>那么怎样才能获取这个帖子的html呢</strong></p>
<p>使用nodejs的https模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>)</div><div class="line"></div><div class="line">getAllHtml (url, callback) &#123;</div><div class="line">	<span class="keyword">let</span> sHtml = <span class="string">''</span>,</div><div class="line">    _this = <span class="keyword">this</span>;</div><div class="line">	https.get(url, (res) =&gt; &#123;</div><div class="line">	  res.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">	    sHtml += data;</div><div class="line">	  &#125;);</div><div class="line">	  res.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">	    callback.bind(_this, sHtml)();</div><div class="line">	  &#125;)</div><div class="line">	&#125;).on(<span class="string">'error'</span>, (err) =&gt; &#123;</div><div class="line">	  <span class="built_in">console</span>.log(err);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过以上操作拿到网站的html之后，便是遍历出我们需要的图片地址来了</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">filterHtml (sHtml, filePath) &#123;</div><div class="line">  <span class="keyword">let</span> $ = cheerio.load(sHtml), <span class="comment">// 将上一步拿到的网站html传入cheerio.load，便得到类似于包装过的jQuery对象，可以像jQuey的选择器一样来选择元素</span></div><div class="line">      $Imgs = $(<span class="string">'noscript img'</span>),</div><div class="line">      imgData = [],</div><div class="line">      _this = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    $Imgs.each(<span class="function">(<span class="params">i, e</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">let</span> imgUrl = $(e).attr(<span class="string">'src'</span>); <span class="comment">//取出对应的url</span></div><div class="line"></div><div class="line">      imgData.push(imgUrl);</div><div class="line">      <span class="comment">// 将url传入开始下载</span></div><div class="line">      _this.downloadImg(imgUrl, _this.filePath, </div><div class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(imgUrl + <span class="string">'has be down'</span>);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">console</span>.log(imgData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>有了图片的url，如何下载到本地呢？</strong><br>我们需要使用<code>request</code>这个库，简单的调用一下api再结合node原生写文件的api。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">downloadImg (imgUrl, filePath, callback) &#123;</div><div class="line">    <span class="keyword">let</span> fileName = <span class="keyword">this</span>.parseFileName(imgUrl);</div><div class="line">    request(imgUrl).pipe(fs.createWriteStream(<span class="string">'./'</span> + filePath + <span class="string">'/'</span>+fileName)).on(<span class="string">'close'</span>, callback &amp;&amp; callback);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>到这里就大功告成了，是不是很简单!!!</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>已经将源码放到gitHub了，欢迎查看。</p>
<p><a href="https://github.com/qianlongo/node-small-crawler" target="_blank" rel="external">项目github地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[this-想说爱你不容易]]></title>
      <url>https://qianlongo.github.io/2016/12/31/this-%E6%83%B3%E8%AF%B4%E7%88%B1%E4%BD%A0%E4%B8%8D%E5%AE%B9%E6%98%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>javascript中的this是啥东西？为啥我们经常被他搞得晕头转向不知所以？他是恶魔？是天使 ？是怪胎？让我们一起来揭开它那神秘的面纱。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD111.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="他是个啥"><a href="#他是个啥" class="headerlink" title="他是个啥"></a>他是个啥</h2><blockquote>
<p>首先<code>this</code>是Javascript语言的关键字之一，指函数<code>运行</code>时的当前对象。那既然和函数运行有关，js中函数有哪些调用模式呢？</p>
</blockquote>
<ol>
<li>纯粹的函数调用</li>
<li>对象的方法调用</li>
<li>构造函数调用</li>
<li>apply、call调用</li>
</ol>
<p><strong>我擦，有木有一千只草泥马在心里蹦腾不息，人家是要弄懂this，你这又是整的哪一出</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/1440757221622060.jpg" alt=""></p>
<p><strong>我们慢慢来，一步步从这些调用模式中探究this这个神奇的远古神兽</strong></p>
<h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><blockquote>
<p>函数调用 即 <code>functionName ()</code> 模式，这也是我们使用的最多的一种方式，其属于全局调用，浏览中默认情况下函数内部的this指向<code>window</code>，当然是在非严格模式下。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.name = <span class="string">'qianlong'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">showName() </div><div class="line"> </div><div class="line"><span class="comment">// qianlong</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="对象的方法调用"><a href="#对象的方法调用" class="headerlink" title="对象的方法调用"></a>对象的方法调用</h2><blockquote>
<p>当一个函数作为对象的某个属性方法被调用的时候</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showName();</div><div class="line"><span class="comment">// qianlong</span></div></pre></td></tr></table></figure>
<p><strong>可以看出<code>this</code>指向是obj这个对象，其实本质上讲函数调用形式内部<code>this</code>就是指向调用它的那个对象</strong></p>
<p>上面的例子相当于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.showName()</div></pre></td></tr></table></figure>
<p>这也是为什么可以读取到全局定义的name属性的原因。</p>
<p><code>再来</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">    <span class="attr">showName</span>: showName</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  obj.showName();</div></pre></td></tr></table></figure>
<p><strong>这个时候输出的是什么呢</strong></p>
<p>结果是不变的，在js中，一切都是对象，而这里也只是将，obj的showName属性指向，showNmae函数的引用地址。</p>
<p><code>继续</code></p>
<p>当我们把<code>showName</code>方法赋值给了一个变量，又会有什么事情发生呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> tempShowName = obj.showName;</div><div class="line"></div><div class="line">tempShowName()</div><div class="line"></div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>为什么不是期望的那样输出 qianlong呢。obj的showName方法是一个对象，当把它赋值给了tempShowName变量，此时便和obj没有什么关系了，而这个时候的调用和下面是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.tempShowName()</div></pre></td></tr></table></figure>
<p>window上此事并没有<code>name</code>属性，自然输出是<code>undefined</code>。</p>
<h2 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h2><blockquote>
<p>当使用 <code>new</code> 去调用一个构造函数的时候，内部的this，指向的是实例化出来的对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.sex = sex;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'qianlong'</span>, <span class="string">'boy'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Person &#123;name: 'qianlong', sex: 'boy'&#125;;</span></div></pre></td></tr></table></figure>
<p>构造函数也是函数，所以当你用普通调用方式调用时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.sex = sex;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person(<span class="string">'qianlong'</span>, <span class="string">'boy'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这个时候相当于给window对象添加了name和sex两个属性。</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.name <span class="comment">// 'qianlong'</span></div><div class="line"><span class="built_in">window</span>.sex <span class="comment">// 'boy'</span></div></pre></td></tr></table></figure>
<h2 id="apply、call调用"><a href="#apply、call调用" class="headerlink" title="apply、call调用"></a>apply、call调用</h2><blockquote>
<p>使用call和apply方式去调用一个函数的时候，内部的this指向的是传进来的第一个参数，当第一个参数是<code>undefined</code>或者<code>null</code>的时候，依旧指向<code>window</code></p>
</blockquote>
<p>关于call和apply欢迎查看另一篇文章</p>
<p><a href="https://qianlongo.github.io/2016/04/26/js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E9%82%A3%E4%BA%9B%E4%BA%8B/">js中call、apply、bind那些事</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">showName() <span class="comment">// window</span></div><div class="line">showName.call(<span class="literal">undefined</span>) <span class="comment">// window</span></div><div class="line">showName.call(<span class="literal">null</span>) <span class="comment">// window</span></div><div class="line">showName.call(&#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125;) <span class="comment">// &#123;name: 'qianlong'&#125;</span></div></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向，普通函数中的this，是运行时候决定的，而箭头函数却是定义时候就决定了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">showNameLater</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;		</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showNameLater();</div><div class="line"></div><div class="line"><span class="comment">// qianlong</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showName();</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><strong>一些坑</strong></p>
<ol>
<li>setTimeout</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">showNameLater</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">    setTimeout(<span class="keyword">this</span>.showName, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showNameLater();</div><div class="line"></div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>这里在执行setTimeout这个函数的时候传了obj的showName函数作为第一个参数，其效果与</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> showName = obj.showName</div></pre></td></tr></table></figure>
<p>是相同的。而setTimeout内部其实也是执行了传进去这个函数而已，即。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showName();</div></pre></td></tr></table></figure>
<p>还记得这种调用方式和<code>window.showName()</code>是类似的效果吗？这个时候输入为undefined也就好理解了。</p>
<p>那么怎么解决这个问题呢，毕竟我们期望的效果是输出<code>qianlong</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">showNameLater</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      self.showName();</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showNameLater();</div></pre></td></tr></table></figure>
<p><code>或者</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">showNameLater</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">    setTimeout(<span class="keyword">this</span>.showName.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.showNameLater();</div></pre></td></tr></table></figure>
<ol>
<li>setTimeout</li>
</ol>
<blockquote>
<p>尼玛坑爹啊，居然还是因为你。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">show(); <span class="comment">// undefined </span></div><div class="line"></div><div class="line">setTimeout(show, <span class="number">1</span>); <span class="comment">// window</span></div></pre></td></tr></table></figure>
<p>在严格模式下面，函数调用的时候没有指定this的情况下，内部this的表现为<code>undefined</code>,但是setTimeout却不同，其内部默认还是指向window。</p>
<ol>
<li>为构造函数指定this</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person.call(&#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Uncaught TypeError: Person.call is not a constructor</span></div></pre></td></tr></table></figure>
<p><code>这里报错了，原因是我们去 new 了 Person.call 函数 ，这里的函数不是一个构造函数；</code></p>
<p>当然解决方式也是有的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> (Person.bind(&#123;&#125;))(<span class="string">'qianlong'</span>, <span class="string">'sex'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Person &#123;name: "qianlong", sex: "sex"&#125;</span></div></pre></td></tr></table></figure>
<ol>
<li>为箭头函数指定this</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var show = (str) =&gt; &#123;</div><div class="line">  console.log(str);</div><div class="line">  console.log(this);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">show(&apos;qianlong&apos;);</div><div class="line">// qianlong</div><div class="line">// window</div><div class="line"></div><div class="line">show.call(&#123;name: &apos;qianlong&apos;&#125;, &apos;qianlong&apos;);</div><div class="line">// qianlong</div><div class="line">// window</div></pre></td></tr></table></figure>
<p>可以看到使用call来手动改变箭头函数中的this的时候，无法成功。 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>文章可能有些疏漏与错误之处，欢迎各位指正。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大学回忆-初入校门的那些囧事]]></title>
      <url>https://qianlongo.github.io/2016/11/20/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86-%E5%88%9D%E5%85%A5%E6%A0%A1%E9%97%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9B%A7%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>2016/11/20日，算算已经毕业快半年了啊。很快也很慢，趁着那4年美好的大学生活依稀在脑海，提笔追忆。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/V1paper-vol051-blogger11.jpg" alt=""></p>
<a id="more"></a>
<h2 id="那些囧事"><a href="#那些囧事" class="headerlink" title="那些囧事"></a>那些囧事</h2><blockquote>
<p>生活中你有没有做一些特别囧的事呢？比如让自己事后回想起来觉得特别逗，忍不住暴口 “我擦 怎么那么傻叉咧”。是哒，自己在刚进大学的时候就做了好几件囧事。你想看吗？ 跟着我来。</p>
</blockquote>
<h2 id="捅断钥匙"><a href="#捅断钥匙" class="headerlink" title="捅断钥匙"></a>捅断钥匙</h2><blockquote>
<p>前面说来接我们的<code>温程</code>同学因为不是江理的学生门卫不让进，所以只有我和陈良春两个人进去报道了。从校门口到宿舍楼下，不会告诉你我们走了接近40多分钟，当然了，这并不是说我们的学校大，而是因为特么的第一次来，一点都熟悉，再加上来的早学校根本没有几个人，偶尔碰上个也是早来的学生问路，结果他也只能大概指个方向。折折腾腾时间也就过去了。</p>
</blockquote>
<p>好不容易找到自己的寝室在4栋508，恰巧良春的寝室也在同一栋，管宿管叔叔要了钥匙便准备上楼放下行李。宿舍是那种4人的小间，还是上下铺，说好的上铺是床下铺是桌子的布局呢！不带这样的啊，呜呜。</p>
<p>本来学校小就有点不乐意了，但是宿舍的环境还这么差，当时的心情只有一个字。日了🐶了。</p>
<p>稍微收拾了一下，正打算关门出去走走的时候，神奇的事情发生了，由于不太熟悉这里的钥匙怎么用，看到这里你是不是心里暗暗想：尼玛这智障，钥匙都不会用么！ 其实你还真别想，我们学校的钥匙和一般常见的钥匙使用方式是不一样的，必须某个方向对准了，才可以开锁，而悲剧就是因为方向弄反，最后钥匙直接断里面了！断里面了！断里面了！</p>
<p>望着这丁点大的大学，捅断的钥匙。word 天，真是厉害了，咋这么倒霉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vscode使用不完全记录]]></title>
      <url>https://qianlongo.github.io/2016/11/13/vscode%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>工欲善其事，必先利其器。作为程序员的俺们，有一款适合自己的编辑器当然是非常好的一件事啦！！！前端开发经常使用的编辑器有<code>sublime</code>,<code>webstorm</code>,<code>atom</code>等等等。看的我都眼花缭乱了，这些编辑器各自有自己的优点与缺点，怎么选择还得看自己的实际需求。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/source-code-583537_960_720.jpg" alt="vscode"></p>
<a id="more"></a>
<h2 id="软件下载安装，编辑器对比。"><a href="#软件下载安装，编辑器对比。" class="headerlink" title="软件下载安装，编辑器对比。"></a>软件下载安装，编辑器对比。</h2><p><a href="https://code.visualstudio.com/download" target="_blank" rel="external">下载地址</a></p>
<p><a href="https://www.zhihu.com/question/41857899" target="_blank" rel="external">编辑器对比</a></p>
<h2 id="颜值-主题"><a href="#颜值-主题" class="headerlink" title="颜值(主题)"></a>颜值(主题)</h2><blockquote>
<p>写代码的时候有一个好看的主题，就像家里有一个漂亮的女盆友，撸代码的时候自然会有好心情。 😄，所以好看的主题自然不能少.</p>
</blockquote>
<ol>
<li>如果你使用过atom，一定很熟悉这种配色. <img src="http://odssgnnpf.bkt.clouddn.com/48280C7F-167E-4C54-A17E-66FF6AB12818.png" alt=""><br>那么你可以使用<code>One Dark Theme</code></li>
</ol>
<p>其它主题可以参看<a href="https://code.visualstudio.com/Docs/customization/themes" target="_blank" rel="external">vscode主题</a></p>
<h2 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h2><blockquote>
<p>有了好看的主题，接下来该安心coding啦，于是我们需要一些比较实用的插件来帮助我们更好的开发。</p>
</blockquote>
<ol>
<li>Path Intellisense (自动补全路径)</li>
<li>auto rename tag (自动修改html标签)</li>
<li>beautify(代码格式化插件)</li>
<li>git history (git 插件)</li>
<li>eslint (强大的代码检查插件)</li>
<li>jQuery Code Snippets (jQuery提示插件)</li>
</ol>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><blockquote>
<p>明显使用快捷键丢弃鼠标可以让我们的工作更加高效和快速，所以记住一些常用的快捷键是必要的。</p>
</blockquote>
<p>单行编辑</p>
<ol>
<li>⇧⌘K - 单行操作，删除光标所在行</li>
<li>⇧⌥↓ - 复制光标所在行到下一行</li>
<li>⌥↓ - 将光标所在行移至下一行</li>
</ol>
<p>多行编辑</p>
<ol>
<li>⌥⌘↓ - 向下插入一个光标，或者使用 ⌥ + Click</li>
<li>⇧⌥ + 鼠标拖动 - 多列区块选择，再配合 ⇧⌘→ 可选中至结尾处</li>
<li>⇧⌘L - 选择相同文本</li>
<li>⌘F2 - 选择相同单词，或者使用 ⌘D 依次加入选中</li>
</ol>
<p>代码定位</p>
<ol>
<li>⇧⌘\ - 跳转至对应匹配括号处</li>
<li>⇧⌘O - 跳转至对象、属性、方法</li>
<li>⌃G - 跳转至指定行</li>
<li>⌘↓ - 跳转至文件结尾</li>
<li>⇧⌘M - 显示当前文件的错误与警告信息</li>
<li>F12 - 跳转至定义行</li>
<li>⌥F12 - 浮窗打开定义行（可直接修改）</li>
<li>⌥⌘ + Click - 新开侧边窗口跳转至定义行</li>
<li>⇧⌘G - 选中上一次的查找结果</li>
</ol>
<p>代码展示</p>
<ol>
<li>⌥Z - 开启/关闭代码自动换行，还可通过 editor.wrappingColumn 配置单行最大字符数</li>
<li>⇧⌘[ - 代码折叠，⇧⌥⌘[ 为全部折叠</li>
<li>⇧⌘] - 代码展开，⇧⌥⌘] 为全部展开</li>
<li>⇧⌥F - 代码格式化</li>
</ol>
<p>窗口操作</p>
<ol>
<li>⌘1 ⌘2 ⌘3 - 切换至对应的子窗口</li>
<li>⌃Tab - 切换当前子窗口的标签页</li>
<li>⌃` - 打开内置 Terminal 窗口</li>
<li>⌘⇧U - 打开/关闭 Output 窗口，可查看 Extensions/Git/Task 输出</li>
</ol>
<h2 id="推荐几篇比较好的文章"><a href="#推荐几篇比较好的文章" class="headerlink" title="推荐几篇比较好的文章"></a>推荐几篇比较好的文章</h2><ol>
<li><a href="https://segmentfault.com/a/1190000006697219" target="_blank" rel="external"><br>vscode 插件精选 - 献给所有前端工程师</a></li>
<li></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一起来实现es5中新增的数组方法]]></title>
      <url>https://qianlongo.github.io/2016/10/22/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AE%9E%E7%8E%B0es5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>一直以来想写一篇关于es5中新增数组的使用方法与源码实现的文章，拖了挺久了，趁着这夜深人静，大脑清醒，又困意不在的时刻写下来。也许有人会问，现如今es6都大行其道了，还学es5是不是有些过时了，😄，温故而知新，可以为师矣，而且我们是要自己实现这些方法嘛，知其然还要知其所以然，不光要会用，还要知道为什么是这样用哒。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/43d555c6434bc10db279724d5aa66dc8.jpg" alt="前端配图"></p>
<a id="more"></a>
<h2 id="新增方法预览"><a href="#新增方法预览" class="headerlink" title="新增方法预览"></a>新增方法预览</h2><blockquote>
<p>es5中给js的数组增添了许多实用的方法，利用这些方法可以帮助我们更加快速方便的写js代码，然后蛋疼的是低版本ie肯定是不支持的，所以………………自己动手丰衣足食。让我们一步步看下如何使用与实现这些方法。</p>
</blockquote>
<ol>
<li>forEach </li>
<li>map </li>
<li>filter </li>
<li>some </li>
<li>every </li>
<li>indexOf </li>
<li>lastIndexOf </li>
<li>reduce </li>
<li>reduceRight </li>
</ol>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><blockquote>
<p>这个方法作用是啥咧，就是循环，遍历。比如一般我们在for循环做这样的事的时候如下。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[i], i, arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果用forEach我们应该如何做呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e, i, array)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>是不是觉得不用写for循环了，瞬间逼格都高了</strong></p>
<blockquote>
<p>forEach函数中的回调函数支持三个参数，<code>1、数组的值</code>，<code>2、值的索引</code>，<code>3、数组本身</code>。这样的调用方式是不是和jQuery中的$.each很像？ 其实不然，jQuery和forEach回调函数的第一个和第二个参数正好是反着来的。</p>
</blockquote>
<p><strong>看看对比</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// forEach</span></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e, i, array);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"></div><div class="line"><span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="number">2</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="number">3</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="number">4</span> <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="number">5</span> <span class="number">4</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// $.each</span></div><div class="line">$.each(arr, <span class="function"><span class="keyword">function</span> (<span class="params">i, e, array</span>) </span>&#123; <span class="comment">// 测试的时候发现array是undefined,查了文档也发现没有第三个参数</span></div><div class="line">  <span class="built_in">console</span>.log(i, e, array);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="literal">undefined</span></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="literal">undefined</span></div><div class="line"><span class="number">2</span> <span class="number">3</span> <span class="literal">undefined</span></div><div class="line"><span class="number">3</span> <span class="number">4</span> <span class="literal">undefined</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="literal">undefined</span></div></pre></td></tr></table></figure>
<p><strong>接着我们来看一下forEach的第二个参数，这个参数决定第一个回调函数的内部this指向</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">//  默认情况下，第二个参数不传入时</span></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e, i, array, <span class="keyword">this</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="built_in">window</span> </div><div class="line"><span class="number">2</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="built_in">window</span> </div><div class="line"><span class="number">3</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="built_in">window</span> </div><div class="line"><span class="number">4</span> <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="built_in">window</span> </div><div class="line"><span class="number">5</span> <span class="number">4</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="built_in">window</span> </div><div class="line"></div><div class="line"><span class="comment">// 传入参数</span></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e, i, array, <span class="keyword">this</span>);</div><div class="line">&#125;, &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"><span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125; </div><div class="line"><span class="number">2</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125; </div><div class="line"><span class="number">3</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125; </div><div class="line"><span class="number">4</span> <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125; </div><div class="line"><span class="number">5</span> <span class="number">4</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &#123;<span class="attr">name</span>: <span class="string">'qianlong'</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>最后接下来我们自己实现一下这个方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeArray = ObjPro.forEach;</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.forEach = nativeArray || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, ctx</span>) </span>&#123;  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (hasOwn.call(<span class="keyword">this</span>, i)) &#123;</div><div class="line">      callBack.call(ctx, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><blockquote>
<p>map是干嘛的！ 其最主要的作用就是将原数组按照一定的规则映射成一个新的数组。再将其返回，<code>注意是返回一个新的数组，而不是将原数组直接改变</code>使用方式和forEach类似,也是接受一个回调函数，一个改变内部this指向的对象。</p>
</blockquote>
<p><strong>map</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.map(callback,[ thisObject])</div></pre></td></tr></table></figure>
<p><strong>callback</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123;</div><div class="line">  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>举个栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'hello '</span> +  e;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"></div><div class="line">[<span class="string">"hello 1"</span>, <span class="string">"hello 2"</span>, <span class="string">"hello 3"</span>, <span class="string">"hello 4"</span>, <span class="string">"hello 5"</span>] <span class="comment">// newArr</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// arr</span></div></pre></td></tr></table></figure>
<p><strong>注意上面的return，如果我们不写return会怎样呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="string">'hello '</span> +  e;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"></div><div class="line">[<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// newArr</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// arr</span></div></pre></td></tr></table></figure>
<p>这一堆的undefined是啥情况，还记得一个函数执行完，如果没有显示的返回值，会返回什么吗？ <strong>没错</strong> 就是<code>undefined</code>，这就是原因所在，等会通过源码，你就会更加明白。</p>
<p><strong>最后我们自己实现一下map这个方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeMap = ObjPro.map;</div><div class="line">    </div><div class="line"><span class="built_in">Array</span>.prototype.map = nativeMap || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, ctx</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> returnArr = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    returnArr.push(callBack.call(ctx, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)); <span class="comment">// 这就是为什么回调函数没有返回值的情况下会得到一堆的undefined值，他将回调函数的返回值push到了一个数组里面，当你没有显示的返回值的时候，自然push进去的就是undefined了     </span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>  returnArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><blockquote>
<p>接下来是<code>filter</code>,筛选，过滤的意思，给你一个数组，用一些你制定的条件，对其中的值进行过滤，最后得到你想要的新的数组。基本用法和map差不多</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">array.filter(callback,[ thisObject]);</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line"></div><div class="line">但是和map也有差别的地方，filter需要你在callback处返回弱等于`<span class="literal">true</span><span class="string">` 的值,才会将原数组中筛选出的值返回给你。</span></div><div class="line"></div><div class="line">**举个栗子**</div><div class="line"></div><div class="line">`<span class="string">``</span> javascript</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> e;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// newArr</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> newArr2 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// ouput</span></div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="comment">// newArr2</span></div></pre></td></tr></table></figure>
<p><strong>当然最后还有第二个参数改变内部this指向的参数可选，默认是window对象，你也可以传一个对象进去, 最后我们自己来实现一下这个api</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeFilter = ObjPro.filter;</div><div class="line">    </div><div class="line"><span class="built_in">Array</span>.prototype.filter = nativeFilter || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, ctx</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> returnArr = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (callBack.call(ctx, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)) &#123;</div><div class="line">      returnArr.push(<span class="keyword">this</span>[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;	</div><div class="line">  <span class="keyword">return</span> returnArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="some-vs-every"><a href="#some-vs-every" class="headerlink" title="some vs every"></a>some vs every</h2><blockquote>
<p>some与接下里的every正好相对，<code>some</code>是只要数组中的某个值，符合你给定的判断条件就返回true，而<code>every</code>则是数组中的所有值都符合你给定的判断条件的时候才会返回true，否则就返回false,也就是说两个方法最后得到的都是true or false</p>
</blockquote>
<p><strong>举个栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e === <span class="number">3</span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// output  	</span></div><div class="line"><span class="literal">true</span> <span class="comment">// result;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> result2 = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">e, i, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e &gt; <span class="number">3</span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// output  	</span></div><div class="line"><span class="literal">false</span> <span class="comment">// result;</span></div></pre></td></tr></table></figure>
<p><code>some 和 every使用起来非常简单，接下来我们自己实现一把</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeSome = ObjPro.some,</div><div class="line">    nativeEvery = ObjPro.every;</div><div class="line">    </div><div class="line"><span class="comment">// some    </span></div><div class="line"><span class="built_in">Array</span>.prototype.some = nativeSome || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, ctx</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> resultValue = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (resultValue) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    resultValue = !!callBack.call(ctx, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>  resultValue;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// every</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.every = nativeEvery || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, ctx</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> resultValue = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!resultValue) &#123;</div><div class="line">      <span class="keyword">break</span>;	</div><div class="line">    &#125;</div><div class="line">    resultValue = !!callBack.call(ctx, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">  &#125;	</div><div class="line">  <span class="keyword">return</span> resultValue;  	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><blockquote>
<p>数组的indexOf方法和字符串的indexOf用法非常类似，<code>array.indexOf(searchElement[, fromIndex])</code>,针对给定的要查找的值，和开始查找的位置(可选)，返回整数索引值。</p>
</blockquote>
<p><strong>举个例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line">arr.indexOf(<span class="number">1</span>) <span class="comment">// 1</span></div><div class="line">arr.indexOf(<span class="number">3</span>, <span class="string">'qianlong'</span>) <span class="comment">// 3 因为给定的开始索引值不能转化成数字，所以还是从0位置开始搜索 </span></div><div class="line">arr.indexOf(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// -1</span></div><div class="line">arr.indexOf(<span class="number">3</span>, <span class="string">'4'</span>) <span class="comment">// -1</span></div><div class="line">arr.indexOf(<span class="string">'3'</span>) <span class="comment">// -1 // 判断条件是强 3 !== '3' =&gt; -1</span></div></pre></td></tr></table></figure>
<p><strong>实现代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeIndexOf = ObjPro.indexOf;</div><div class="line">    </div><div class="line"><span class="built_in">Array</span>.prototype.indexOf = nativeIndexOf || <span class="function"><span class="keyword">function</span> (<span class="params">searchElement, fromIndex</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> returnIndex = <span class="number">-1</span>,</div><div class="line">      fromIndex = fromIndex * <span class="number">1</span> || <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = fromIndex, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (searchElement === <span class="keyword">this</span>[i]) &#123;</div><div class="line">	   returnIndex = i;</div><div class="line">	   <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;     		</div><div class="line">  <span class="keyword">return</span> returnIndex;    	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><blockquote>
<p>数组的lastIndexOf方法和字符串的lastIndexOf用法非常类似，<code>array. lastIndexOf(searchElement[, fromIndex])</code>,针对给定的要查找的值，和开始查找的位置(可选)，返回整数索引值。与indexOf不同的地方在于，它是从后往前查找。默认开始查找的位置是 <code>array.length - 1</code></p>
</blockquote>
<p><strong>举个栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>];</div><div class="line"></div><div class="line">arr.lastIndexOf(<span class="number">1</span>) <span class="comment">// 9</span></div><div class="line">arr.lastIndexOf(<span class="number">3</span>, <span class="string">'qianlong'</span>) <span class="comment">// -1 这里和indexOf不一样，传入的值不能转化为数字将得到-1</span></div><div class="line">arr.lastIndexOf(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3</span></div><div class="line">arr.lastIndexOf(<span class="number">3</span>, <span class="string">'4'</span>) <span class="comment">// 3</span></div><div class="line">arr.lastIndexOf(<span class="string">'3'</span>) <span class="comment">// -1 // 判断条件是强 3 !== '3' =&gt; -1</span></div></pre></td></tr></table></figure>
<p><strong>源码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeLastIndexOf = ObjPro.lastIndexOf;</div><div class="line">    </div><div class="line"><span class="built_in">Array</span>.prototype.lastIndexOf = nativeLastIndexOf || <span class="function"><span class="keyword">function</span> (<span class="params">searchElement, fromIndex</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</div><div class="line">      returnIndex = <span class="number">-1</span>,</div><div class="line">      fromIndex = fromIndex * <span class="number">1</span> || len - <span class="number">1</span>;</div><div class="line">      </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = fromIndex; i &gt; <span class="number">-1</span>; i -= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[i] === searchElement)&#123;</div><div class="line">      returnIndex = i;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> returnIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><blockquote>
<p>reduce 相对es5中数添加的其他方法都复杂一些，我们可以通过栗子来看一下这个api怎么使用。首先基本参数如下</p>
</blockquote>
<p><code>array.reduce(callback[, initialValue])</code>,接收一个回调函数，一个初始化的值<code>initialValue</code>。其中callback参数分别是初始化的值<code>initialValue</code>,如果没有传入<code>initialValue</code>,则默认是数组的第一项。第二个及其后面的参数分别是<code>当前值</code>,<code>索引</code>,<code>数组本身</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</div><div class="line">    sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">init, cur, i, array</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> init + cur;</div><div class="line">    &#125;);	</div><div class="line">    </div><div class="line">   <span class="comment">//output</span></div><div class="line">   sum <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>我们来看一下上面的执行过程是怎样的。</p>
<p><strong>第一回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为initialValue没有传入所以回调函数的第一个参数为数组的第一项</span></div><div class="line"></div><div class="line">init = <span class="number">0</span>;</div><div class="line">cur = <span class="number">1</span>;</div><div class="line"></div><div class="line">=&gt; init + cur = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p><strong>第二回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">1</span>;</div><div class="line">cur = <span class="number">2</span>;</div><div class="line"></div><div class="line">=&gt; init + cur = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p><strong>第三回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">3</span>;</div><div class="line">cur = <span class="number">3</span>;</div><div class="line"></div><div class="line">=&gt; init + cur = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p><strong>第四回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">6</span>;</div><div class="line">cur = <span class="number">4</span>;</div><div class="line"></div><div class="line">=&gt; init + cur = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p><strong>第五回合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init = <span class="number">10</span>;</div><div class="line">cur = <span class="number">5</span>;</div><div class="line"></div><div class="line">=&gt; init + cur = <span class="number">15</span>;</div></pre></td></tr></table></figure>
<p>最后得到结果<code>15</code></p>
<p><strong>那么我们如何自己实现一个reduce呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeReduce = ObjPro.reduce;</div><div class="line">    </div><div class="line"><span class="built_in">Array</span>.prototype.reduce = nativeReduce || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, initialVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> init = initialVal,</div><div class="line">      i = <span class="number">0</span>;</div><div class="line">  </div><div class="line">      <span class="keyword">if</span> (init === <span class="keyword">void</span> (<span class="number">0</span>)) &#123;</div><div class="line">        init = <span class="keyword">this</span>[<span class="number">0</span>];</div><div class="line">        i = <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">  <span class="keyword">for</span> (i, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (hasOwn.call(<span class="keyword">this</span>, i)) &#123;</div><div class="line">      init = callBack(init, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">    &#125;  </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> init;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><blockquote>
<p>reduceRight基本用法与reduce类似，好比indexOf与lastIndexOf，不同之处在于它是从最右边的值开始计算的。我们直接去看源码怎么实现吧</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjPro = <span class="built_in">Object</span>.prototype,</div><div class="line">    hasOwn = ObjPro.hasOwnProperty,</div><div class="line">    nativeReduceRight = ObjPro.reduceRight;</div><div class="line">   </div><div class="line"><span class="built_in">Array</span>.prototype.reduceRight = nativeReduceRight || <span class="function"><span class="keyword">function</span> (<span class="params">callBack, initialVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack != <span class="string">'function'</span>) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> init = initialVal,</div><div class="line">      len = <span class="keyword">this</span>.length,</div><div class="line">      i = len - <span class="number">1</span>;</div><div class="line">      </div><div class="line">  <span class="keyword">if</span> (init === <span class="keyword">void</span>(<span class="number">0</span>)) &#123;</div><div class="line">    init = <span class="keyword">this</span>[len - <span class="number">1</span>];</div><div class="line">    i -= <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (i; i &gt; <span class="number">-1</span>; i -=<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (hasOwn.call(<span class="keyword">this</span>, i)) &#123;</div><div class="line">      init = callBack(init, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;    </div><div class="line">  <span class="keyword">return</span> init;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p> 终于写完了，断断续续快写了两天，欢迎大家看了以后提一些意见，函数实现的不一定都对，肯定有一些问题的地方，欢迎大家指正。</p>
</blockquote>
<p><strong>最后把代码放到github上面了</strong> </p>
<p><a href="https://github.com/qianlongo/es5-funcs" target="_blank" rel="external">github地址</a></p>
<p>各位大大，请让我打个小广告。😄😄😄</p>
<p><a href="https://qianlongo.github.io/">博客地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[underscore源码分析系列－3－对象方法简分析]]></title>
      <url>https://qianlongo.github.io/2016/10/16/underscore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%8D3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在前一篇文章中，我们主要说了<code>underscore</code>中几个很常见也很简单的api，在这篇博客中，我们希望说一下<code>对象</code>方面的api</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/687474703a2f2f6a6263646e322e62302e7570616979756e2e636f6d2f323031362f30322f65333666346164353166656637333466616536636466313535623035333233392e6a706567.jpeg" alt="underscore源码分析系列－3"></p>
<a id="more"></a>
<h2 id="isNull"><a href="#isNull" class="headerlink" title="_.isNull"></a>_.isNull</h2><blockquote>
<p>判断一个对象是不是null，如果事就返回true。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNull = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj === <span class="literal">null</span>;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意判断用的事三等，也就是当你传入undefined 的时候，返回的事false。</p>
<h2 id="isUndefined"><a href="#isUndefined" class="headerlink" title="_.isUndefined"></a>_.isUndefined</h2><blockquote>
<p>判断传入的值是否事undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isUndefined = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断条件中用的是 void，其作用的起到计算表达式的作用，计算结束之后永远返回undefined，为什么这里要用到void这个特性呢？ 本质上还是因为低版本的ie中undefined是可以被修改的。</p>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="_.isNaN"></a>_.isNaN</h2><blockquote>
<p>如果object 是 “不是一个数字”，则返回true。 </p>
</blockquote>
<p><strong>注意： 这和原生的isNaN 函数不一样，如果变量是undefined，原生的isNaN 函数也会返回 true 。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isNaN = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj !== +obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先判断传入的值是否是Number类型，接着判断该值是否等于本身。重点看后面的判断条件 <code>+obj</code>,这句话可以将字符串的数字转化成真正的数字，便排除了<code>isNaN</code>这种情况。</p>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="_.isObject"></a>_.isObject</h2><blockquote>
<p>如果object是一个对象，返回true。需要注意的是JavaScript数组和函数是对象，字符串和数字不是。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.isObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> obj;</div><div class="line">  <span class="keyword">return</span> type === <span class="string">'function'</span> || type === <span class="string">'object'</span> &amp;&amp; !!obj;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>js的集中数据类型中包括常见的<code>{}</code>,其实函数也看作是一种对象类型。当然<code>null</code>也称作是空对象。所以该api，将类型是<code>function</code>或者<code>object</code>(出了null)都返回true。</p>
<h2 id="isElement"><a href="#isElement" class="headerlink" title="_.isElement"></a>_.isElement</h2><blockquote>
<p>如果object是一个DOM元素，返回true。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.isElement = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过传入对象的nodeType属性来判断一个对象是否是DOM元素，其实这样并不严谨。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="attr">nodeType</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(_.isElement(obj)) =&gt; <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>可以看到只要对象有一个属性是nodeType并且是1，那么_.isElement就会认为这是一个DOM元素。</p>
<h2 id="has-object-key"><a href="#has-object-key" class="headerlink" title="_.has(object, key)"></a>_.has(object, key)</h2><blockquote>
<p>判断object对象是否含有key属性。 有则返回true，否则返回false</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ObjProto = Object.prototype;</div><div class="line">var hasOwnProperty = ObjProto.hasOwnProperty;</div><div class="line"></div><div class="line">_.has = function (obj, has) &#123;</div><div class="line">  return obj != null &amp;&amp; hasOwnProperty.call(obj, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里通过hasOwnProperty判断，也就是原形是上面的属性，不会去判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.sex = <span class="string">'boy'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'qianlong'</span>);</div><div class="line"></div><div class="line">_.has(p1, <span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">_.has(p1, <span class="string">'sex'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="isArray"><a href="#isArray" class="headerlink" title="_.isArray"></a>_.isArray</h2><blockquote>
<p>判断传入的值是否是数组，如果是就返回<code>true</code></p>
</blockquote>
<p>判断一个变量是否是数组，想必大家比较熟悉了，我们看下_中是怎么实现的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> toString = ObjProto.toString;</div><div class="line"><span class="keyword">var</span> nativeIsArray = <span class="built_in">Array</span>.isArray;</div><div class="line"></div><div class="line">_.isArray = nativeIsArray || <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object Array]'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在源码的开头保存了nativeIsArray，如果在支持该函数的浏览器中就用这个，如果在一些版本较低的浏览器中就用自己实现的。很显然其他的数据类型也可以用类似的方法来实现。</p>
<h2 id="isArguments-isFunction-isString-isNumber-isDate-isRegExp-isError"><a href="#isArguments-isFunction-isString-isNumber-isDate-isRegExp-isError" class="headerlink" title=".isArguments, .isFunction ,.isString, .isNumber, .isDate, .isRegExp, _.isError"></a><em>.isArguments, </em>.isFunction ,<em>.isString, </em>.isNumber, <em>.isDate, </em>.isRegExp, _.isError</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.each([<span class="string">'Arguments'</span>, <span class="string">'Function'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>, <span class="string">'Error'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    _[<span class="string">'is'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object '</span> + name + <span class="string">']'</span>;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>这里用到了其自身的工具方法<code>_.each</code>来对一个数组进行遍历，最后导出多个相应的判断数据类型的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[underscore源码分析系列－2－常见简单函数分析]]></title>
      <url>https://qianlongo.github.io/2016/10/16/underscore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%8D2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>这一篇源码分析中，我们会试着去看<code>underscore</code>几个比较常见的函数</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/075139_ey1FV7wc.jpg" alt=""></p>
<a id="more"></a>
<h2 id="random"><a href="#random" class="headerlink" title="_.random"></a>_.random</h2><blockquote>
<p>返回一个min 和 max之间的随机整数。如果你只传递一个参数，那么将返回0和这个参数之间的<code>整数</code>。取值范围是[min, max],注意是闭区间</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.random = <span class="function"><span class="keyword">function</span> (<span class="params">min, max</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (max == <span class="literal">null</span>) &#123;</div><div class="line">    max = min;</div><div class="line">    min = <span class="number">0</span>;</div><div class="line">  &#125;	</div><div class="line">  <span class="keyword">return</span> min + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数参数可以传进去两个或者一个，当为一个的时候，返回的是[0, max] 之间的一个整数，平实需要得到一个指定范围的数字的时候，比较常用。</p>
<h2 id="noConflict"><a href="#noConflict" class="headerlink" title="_.noConflict"></a>_.noConflict</h2><blockquote>
<p>放弃Underscore 的控制变量”_”。返回Underscore 对象的引用。也就是为了防止冲突而做的处理。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意在源码一开头有这句话</span></div><div class="line"><span class="keyword">var</span> previousUnderscore = root._;</div><div class="line"></div><div class="line">_.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  root._ = previousUnderscore;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码非常简单，就是把原来的全局变量_给赋值回去，而将underscore的引用作为函数调用后的返回值，提供给调用方使用。这是一种非常经典的防止全局冲突的方法。</p>
<p><strong>举个例子</strong>我们要写一个平实自己经常要用到的工具类，取的名字是$,当然假设之前，我们并不知道jQuery中也用了这个名字，那么在实际项目中为了防止自己写的这个工具库把全局的美元符号给污染掉，怎么办呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/jquery/3.0.0/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">win</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> prev$ = win.$,</div><div class="line">      $ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      </div><div class="line">      &#125;;</div><div class="line">      $.isUndefined = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> obj === <span class="keyword">void</span>(<span class="number">0</span>);		</div><div class="line">      &#125;</div><div class="line">      $.random = <span class="function"><span class="keyword">function</span> (<span class="params">min, max</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isUndefined(max)) &#123;</div><div class="line">          max = min;</div><div class="line">          min = <span class="number">0</span>;</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> min + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>))</div><div class="line">      &#125;;</div><div class="line">      $.showMessage = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">        alert(msg)</div><div class="line">      &#125;;</div><div class="line">      $.noConflict = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        win.$ = prev$;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line">      win.$ = $;</div><div class="line">&#125;)(<span class="built_in">window</span>);</div><div class="line"></div><div class="line"></div><div class="line">	$.showMessage(<span class="string">'hello world'</span>); <span class="comment">// 弹出hello world</span></div><div class="line">		</div><div class="line"><span class="comment">//自己写的$把jQuery中的$给覆盖掉了</span></div><div class="line">  </div><div class="line">    <span class="keyword">var</span> my$ = $.noConflict(); <span class="comment">// 不执行这句 下面的$() 调用会没有反应</span></div><div class="line">    </div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="string">'hello world two'</span>); <span class="comment">// 弹出hello world two</span></div><div class="line">    &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="noop"><a href="#noop" class="headerlink" title="_.noop"></a>_.noop</h2><blockquote>
<p>返回undefined，不论传递给它的是什么参数。 可以用作默认可选的回调参数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.noop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>underscore帮我们提供一个空函数，这个有啥用呢？ 其实还真有用处，平实如果我们要初始化某个变量为空函数，方便后面再把这个变量对应的值替换掉。又或者甚至用作判断一个变量是否是undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (a == _.noop()) &#123;</div><div class="line">  alert(<span class="string">'a 是 undefined'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">showMsg</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">showAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">showMsg</span>: _.noop,</div><div class="line">  <span class="attr">showAge</span>: _.noop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很显然这样可以有两个好处，</p>
<ol>
<li>因为在ie低版本中undefined的值可能被改写，所以导致判断不准确。但是如果直接于<code>_.noop()</code>相比较就不会有这个问题</li>
<li>直接给浏览器省了创建两个空函数的麻烦</li>
</ol>
<h2 id="now"><a href="#now" class="headerlink" title="_.now"></a>_.now</h2><blockquote>
<p>一个优化的方式来获得一个当前时间的整数时间戳。可用于实现定时/动画功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.now = <span class="built_in">Date</span>.now || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的浏览器提供的Date对象中含有now函数就用直接提供的，否则就用自己实现的。平常如果需要生成唯一的id，可以用到这个函数。</p>
<h2 id="identity"><a href="#identity" class="headerlink" title="_.identity"></a>_.identity</h2><blockquote>
<p>返回与传入参数相等的值,这个函数看似无用, 但是在Underscore里被用作默认的迭代器iterator.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.identity = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数非常简单就是你传进来什么东西就返还给你什么东西。</p>
<h2 id="constant"><a href="#constant" class="headerlink" title="_.constant"></a>_.constant</h2><blockquote>
<p>创建一个函数，这个函数返回传入的值 。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.constant = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="uniqueId"><a href="#uniqueId" class="headerlink" title="_.uniqueId"></a>_.uniqueId</h2><blockquote>
<p>为需要的客户端模型或DOM元素生成一个全局唯一的id。如果prefix参数存在， id 将附加在其后面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> idCounter = <span class="number">0</span>;</div><div class="line">_.uniqueId = <span class="function"><span class="keyword">function</span> (<span class="params">prefix</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = ++idCounter + <span class="string">''</span>; <span class="comment">// 将数字转化为字符串</span></div><div class="line">  <span class="keyword">return</span> prefix ? prefix + id : id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>万事开头难，啥复杂难的事都是从简单容易的事情开始做的，这篇博文主要讲了几个<code>underscore</code>中非常简单的api。接下来会慢慢接触一些比较难的，又非常重要的api。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你看，他们都在感恩]]></title>
      <url>https://qianlongo.github.io/2016/10/15/%E4%BD%A0%E7%9C%8B%EF%BC%8C%E4%BB%96%E4%BB%AC%E9%83%BD%E5%9C%A8%E6%84%9F%E6%81%A9/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是一篇在大一时候写的文章，转眼间过去四年，自己也开始出来工作，但是给爸妈唱《父亲》这首歌的感觉依然还在。愿我们时常心存感激、感恩。</p>
</blockquote>
<p>“鸦有反哺之情，羊有跪乳之义”生而为人，我们要懂得助人于困顿，救人于危难，更要懂得知恩图报，受之滴水，报以涌泉。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/thankyou.jpg" alt="感恩图片"></p>
<a id="more"></a>
<p>感恩是三顾茅芦的死而后已。生于战火纷飞的三国，你高卧茅芦，闲庭山水。“不求闻达于诸侯”是你志趣的归宿;“凤歌笑孔丘，一生好入名山游”是你个性的写照。但感于刘备三顾之恩，你毅然选择了出山，为了统一大业，你六出祈山，七擒孟获，排八阵，演七星赤壁火温暖了东吴，草船上刻有你的智慧。当汉室江山摇摇欲坠之际，你挽狂澜于既倒，扶大厦于将倾，用双手托起它的兴衰存亡。当五丈原的秋风刮起，你用一生的忠诚诠释了感恩的重量。</p>
<p>感恩是一杯奶的生命回报。美国著名医生富兰克林.道尔顿年幼时疾苦难当，一日，走在凛冽的寒风中，又累又饿的他透过街道旁的窗户，温暖的灯光下，一个小女孩正在和她的家人吃饭，有说有笑。鼓起万分勇气，他敲响了那座门。“能给我…一口水喝吗？”道尔顿怯怯地说道。“给，趁热喝吧，别冻着。”小女孩微笑着递过一杯牛奶。多年后道尔顿成就医业，为小女孩治愈不治之症，分文不取。他说:“一杯牛奶足以唤醒一颗感恩的生命。”是啊！感恩让我们懂得回报，让我们心怀善念。</p>
<p>感恩是乌锥马的含笑饮泣。当拔山举鼎的盖世传奇褪色成一页淡黄的史册，那一夜楚歌四起，士卒逃散。站在生命的弯道，是继续随项羽奋力杀敌，还是掉头东转，弃他而去？这一刻，不见你茫然失色，却见乌锥颈血尽染乌江。苍天抽泣大地无语。好一匹乌锥哦！感恩项羽，那一刻在流星划破天际的刹那，你真正与岁月长河完美对接。</p>
<p>小时候喜欢依偎在爸爸妈妈的怀抱，觉得他们是一座山，深幽的山。我是一条藤，缠绕的藤。藤不离山，山眷着藤。当山不再那么高大巍峨，藤就该奋力茁壮成长，为山送去一份阴凉，一份希冀。</p>
<p>   母亲节，唱了一首《父亲》给爸爸妈妈听，你们在儿子心中是同“一个人”，是最重要，最爱，最疼的人，我爱你……我是你的骄傲吗？还在为我而担心吗？ 你牵挂的孩子啊，长大啦。儿子长大啦，谢谢你们做的一切，双手撑起我们的家。以后儿子的手也要和你们紧紧地抱在一起，一起温暖我们的家……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react-slider]]></title>
      <url>https://qianlongo.github.io/2016/10/08/react-slider/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>react 自从去年火起来之后，在前端的应用可谓广泛，许多人为之倾倒，组件化，虚拟dom，从很大程度上将前端开发者的思维从jQuery dom操作的时代劈将开来。几个月之前用react配合webpack打包尝试写了一个轮播图滚动组件，一直没有纪录和总结下来，现在重新翻起，希望可以将其写成一篇博文，一是回顾react基本用法和应用，二是坚持写博文的习惯。</p>
</blockquote>
<p><a href="https://github.com/qianlongo/react-slider" target="_blank" rel="external">github地址</a></p>
<p><code>轮播图组件预览如下图</code></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/slider.gif" alt="轮播图图示"></p>
<a id="more"></a>
<h2 id="组件分析"><a href="#组件分析" class="headerlink" title="组件分析"></a>组件分析</h2><blockquote>
<p>首先我想做的组件主要目的是展示多张图片，并且可以通过左右按钮来进行切换，又或者可以通过底部的小点按钮进行图片切换。简要的画了一张组件示意图如下，将其拆分开来，可以分成</p>
</blockquote>
<ol>
<li>左右箭头（控制图片的左右切换）</li>
<li>底部小圆点（切换图片）</li>
<li>中间图片展示区域</li>
</ol>
<p>几个部分。</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/distance.png" alt="组件分析"></p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><blockquote>
<p>对要做的组件有了一个比较明确的划分之后，可以开始规划目录结构。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">--app</div><div class="line">  --components</div><div class="line">  	 --App <span class="comment">// 最终输出的完成的图片轮播组件</span></div><div class="line">  	 	--App.js</div><div class="line">  	 	--App.scss</div><div class="line">  	 --Arrows <span class="comment">// 箭头小组件</span></div><div class="line">  	 	--Arrows.js </div><div class="line">  	 	--Arrows.scss</div><div class="line">  	 --Dots <span class="comment">// 小点组件</span></div><div class="line">  	 	--Dots.js</div><div class="line">  	 	--Dots.scss</div><div class="line">  	 --Imgs <span class="comment">// 图片组件</span></div><div class="line">  	 	--Imgs.js</div><div class="line">  	 	--Imgs.scss</div><div class="line">  --images</div><div class="line">  	 ... <span class="comment">// 一些项目用到的图片</span></div><div class="line">  --libs</div><div class="line">    --base.js <span class="comment">// 输出react 需要用到的 React 和 DOM</span></div><div class="line">  --styles</div><div class="line">  	 ... <span class="comment">// 项目scss</span></div><div class="line">  --index.js	<span class="comment">// 入口文件</span></div><div class="line">--package.json <span class="comment">// 项目依赖与相关说明</span></div><div class="line">--READEME.md	 </div><div class="line">--webpack.config.js <span class="comment">// webpack配置文件</span></div><div class="line">--webpack.production.config.js <span class="comment">// 构建脚本</span></div></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><ul>
<li><strong>webpack配置文件</strong></li>
</ul>
<blockquote>
<p>webpack的配置文件很平常，就是日常项目里面用到的一点知识。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="keyword">var</span> ROOT_PATH = path.resolve(__dirname);</div><div class="line"><span class="keyword">var</span> APP_PATH = path.resolve(ROOT_PATH, <span class="string">'app'</span>);</div><div class="line"><span class="keyword">var</span> BUILD_PATH = path.resolve(ROOT_PATH, <span class="string">'build'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: APP_PATH, <span class="comment">// 入口文件</span></div><div class="line">  output: &#123; <span class="comment">// 输出文件</span></div><div class="line">    path: BUILD_PATH,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">devServer</span>: &#123; <span class="comment">// 静态服务</span></div><div class="line">    historyApiFallback: <span class="literal">true</span>,</div><div class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">inline</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">progress</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123; <span class="comment">// sass loader</span></div><div class="line">        test: <span class="regexp">/\.scss$/</span>,</div><div class="line">        <span class="attr">loaders</span>: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>],</div><div class="line">        <span class="attr">include</span>: APP_PATH</div><div class="line">      &#125;,</div><div class="line">      &#123; <span class="comment">// 图片loader 大于4兆的图片转成base64</span></div><div class="line">        test: <span class="regexp">/\.(png|jpg)$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'url?limit=40000'</span></div><div class="line">      &#125;,</div><div class="line">      &#123; <span class="comment">// es6语法支持loader</span></div><div class="line">        test: <span class="regexp">/\.jsx?$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">        <span class="attr">include</span>: APP_PATH,</div><div class="line">        <span class="attr">query</span>: &#123;</div><div class="line">          <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [ </div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="comment">// 快速生成html插件</span></div><div class="line">      title: <span class="string">'hello world app'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123; <span class="comment">// jQuery插件</span></div><div class="line">      $: <span class="string">"jquery"</span>,</div><div class="line">      <span class="attr">jQuery</span>: <span class="string">"jquery"</span>,</div><div class="line">      <span class="string">"window.jQuery"</span>: <span class="string">"jquery"</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>lib/base.js</strong></li>
</ul>
<blockquote>
<p>该文件主要作用是输出react和react-dom的引用这样在写<code>箭头组件</code>、<code>小点组件</code>、<code>图片组件</code>的时候就可以不用每次都去 <code>import</code>了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Render <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  React,</div><div class="line">  Render</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>很简单吧，就四句，后面需要用到react这两个关键库的时候可以通过以下方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;React, Render&#125; <span class="keyword">from</span> <span class="string">'./libs/base'</span>;</div></pre></td></tr></table></figure>
<p><strong>待续</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大学回忆-初入校门]]></title>
      <url>https://qianlongo.github.io/2016/10/08/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86-%E5%88%9D%E5%85%A5%E6%A0%A1%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>2016年10月8日凌晨12点半，窗外的秋雨淅淅沥沥地下着，不紧不慢，也不大声响，悄悄滴落在地。没有初夏的酷热难当，也没有冬日的凌烈寒风，此时入眠当是正好。闭眼想早早睡去，明日还得上班呢！然脑海思绪不断，大学一幕幕铺将开来，甚是怀念。遂起身开灯，将这时光赋予文字，记录下来。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E5%A4%A7%E4%B8%80.jpeg" alt="大一脐橙节"></p>
<a id="more"></a>
<p><strong>大一我们还懵懵懂懂，上课还是认真听讲的好孩子，喜欢参加各种社团，见到喜欢的女孩子还会害羞脸红…</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E8%A5%BF%E6%A0%A1%E5%8C%BA%E7%85%A7%E7%89%87.jpg" alt="大一离开西校区留影"></p>
<p><strong>转眼间，一张西校区的合影标志着，大一已经结束，大二的生涯就要开始</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E5%A4%A7%E4%B8%89.jpeg" alt="大三龙南游玩"></p>
<p><strong>时间到了大三，我们不再热衷于社团、学生会、各种活动，喜欢做些自己想做的事情，但是依旧迷茫</strong></p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/%E6%AF%95%E4%B8%9A%E7%85%A7%E7%89%871.jpg" alt="毕业学士照"></p>
<p><strong>穿上学士服的那一刻，我们毕业了</strong></p>
<blockquote>
<p>四年匆匆而过，离开校园的那一刻意味着你我都告别了一段纯真的青春，一段年少轻狂的岁月，一个充满幻想的时代…接下便是风雨兼程，为梦想多加努力。</p>
</blockquote>
<p>回想这四年，似乎很漫长，却又无时不刻在逝去，不经意间便从指尖溜走。这不，你我都背上行囊，奔向远方。还记得答辩前的不安，别离时的伤感，散伙饭时喝醉的惆怅吗？</p>
<h2 id="高考结束"><a href="#高考结束" class="headerlink" title="高考结束"></a>高考结束</h2><blockquote>
<p>高三的日子枯涩又极其酸甜，百无聊赖但却充实饱满，高考过后，同学间相互往来嬉闹，讨论分数，期待大学未来。分数出来后，不是很理想，又不太想离家乡太过遥远，于是选择了一所江西省声望不错的学校－江西理工大学。收到通知书的刹那，喜悦非常，日日幻想大学生活，开学日期定于9月12日前后，但迫不及耐，与好友<code>陈良春</code>准备8号便出发前往赣州梦想之地。</p>
</blockquote>
<h2 id="前往大学的路上"><a href="#前往大学的路上" class="headerlink" title="前往大学的路上"></a>前往大学的路上</h2><blockquote>
<p>上了大学之后才知道，原来许多学生的家长都会将其子女送到学校，孩子第一次出远门，多是放心不下，唯安全送达，方安心归家，并嘱咐一二，大学切以学业为重，不可荒废人生。自己从小爸妈就出远门打工，与爷爷相守，独立自是不必多说，倒也省去爸妈担心的困扰。收拾两三行李，带上爷爷的牵挂，便上路了。</p>
</blockquote>
<h2 id="大跌眼镜"><a href="#大跌眼镜" class="headerlink" title="大跌眼镜"></a>大跌眼镜</h2><blockquote>
<p>路途不长，3个小时。便到达赣州东河汽车站，暑假打暑期工时，认识一师院大二学生<code>温程</code>，他甚是贴切，担心我们路况不熟，社会阅历尚浅，容易被骗，就早早在车站接我们。终于来到理工大一新生校区，我已吐槽无力，这尼玛的就是我梦想的大学？ are you kidding me? </p>
</blockquote>
<p><strong>2016/11/20 新更</strong></p>
<p>转眼间距离写这篇回忆文章已经有一个多月了，这一个多月发生了发生了许多的事情，工作渐渐趋于稳定，业务更加熟悉，在现在的公司和同事们也相处的挺愉快的。我的宝贝女朋友晚上要我抱着才睡觉😄。</p>
<p>还是与上次一样的心情，准备开始继续写回忆啦。都说文字是记录回忆最好的佐证，因为随着时间的流逝，我们会忘记很多事情，忘记你曾经青春年少，忘记你为梦想奋斗努力…</p>
<p>come on !!!</p>
<p><img src="http://odssgnnpf.bkt.clouddn.com/1870.jpg" alt="江西理工大学西校区校门口照片"></p>
<p>!!!没错这就是我大学开始的地方，江西理工大学西校区。在以后的日子里，整整一年的时间里我都要在这里度过。用一句话阐述自己对大学的印象就是。尼玛，这比高中的学校还小，这是在逗我么。老天，我要回去复读!!!</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>一直憧憬的大学生活，我来了，和想象中有点不一样，接下来，又会有怎样的生活呢!!! </p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[underscore源码分析系列－1－整体结构]]></title>
      <url>https://qianlongo.github.io/2016/08/21/underscore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%8D1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>一直希望有一个机会可以阅读某库的源码，并写一些自己的想法和思考，最终将目标定在<code>underscore</code>,一个纯粹的js工具库，没有dom、bom的参与。</p>
</blockquote>
<p><img src="http://odssgnnpf.bkt.clouddn.com/underscorejs.png" alt="underscore.js"></p>
<a id="more"></a>
<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><blockquote>
<p>首先我们来看一下，underscore工具库的整体框架</p>
</blockquote>
<p><code>verison</code> <code>1.8.3</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	</div><div class="line">  <span class="comment">//拿到一个全局对象，browser中是window对象，server中是exports</span></div><div class="line">  <span class="keyword">var</span> root = <span class="keyword">this</span>;</div><div class="line">	</div><div class="line">  <span class="comment">// 缓存一些原生js的原型以及es5的方法</span></div><div class="line">	</div><div class="line">  <span class="comment">// ...</span></div><div class="line">	</div><div class="line">  <span class="comment">//underscore工具库的构造函数</span></div><div class="line">  <span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">    <span class="keyword">this</span>._wrapped = obj;</div><div class="line">  &#125;;</div><div class="line">	</div><div class="line">  <span class="comment">//将构造函数暴露给全局</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports)&#123;</div><div class="line">      exports = <span class="built_in">module</span>.exports = _;</div><div class="line">    &#125;</div><div class="line">    exports._=_;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    root._ = _;</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">  <span class="comment">// 版本</span></div><div class="line">	</div><div class="line">  _.VERSION = <span class="string">'1.8.3'</span>;</div><div class="line">	</div><div class="line">  <span class="comment">/*underscore中一些内部变量和函数*/</span></div><div class="line">	</div><div class="line">  <span class="comment">//...</span></div><div class="line">	</div><div class="line">  <span class="comment">/*提供给外部调用的静态api*/</span></div><div class="line">	</div><div class="line">  _.each = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  _.first = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  _.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  _.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  _.noConfict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  _.chain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  <span class="comment">//...</span></div><div class="line">	</div><div class="line">  <span class="comment">//一些原型上面的方法</span></div><div class="line">	</div><div class="line">  _.prototype.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">  &#125;;</div><div class="line">  <span class="comment">//...</span></div><div class="line">	</div><div class="line">  <span class="comment">//支持amd</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;	define(<span class="string">'underscore'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> _;</div><div class="line">   &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;).call(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p><strong>大体框架如上所述</strong></p>
<p>接下来我们看一下underscore库刚开始设置哪些后面要用到的常用的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="comment">// 保存引进underscore库之前可能存在于全局对象下面的_属性值，主要给noConflict静态函数做去冲突用</span></div><div class="line"><span class="keyword">var</span> previousUnderscore = root._;</div><div class="line"></div><div class="line"><span class="comment">// 保存一些长江的构造函数的原型，数组，对象，函数等</span></div><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype, FuncProto = <span class="built_in">Function</span>.prototype;</div><div class="line"></div><div class="line"><span class="comment">// 保存一些数组的常见方法</span></div><div class="line"><span class="keyword">var</span></div><div class="line">  push             = ArrayProto.push,</div><div class="line">  slice            = ArrayProto.slice,</div><div class="line">  toString         = ObjProto.toString,</div><div class="line">  hasOwnProperty   = ObjProto.hasOwnProperty;</div><div class="line"></div><div class="line"><span class="comment">// 保存es5的一些方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span></div><div class="line">  nativeIsArray      = <span class="built_in">Array</span>.isArray,</div><div class="line">  nativeKeys         = <span class="built_in">Object</span>.keys,</div><div class="line">  nativeBind         = FuncProto.bind,</div><div class="line">  nativeCreate       = <span class="built_in">Object</span>.create;</div></pre></td></tr></table></figure>
<h2 id="underscore构造函数"><a href="#underscore构造函数" class="headerlink" title="underscore构造函数"></a>underscore构造函数</h2><blockquote>
<p>最后我们来看一下，构造函数本身。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj; <span class="comment">// 如果传进来的obj是_的实例，那么直接将obj返回</span></div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj); <span class="comment">// 如果不是_的实例，那么内部直接new 一个 _的实例，然后返回</span></div><div class="line">    <span class="keyword">this</span>._wrapped = obj; <span class="comment">// 给_的实例挂一个属性_wrapped，并赋值为obj</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p><strong>underscore构造函数内部这样处理，可以保证不管外部是否适用new的形式调用，都会拿到一个underscore实例</strong></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>underscore.js第一篇就先到这里，了解了其整体的结构，接下来我们开始分析一些比较常用的函数。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery源码分析－分析碎片－init解读]]></title>
      <url>https://qianlongo.github.io/2016/08/14/jQuery%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8D%E5%88%86%E6%9E%90%E7%A2%8E%E7%89%87%EF%BC%8Dinit%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>距离上一次写博客已经快4个月了，4个月快也慢，转眼间自己便毕业离开学校由一名学生成为一名<strong>上班狗</strong>。想起6月初答辩时的紧张不安，别离时的万分不舍，一切仿佛就在眼前…</p>
</blockquote>
<p><strong>😄，好像跑偏了，哈哈哈！今天想开始写关于jQuery源码解读的系列博客，jQuery是前端开发人员使用非常广的类库之一，帮助我们解决了许多现实问题，希望通过查看jQuery源码，学习其中的编程技巧，设计模式，以及前端开发中常见的知识点等等</strong></p>
<hr>
<a id="more"></a>
<h2 id="分析碎片－init解读"><a href="#分析碎片－init解读" class="headerlink" title="分析碎片－init解读"></a>分析碎片－init解读</h2><blockquote>
<p>jQuery使用起来非常的方便，和常见的js面相对象写法有些差异，我们可以通过<code>$()</code>函数调用的形式来创建一个jQuery实例，从而省去<code>new</code> 操作的麻烦。</p>
</blockquote>
<p>为什么可以这样呢？ 老师告诉我们当你要创建对象的时候，请<code>new</code> 一个，现在不<code>new</code>为啥就可以创建对象了嘛，其实并不是没有<code>new</code>只是jQuery把这个操作放在了内部，请看…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</div><div class="line"><span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>可以看出，当我们在$()方法的时候，本质上通过jQuery.fn.init这个构造器创建了一个实例</strong>接下来，我们开始一步步看jQuery.fn.init这个构造器都做了一些什么事</p>
<h2 id="的常见用法"><a href="#的常见用法" class="headerlink" title="$() 的常见用法"></a>$() 的常见用法</h2><p>关于jQuery $()的常见用法欢迎查看<a href="http://qianlongo.github.io/2016/03/26/jQuery%E4%B8%AD-%E5%87%BD%E6%95%B0%E7%9A%847%E7%A7%8D%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/">$()的七种常见用法</a></p>
<p>其中最常用的方式是给$()传进去一个字符串和执行上下文，也就是 jQuery(selector,context)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> match, elem;</div><div class="line"></div><div class="line">	<span class="comment">// HANDLE: $(""), $(null), $(undefined), $(false)</span></div><div class="line">	<span class="keyword">if</span> ( !selector ) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>init方法中一开始便将传进来的selector进行了一层判断，当selector为</p>
<ul>
<li>空字符串</li>
<li>null</li>
<li>undefined</li>
<li>false </li>
</ul>
<p>在js中表示为<code>假</code>操作的时候，便直接返回一个jQuery实例，只不过该实例与一般的jQuery对象有些不同，该实例没有0，1，2…引用着某个dom的属性也没有表示长度的length属性等</p>
<p>紧接着</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> selector === <span class="string">"string"</span> ) &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector.nodeType) &#123;</div><div class="line"> 	<span class="comment">// ...</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jQuery.isFunction( selector )) &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对传进来的selector又进行了多层if else if判断，我们先看第一个<code>typeof selector === &quot;string&quot;</code></p>
<p>日常在用jQuery的时候，当传进去的selector是字符串的时候我们可能会涉及到以下用法</p>
<p><code>选择元素的常见用法</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#div1'</span>) </div><div class="line">$(<span class="string">'.box'</span>) </div><div class="line">$(<span class="string">'div'</span>)  </div><div class="line">$(<span class="string">'#div1 div.box'</span>)</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">`  </span></div><div class="line"></div><div class="line">`创建元素的常见用法<span class="string">`</span></div><div class="line"></div><div class="line">`<span class="string">``</span> javascript</div><div class="line">$(<span class="string">'&lt;li&gt;'</span>)  </div><div class="line">$(<span class="string">'&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;'</span>)</div></pre></td></tr></table></figure>
<p><strong>在进入selctor已经是<code>string</code>判断的时候</strong>，接下来jQuery将</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( selector.charAt(<span class="number">0</span>) === <span class="string">"&lt;"</span> &amp;&amp; selector.charAt( selector.length - <span class="number">1</span> ) === <span class="string">"&gt;"</span> &amp;&amp; selector.length &gt;= <span class="number">3</span> ) &#123;</div><div class="line">	<span class="comment">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></div><div class="line">	match = [ <span class="literal">null</span>, selector, <span class="literal">null</span> ];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	match = rquickExpr.exec( selector );	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'&lt;div&gt;'</span>)</div><div class="line">$(<span class="string">'&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;'</span>)</div></pre></td></tr></table></figure>
<p>符合以上selector场景的match置成了一个数组<code>match = [ null, selector, null ];</code></p>
<p>而将符合以下参数条件的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;#div1&apos;) </div><div class="line">$(&apos;.box&apos;) </div><div class="line">$(&apos;div&apos;) </div><div class="line">$(&apos;#div1 div.box&apos;)</div><div class="line">$(&apos;&lt;div&gt;test&apos;)</div></pre></td></tr></table></figure>
<p>通过正则匹配将</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js中call、apply、bind那些事]]></title>
      <url>https://qianlongo.github.io/2016/04/26/js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>回想起之前的一些面试，几乎每次都会问到一个js中关于call、apply、bind的问题，比如…</p>
</blockquote>
<ol>
<li>怎么利用call、apply来求一个数组中最大或者最小值</li>
<li>如何利用call、apply来做继承</li>
<li>apply、call、bind的区别和主要应用场景</li>
</ol>
<a id="more"></a>
<blockquote>
<p>虽然网上有很多关于这方面的博客和文章，但还是决定写一篇自己对这方面知识的理解。</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<p>首先问个问题，这三个函数的存在意义是什么？答案是<strong>改变函数执行时的上下文</strong>，再具体一点就是<strong>改变函数运行时的this指向</strong>。有了这个认识，接下来我们来看一下,怎么使用这三个函数。</p>
</blockquote>
<p><strong>举个栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">showName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'qianlong'</span>);</div><div class="line">  person.showName();</div></pre></td></tr></table></figure>
<p>上面的代码中person调用showName方法后会在浏览器的控制台输出<code>qianlong</code></p>
<p><strong>接下来</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'cat'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中有一个对象字面量，他没有所谓的showName方法，但是我还是想用？怎么办？(坑爹了，这好像在让巧媳妇去做无米之炊)，不过没关系，call、apply、bind可以帮我们干这件事。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1 call</span></div><div class="line">person.showName.call(animal);</div><div class="line"><span class="comment">// 2 apply</span></div><div class="line">person.showName.apply(animal);</div><div class="line"><span class="comment">// 3 bind</span></div><div class="line">person.showName.bind(animal)();</div></pre></td></tr></table></figure>
<p><strong>啦啦啦，有木有很神奇，控制台输出了三次<code>cat</code></strong></p>
<p>我们拿别人的showName方法，并动态改变其<strong>上下文</strong>帮自己输出了信息，说到底就是实现了<strong>复用</strong></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote>
<p>上面看起来三个函数的作用差不多，干的事几乎是一样的，那为什么要存在3个家伙呢，留一个不就可以。所以其实他们干的事从本质上讲都是一样的<strong>动态的改变this上下文</strong>,但是多少还是有一些差别的..</p>
</blockquote>
<p><strong>call、apply与bind的差别</strong></p>
<blockquote>
<p>call和apply改变了函数的<strong>this</strong>上下文后便<strong>执行</strong>该函数,而bind则是返回改变了上下文后的一个函数。</p>
</blockquote>
<p><strong>call、apply的区别</strong></p>
<blockquote>
<p>他们俩之间的差别在于参数的区别，call和aplly的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">fn.call(obj, arg1, arg2, arg3...);</div><div class="line">fn.apply(obj, [arg1, arg2, arg3...]);</div></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<p>知道了怎么使用和他们之间的区别，接下来我们来了解一下通过call、apply、bind的常见应用场景。</p>
</blockquote>
<ul>
<li><strong>求数组中的最大和最小值</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>];</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</div><div class="line"><span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</div><div class="line"><span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</div></pre></td></tr></table></figure>
<ul>
<li><strong>将伪数组转化为数组</strong></li>
</ul>
<blockquote>
<p>js中的伪数组(例如通过<code>document.getElementsByTagName</code>获取的元素)具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayLike = &#123;</div><div class="line">  <span class="number">0</span>: <span class="string">'qianlong'</span>,</div><div class="line">  <span class="number">1</span>: <span class="string">'ziqi'</span>,</div><div class="line">  <span class="number">2</span>: <span class="string">'qianduan'</span>,</div><div class="line">  <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是一个普通的对象字面量，怎么把它变成一个数组呢？最简单的方法就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</div></pre></td></tr></table></figure>
<p>上面arr便是一个包含arrayLike元素的真正的数组啦( <strong>注意数据结构必须是以数字为下标而且一定要有length属性</strong> )</p>
<ul>
<li><strong>数组追加</strong></li>
</ul>
<blockquote>
<p>在js中要往数组中添加元素，可以直接用push方法，</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"></div><div class="line">[].push.apply(arr1, arr2);</div><div class="line"></div><div class="line"><span class="comment">// arr1 [1, 2, 3, 4, 5, 6]</span></div><div class="line"><span class="comment">// arr2 [4,5,6]</span></div></pre></td></tr></table></figure>
<p><strong>判断变量类型</strong></p>
<blockquote>
<p>对于对象型的数据类型，我们可以借助call来得知他的具体类型，例如数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">isArray([]) <span class="comment">// true</span></div><div class="line">isArray(<span class="string">'qianlong'</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><strong>2016.12.31日更新，有些读者对文章提了一些意见，觉得还是蛮好的，现在就其中部分进行更新。</strong></p>
<p><strong>利用call和apply做继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Girl = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  Person.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Boy = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</div><div class="line">  Person.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> Girl (<span class="string">'qing'</span>);</div><div class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Boy(<span class="string">'qianlong'</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于canvas的局部清晰图片查看效果]]></title>
      <url>https://qianlongo.github.io/2016/04/24/%E5%9F%BA%E4%BA%8Ecanvas%E7%9A%84%E5%B1%80%E9%83%A8%E6%B8%85%E6%99%B0%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>一直对canvas非常感兴趣，今天抽空写了一个在一张模糊图片中查看局部清晰图的小demo,时间比较晚了,先放图，明日写博文.</p>
</blockquote>
<iframe src="https://codepen.io/qianlong/embed/ALymLp" frameborder="0" allowfullscreen></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊这些常见而且实用的css技巧]]></title>
      <url>https://qianlongo.github.io/2016/04/19/%E8%81%8A%E4%B8%80%E8%81%8A%E8%BF%99%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%80%8C%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84css%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>生活需要总结，需要不断地发现自己的缺陷然后找到好的方法，改之。古人说好记性不如烂笔头，人终归是会遗忘一些事情的，哪怕它曾经深深地印在你的脑海，久久挥之不去，经过时间的洗涤，一切都会回到最初的那个时刻，还记得你上次写的令自己引以为豪的css样式吗？  😄，也许你记得，但模糊了不是？？？所以还是乖乖地拿起你的电脑，愉快地一点点敲下来，记录一遍吧！ 这篇文章会记录自己时常用到的css片段，使用这些css可以帮助我们解决许多实际问题。</p>
</blockquote>
<p><a href="https://github.com/qianlongo/cssSkills" target="_blank" rel="external">源码地址</a><br><a href="http://sandbox.runjs.cn/show/rrtvorhl" target="_blank" rel="external">预览地址</a></p>
<a id="more"></a>
<h2 id="1、清除浮动"><a href="#1、清除浮动" class="headerlink" title="1、清除浮动"></a>1、清除浮动</h2><blockquote>
<p>浮动给我们的代码带来的麻烦，想必不需要多说，我们会用很多方式来避免这种麻烦，其中我觉得最方便也是兼容性最好的一种是….</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清除浮动</span></div><div class="line">.clearfix&#123;</div><div class="line">  <span class="attr">zoom</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">.clearfix:after&#123;</div><div class="line">  <span class="attr">display</span>: block;</div><div class="line">  content: <span class="string">''</span>;</div><div class="line">  clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、垂直水平居中"><a href="#2、垂直水平居中" class="headerlink" title="2、垂直水平居中"></a>2、垂直水平居中</h2><blockquote>
<p>在css的世界里水平居中比垂直居中来的简单一些，经过了多年的演化，依然没有好的方式来让元素垂直居中(各种方式各有优缺点，但都不能达到兼容性好，破坏力小的目标)，以下是几种常见的实现方式</p>
</blockquote>
<p><code>绝对定位方式且已知宽高</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</div><div class="line"><span class="selector-tag">top</span>: 50%;</div><div class="line"><span class="selector-tag">left</span>: 50%;</div><div class="line"><span class="selector-tag">margin-top</span>: <span class="selector-tag">-3em</span>;</div><div class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-7em</span>;</div><div class="line"><span class="selector-tag">width</span>: 14<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">height</span>: 6<span class="selector-tag">em</span>;</div></pre></td></tr></table></figure>
<p><code>绝对定位 ＋ 未知宽高 ＋ translate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">position: absolute;</div><div class="line">left: 50%;</div><div class="line">top: 50%;</div><div class="line">transform: translate(-50%, -50%);</div><div class="line">//需要补充浏览器前缀</div></pre></td></tr></table></figure>
<p><code>flex 轻松搞定水平垂直居中( 未知宽高)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">display: flex;</div><div class="line">align-items: center;</div><div class="line">justify-content: center;</div></pre></td></tr></table></figure>
<h2 id="3、-文本末尾添加省略号"><a href="#3、-文本末尾添加省略号" class="headerlink" title="3、 文本末尾添加省略号"></a>3、 文本末尾添加省略号</h2><blockquote>
<p>当文本的内容超出容器的宽度的时候，我们希望在其默认添加省略号以达到提示用户内容省略显示的效果。</p>
</blockquote>
<p><code>宽度固定，适合单行显示...</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</div><div class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</div><div class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</div></pre></td></tr></table></figure>
<p><code>宽度不固定，适合多行以及移动端显示</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</div><div class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</div><div class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</div><div class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</div><div class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</div></pre></td></tr></table></figure>
<h2 id="4、制造文本的模糊效果"><a href="#4、制造文本的模糊效果" class="headerlink" title="4、制造文本的模糊效果"></a>4、制造文本的模糊效果</h2><blockquote>
<p>当我们希望给文本制造一种模糊效果感觉的时候，可以这样做</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">text-shadow</span><span class="selector-pseudo">:0</span> 0 2<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.5</span>);</div></pre></td></tr></table></figure>
<h2 id="5、动画实现简洁loading效果"><a href="#5、动画实现简洁loading效果" class="headerlink" title="5、动画实现简洁loading效果"></a>5、动画实现简洁loading效果</h2><blockquote>
<p>我们来实现一个非常简洁的loading效果</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.loading:after&#123;</div><div class="line">  display: inline-block;</div><div class="line">  overflow: hidden;</div><div class="line">  vertical-align: bottom;</div><div class="line">  content: '\2026';</div><div class="line">  -webkit-animation: ellipsis 2s infinite;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 动画部分</div><div class="line">@-webkit-keyframes ellipsis&#123;</div><div class="line">  from&#123;</div><div class="line">    width: 2px;</div><div class="line">  &#125;</div><div class="line">  to&#123;</div><div class="line">    width: 15px;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6、自定义文本选中样式"><a href="#6、自定义文本选中样式" class="headerlink" title="6、自定义文本选中样式"></a>6、自定义文本选中样式</h2><blockquote>
<p>默认情况下，我们在网页上选中文字的时候，会给选中的部分一个深蓝色背景颜色(可以自己拿起鼠标试试)，如果我们想自己定制被选中的部分的样式呢？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意只能修改这两个属性 字体颜色 选中背景颜色</span></div><div class="line"></div><div class="line">element::selection&#123;</div><div class="line">  <span class="attr">color</span>: green;</div><div class="line">  background-color: pink;</div><div class="line">&#125;</div><div class="line">element::-moz-selection&#123;</div><div class="line">  <span class="attr">color</span>: green;</div><div class="line">  background-color: pink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7、顶角贴纸效果"><a href="#7、顶角贴纸效果" class="headerlink" title="7、顶角贴纸效果"></a>7、顶角贴纸效果</h2><blockquote>
<p>有时候我们会有这样的需求，在一个列表展示页面，有一些列表项是新添加的、或者热度比较高的，就会要求在其上面添加一个贴纸效果的小条就像hexo默认博客的fork me on github那个效果一样，如下图。<br><img src="/2016-4/20/1.png" alt="贴纸效果"></p>
</blockquote>
<p><strong>接下来我们开始一步步完成最左边的这个效果</strong></p>
<p><code>html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ribbon"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Fork me on GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>css</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/* 外层容器几本设置  */</div><div class="line">.wrap&#123;</div><div class="line">  width: 160px;</div><div class="line">  height:160px;</div><div class="line">  overflow:hidden;</div><div class="line">  position: relative;</div><div class="line">  background-color: #f3f3f3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.ribbon&#123;</div><div class="line">  background-color: #a00;</div><div class="line">  overflow: hidden;</div><div class="line">  white-space: nowrap;</div><div class="line">  position: absolute;</div><div class="line">  /* shadom */</div><div class="line">  -webkit-box-shadow: 0 0 10px #888;</div><div class="line">  -moz-box-shadow: 0 0 10px #888;</div><div class="line">  box-shadow: 0 0 10px #888;</div><div class="line">  /* rotate */</div><div class="line">  -webkit-transform: rotate(-45deg);</div><div class="line">  -moz-transform: rotate(-45deg);</div><div class="line">  -ms-transform: rotate(-45deg);</div><div class="line">  -o-transform: rotate(-45deg);</div><div class="line">  transform: rotate(-45deg);</div><div class="line">  /* position */</div><div class="line">  left: -50px;</div><div class="line">  top: 40px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.ribbon a&#123;</div><div class="line">  border: 1px solid #faa;</div><div class="line">  color: #fff;</div><div class="line">  display: block;</div><div class="line">  font: bold 81.25% &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;</div><div class="line">  margin: 1px 0;</div><div class="line">  padding: 10px 50px;</div><div class="line">  text-align: center;</div><div class="line">  text-decoration: none;</div><div class="line">  /* shadow */</div><div class="line">  text-shadow: 0 0 5px #444;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8、input占位符"><a href="#8、input占位符" class="headerlink" title="8、input占位符"></a>8、input占位符</h2><blockquote>
<p>当我们给部分input类型的设置placeholder属性的时候，有的时候需要修改其默认的样式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">input::-webkit-input-placeholder&#123;</div><div class="line">  color: green;</div><div class="line">  background-color: #F9F7F7;</div><div class="line">  font-size: 14px;</div><div class="line">&#125;</div><div class="line">input::-moz-input-placeholder&#123;</div><div class="line">  color: green;</div><div class="line">  background-color: #F9F7F7;</div><div class="line">  font-size: 14px;</div><div class="line">&#125;</div><div class="line">input::-ms-input-placeholder&#123;</div><div class="line">  color: green;</div><div class="line">  background-color: #F9F7F7;</div><div class="line">  font-size: 14px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="9、移动端可点击元素去处默认边框"><a href="#9、移动端可点击元素去处默认边框" class="headerlink" title="9、移动端可点击元素去处默认边框"></a>9、移动端可点击元素去处默认边框</h2><blockquote>
<p>在移动端浏览器上，当你点击一个链接或者通过Javascript定义的可点击元素的时候，会出现蓝色边框，说实话，这是很恶心的，怎么去掉呢?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-webkit-tap-highlight-color: rgba(255,255,255,0);</div></pre></td></tr></table></figure>
<h2 id="10、首字下沉"><a href="#10、首字下沉" class="headerlink" title="10、首字下沉"></a>10、首字下沉</h2><blockquote>
<p>要实现类似word中首字下沉的效果可以使用以下代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">element:first-letter&#123;</div><div class="line">  float:left;</div><div class="line">  color:green;</div><div class="line">  font-size:30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="11、小三角"><a href="#11、小三角" class="headerlink" title="11、小三角"></a>11、小三角</h2><blockquote>
<p>在很多地方我们可以用得上小三角，接下来我们画一下四个方向的三角形</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">.triangle&#123;</div><div class="line">  /* 基础样式 */</div><div class="line">  border:solid 10px transparent;</div><div class="line">&#125;</div><div class="line">/*下*/</div><div class="line">.triangle.bottom&#123;</div><div class="line"> border-top-color: green;</div><div class="line">&#125;</div><div class="line">/*上*/</div><div class="line">.triangle.top&#123;</div><div class="line"> border-bottom-color: green;</div><div class="line">&#125;</div><div class="line">/*左*/</div><div class="line">.triangle.top&#123;</div><div class="line"> border-right-color: green;</div><div class="line">&#125;</div><div class="line">/*右*/</div><div class="line">.triangle.top&#123;</div><div class="line"> border-left-color: green;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>可以看出画一个小三角非常简单，只要两行样式就可以搞定，对于方向只要想着画哪个方向则设置反方向的样式属性就可以</strong></p>
<h2 id="12、鼠标手型"><a href="#12、鼠标手型" class="headerlink" title="12、鼠标手型"></a>12、鼠标手型</h2><blockquote>
<p>一般情况下，我们希望在以下元素身上添加鼠标手型</p>
</blockquote>
<ul>
<li>a</li>
<li>submit</li>
<li>input[type=”iamge”]</li>
<li>input[type=”button”]</li>
<li>button</li>
<li>label</li>
<li>select</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[href],input[type=&apos;submit&apos;], input[type=&apos;image&apos;],input[type=&apos;button&apos;], label[for], select, button &#123;</div><div class="line">  cursor: pointer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="13、屏蔽Webkit移动浏览器中元素高亮效果"><a href="#13、屏蔽Webkit移动浏览器中元素高亮效果" class="headerlink" title="13、屏蔽Webkit移动浏览器中元素高亮效果"></a>13、屏蔽Webkit移动浏览器中元素高亮效果</h2><blockquote>
<p>在访问移动网站时，你会发现，在选中的元素周围会出现一些灰色的框框，使用以下代码屏蔽这种样式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-webkit-touch-callout: none;</div><div class="line">-webkit-user-select: none;</div><div class="line">-khtml-user-select: none;</div><div class="line">-moz-user-select: none;</div><div class="line">-ms-user-select: none;</div><div class="line">user-select: none;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[玩转jade]]></title>
      <url>https://qianlongo.github.io/2016/04/16/jade%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>接触过一些不同种类的前端模版引擎 <code>Mustache</code> <code>ejs</code> <code>mustache</code> <code>coffeecup</code>…,大体上这些引擎都有相似的语法和功能，本质上都是通过弥补html与生俱来的缺陷，比如在模版种使用变量，循环，条件判断等加快应用的开发，本文要介绍的<code>jade</code>与上述模版引擎有些许不同，他是采用缩进的形式来组织html的。</p>
</blockquote>
<a id="more"></a>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote>
<p>这篇文章默认你已经知道用”-“开头可以声明js变量与使用js语句,使用#{name}获取name变量的值, 文本在标签后空一个空格。</p>
</blockquote>
<h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h2><blockquote>
<p>jade中默认一行中的第一个单词就是标签名称，如果不写标签名则默认创建一个div</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.tag#tag</div><div class="line">  ul.list</div><div class="line">    li item1</div><div class="line">    li item2</div><div class="line">    li item3</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;wrap&quot; class=&quot;wrap&quot;&gt;</div><div class="line">  &lt;ul class=&quot;list&quot;&gt;</div><div class="line">    &lt;li&gt;item1&lt;/li&gt;</div><div class="line">    &lt;li&gt;item2&lt;/li&gt;</div><div class="line">    &lt;li&gt;item3&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h2><blockquote>
<p>一般我们需要在标签上面挂载一些属性，jade中标签的属性放在()中，多个属性之间使用<strong>,</strong>逗号隔开</p>
</blockquote>
<h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a(href=&quot;google.com&quot;) google.com</div><div class="line">a(class=&quot;button&quot;, href=&quot;google.com&quot;) google.com</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;google.com&quot;&gt;google.com&lt;/a&gt;</div><div class="line">&lt;a href=&quot;google.com&quot; class=&quot;button&quot;&gt;google.com&lt;/a&gt;</div></pre></td></tr></table></figure>
<h3 id="2-2-模版中夹杂js语句"><a href="#2-2-模版中夹杂js语句" class="headerlink" title="2.2 模版中夹杂js语句"></a>2.2 模版中夹杂js语句</h3><blockquote>
<p>当然了绝大多的js语句是可以模版中运行的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- var test = true; // 这里的test只要 弱为真即可( 注意前面的-符号 )</div><div class="line">a(href=test ? &apos;google.com&apos;: &apos;baidu.com&apos;) js语句</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;google.com&quot;&gt;js语句&lt;/a&gt;</div></pre></td></tr></table></figure>
<h3 id="2-2-多个属性"><a href="#2-2-多个属性" class="headerlink" title="2.2 多个属性"></a>2.2 多个属性</h3><blockquote>
<p>想象一下，当你要给标签上面挂载多个属性的时候，全部写在一行必然不是什么好玩的事情，于是我们可以像下面这样写</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">input(</div><div class="line">  type=&quot;checkbox&quot;,</div><div class="line">  name= &quot;qianlong&quot;,</div><div class="line">  checked </div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;checkbox&quot; name=&quot;qianlong&quot; checked /&gt;</div></pre></td></tr></table></figure>
<h3 id="2-3-boolean类型属性"><a href="#2-3-boolean类型属性" class="headerlink" title="2.3 boolean类型属性"></a>2.3 boolean类型属性</h3><p>&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input(type=&quot;checkbox&quot;, checked )</div><div class="line">input(type=&quot;checkbox&quot;, checked=true )</div><div class="line">input(type=&quot;checkbox&quot;, checked=false )</div><div class="line">input(type=&quot;checkbox&quot;, checked=true &amp;&amp; &apos;checked&apos; )</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;checkbox&quot; checked&gt;</div><div class="line">&lt;input type=&quot;checkbox&quot; checked&gt;</div><div class="line">&lt;input type=&quot;checkbox&quot;&gt;</div><div class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;</div></pre></td></tr></table></figure>
<h3 id="2-4-style-书写行间样式"><a href="#2-4-style-书写行间样式" class="headerlink" title="2.4 style 书写行间样式"></a>2.4 style 书写行间样式</h3><blockquote>
<p>当我们要在行间给一个元素单独的设置一段样式的时候，应该怎么做呢？直接给style属性赋值一段js对象即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- styles = &#123;color: &apos;red&apos;, background: &apos;green&apos;&#125; </div><div class="line">a(href=&quot;google.com&quot;, style=styles) google.com</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;google.com&quot; style=&quot;color:red;background:green&quot;&gt;google.com&lt;/a&gt;</div></pre></td></tr></table></figure>
<h3 id="2-5-单独添加class属性"><a href="#2-5-单独添加class属性" class="headerlink" title="2.5 单独添加class属性"></a>2.5 单独添加class属性</h3><blockquote>
<p>前面在tag章节我们讲过可以通过.className的形式添加class，这里我们也可以把类当成是某个属性来书写，并且可以把一个数组直接赋值给class属性，亦可以是个对象类型的条件判断赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- var classes = [&apos;qianlong&apos;, &apos;tianxiang&apos;, &apos;doubi&apos;];</div><div class="line">- var objTest = false;</div><div class="line"></div><div class="line">a(class=classes, href=&quot;google.com&quot;) google.com</div><div class="line">// 这里结合.className的形式</div><div class="line">a.firstName.qianlong(class=classes, class=&quot;firstName&quot;, href=&quot;google.com&quot;) google.com</div><div class="line">// 对象形式</div><div class="line">a(class=&#123;&apos;active&apos;: objTest&#125;, href=&quot;google.com&quot;) google.com</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;google.com&quot; class=&quot;qianlong tianxiang doubi&quot;&gt;google.com&lt;/a&gt;</div><div class="line">&lt;a href=&quot;google.com&quot; class=&quot;firstName qianlong qianlong tianxiang doubi firstName&quot;&gt;google.com&lt;/a&gt;</div><div class="line">&lt;a href=&quot;google.com&quot; class=&quot;active&quot;&gt;google.com&lt;/a&gt;</div></pre></td></tr></table></figure>
<p><strong>1. 可以看出当我们同时使用.className和属性书写的形式并且两者有相同的类名的时候，jade并不会非常智能地给我们只留下一下一个类，而是重复相同的类名多次</strong></p>
<p><strong>2. 我们可以利用使用对象类型添加class的方式来给不同的元素添加不同的类</strong></p>
<h2 id="3-循环each-amp-amp-条件判断-if"><a href="#3-循环each-amp-amp-条件判断-if" class="headerlink" title="3. 循环each &amp;&amp; 条件判断 if"></a>3. 循环each &amp;&amp; 条件判断 if</h2><blockquote>
<p>在模版引擎中除了使用变量动态的获取我们需要的数据，很多时候我们做的事是根据数据<strong>循环</strong>生成dom元素以及根据<strong>条件判断</strong>来涮选数据，很幸运jade给我们提供了这样的机制</p>
</blockquote>
<h2 id="3-1-each-for"><a href="#3-1-each-for" class="headerlink" title="3.1 each || for"></a>3.1 each || for</h2><blockquote>
<p>我们可以通过each和js中的for语句来根据数据循环生成dom结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- var list = [&apos;qianlong&apos;, &apos;tianxiang&apos;, &apos;doubi&apos;];</div><div class="line"></div><div class="line">ul.list1</div><div class="line">  each val, index in list</div><div class="line">    li 值是:#&#123;val&#125; 索引是: #&#123;index&#125;  </div><div class="line">ul.list2</div><div class="line">  - for(var i = 0, len = list.length; i &lt; len; i++)</div><div class="line">    li 值是:#&#123;list[i]&#125; 索引是: #&#123;i&#125;</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;ul class=&quot;list1&quot;&gt;</div><div class="line">  &lt;li&gt;值是:qianlong 索引是: 0  &lt;/li&gt;</div><div class="line">  &lt;li&gt;值是:tianxiang 索引是: 1  &lt;/li&gt;</div><div class="line">  &lt;li&gt;值是:doubi 索引是: 2  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;ul class=&quot;list2&quot;&gt;</div><div class="line">  &lt;li&gt;值是:qianlong 索引是: 0  &lt;/li&gt;</div><div class="line">  &lt;li&gt;值是:tianxiang 索引是: 1  &lt;/li&gt;</div><div class="line">  &lt;li&gt;值是:doubi 索引是: 2  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p><strong>可见两种方式都可以达到相同的遍历效果，但是后者代码量较大稍显繁琐，推荐使用第一种方式</strong></p>
<h2 id="3-2-if"><a href="#3-2-if" class="headerlink" title="3.2 if"></a>3.2 if</h2><blockquote>
<p>通过if关键字来进行条件判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- var ifTest = 0;</div><div class="line">  if ifTest &gt; 10</div><div class="line">    p ifTest 大于10    </div><div class="line">  else if ifTest == 10</div><div class="line">    p ifTest 等于10</div><div class="line">  else</div><div class="line">    p ifTest 小于10</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;ifTest 小于10   &lt;/p&gt;</div></pre></td></tr></table></figure>
<h2 id="4-case-vs-switch"><a href="#4-case-vs-switch" class="headerlink" title="4. case vs switch"></a>4. case vs switch</h2><blockquote>
<p>在jade模版里面我们通过case、when和default关键字可以实现类似于编程语句中switch的效果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- var friends = 10;</div><div class="line">case friends</div><div class="line">  when 0</div><div class="line">    p you have no friends</div><div class="line">  when 1</div><div class="line">    p you have a friends</div><div class="line">  default</div><div class="line">    p you have #&#123;friends&#125; friends</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;you have 10 friends&lt;/p&gt;</div></pre></td></tr></table></figure>
<p><strong>可见当when中没有与之相匹配的项时，会走默认的default,接下来我们来看一下这几种情形</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- var friends = 0;</div><div class="line">case friends</div><div class="line">  when 0</div><div class="line">  when 1</div><div class="line">    p you have a friends</div><div class="line">  default</div><div class="line">    p you have #&#123;friends&#125; friends</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;you have a friends&lt;/p&gt;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- var friends = 1;</div><div class="line">case friends</div><div class="line">  when 0</div><div class="line">    p you have no friends</div><div class="line">  when 1</div><div class="line">    p you have a friends</div><div class="line">  default</div><div class="line">    p you have #&#123;friends&#125; friends</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;you have a friends&lt;/p&gt;</div></pre></td></tr></table></figure>
<h2 id="5-extends"><a href="#5-extends" class="headerlink" title="5. extends"></a>5. extends</h2><blockquote>
<p>在构建应用的过程中，我们可能需要扩展自己，以弥补自己的不足。这时候便可以能用到<strong>extends</strong></p>
</blockquote>
<p><code>layout.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doctype html</div><div class="line">html</div><div class="line">  head</div><div class="line">    block title</div><div class="line">  body</div><div class="line">    block content</div></pre></td></tr></table></figure>
<p><code>main.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extends ./layout.jade</div><div class="line"></div><div class="line">block title</div><div class="line">  title 我是main title</div><div class="line">block content</div><div class="line">  .content 我是main中的content部分</div></pre></td></tr></table></figure>
<p>最终main.jade编译后dom结构是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;我是main title&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div class=&quot;content&quot;&gt;我是main中的content部分  &lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>这里就好像是在layout.jade中先埋好title和content这两个坑，然后在main.jade中把这两个坑给填上了，并且也继承了layout.jade的dom结构</strong></p>
<h2 id="6-include"><a href="#6-include" class="headerlink" title="6. include"></a>6. include</h2><blockquote>
<p>一张网页的很多模块是公用的比如头部和尾部，我们可以将这些可以复用的部分作为单独的模块，然后被他页面的嵌入，在jade要实现这种效果用的是include关键字</p>
</blockquote>
<p><code>head.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">head</div><div class="line">  title 我是head部分</div><div class="line">  link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;../styles/index.css&quot;)</div></pre></td></tr></table></figure>
<p><code>footer.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#footer 我是footer部分</div></pre></td></tr></table></figure>
<p><code>index.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doctype html</div><div class="line">html</div><div class="line">  include ./header.jade</div><div class="line">  body</div><div class="line">  #main 我是主题部分</div><div class="line">  include ./footer.jade</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">  &lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;title&gt;我是head部分&lt;/title&gt;</div><div class="line">      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../styles/index.css&quot;&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;div id=&quot;main&quot;&gt;我是主题部分&lt;/div&gt;</div><div class="line">      &lt;div id=&quot;footer&quot;&gt;我是footer部分&lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">  &lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>怎么样，是不是有当前使用jsp include的那种感觉，别着急include的强大之处并不仅仅是引进<code>.jade</code>类型的文件，他还可以引进类似<code>.css``.js</code>等的文件</strong></p>
<p><code>index.css</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">  background-color: green;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>index.jade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">doctype html</div><div class="line">html</div><div class="line">  head</div><div class="line">    title include test</div><div class="line">    style</div><div class="line">      include ../public/styles/index.css</div><div class="line">  body</div><div class="line">    #main 我是主题部分</div></pre></td></tr></table></figure>
<p><strong>编译后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;include test&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">      body&#123;</div><div class="line">        background-color: green;</div><div class="line">      &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&quot;main&quot;&gt;我是主题部分&lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>jade还有其他相关的语法，日常工作中需要我们常用的结合上述所说灵活使用</p>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://jade-lang.com/" target="_blank" rel="external">jade官网</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化之DOM篇章]]></title>
      <url>https://qianlongo.github.io/2016/04/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BDOM%E7%AF%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前端经常需要和DOM打交道，增加、删除、替换是常见的DOM操作，然而就是这些操作时常成为网站性能的瓶颈，为了提高我们的网站性能，我们需要在DOM上面花不少心思。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-使用DOM的引用"><a href="#1-使用DOM的引用" class="headerlink" title="1.  使用DOM的引用"></a>1.  使用DOM的引用</h2><blockquote>
<p>在进行DOM操作前，我们先要对元素进行查找，或者需要根据后台返回的数据动态的创建元素，比如我们得到一个数组类型的数据data，需求是根据data往一个id为main的元素中添加li。我们可能会进行下面的DOM操作</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++ )&#123;</div><div class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">  li.innerText = data[i];</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>).appendChild(li);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>上面的代码每次循环都会去计算一个data的length值，查询并得到main元素，可想而之其效率应该有多低下，好的方式是在进行循环之前便将data的length以及main元素缓存下来，在循环的时候使用其引用即可。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oMain = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</div><div class="line"><span class="keyword">var</span> len = data.length;</div><div class="line"><span class="keyword">var</span> i,li;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++ )&#123;</div><div class="line">  li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">  li.innerText = data[i];</div><div class="line">  oMain.appendChild(li);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意元素的查找默认根元素是document，当我们需要对某些元素进行频繁的查找的时候，可以先将某个元素缓存下来，后面的元素查找则是基于该元素，从而减短查找路径</strong></p>
<h2 id="2-使用文档碎片"><a href="#2-使用文档碎片" class="headerlink" title="2.  使用文档碎片"></a>2.  使用文档碎片</h2><blockquote>
<p>上面的操作中还有一个非常耗费性能的地方，<code>oMain.appendChild(li)</code>，每次循环都会进行一次元素添加操作，进而导致浏览器重排，我们知道浏览器的重排和重绘是需要耗费大量的时间进行的，所以提高网页性能的一方面是考虑尽量减少重排和重绘的次数。将频繁的DOM操作先在内存中完成，最后一次性将节点推进页面当中，这里我们会用到一个方法<code>document.createDocumentFragment</code>,重新修改上诉例子如下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oMain = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</div><div class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment </div><div class="line"><span class="keyword">var</span> len = data.length;</div><div class="line"><span class="keyword">var</span> i,li;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++ )&#123;</div><div class="line">  li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">  li.innerText = data[i];</div><div class="line">  frag.appendChild(li); <span class="comment">// 所有的操作在内存中完成，这个时候不会触发重排</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">oMain.appendChild(frag); <span class="comment">// 最后一次性添加到页面中，只出发浏览器一次重排</span></div></pre></td></tr></table></figure>
<h2 id="3-使用innerHTML一次性添加DOM节点"><a href="#3-使用innerHTML一次性添加DOM节点" class="headerlink" title="3. 使用innerHTML一次性添加DOM节点"></a>3. 使用innerHTML一次性添加DOM节点</h2><blockquote>
<p>以上的代码中每次都要通过<code>document.createElement(&#39;li&#39;)</code>创建元素，通过<code>li.innerText = data[i]</code>设置文本信息，蛋疼的很，我们可以尝试着使用innerHTML来一次性添加元素，当然前提是你要先以字符串的形式把元素和数据拼接好</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oMain = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</div><div class="line"><span class="keyword">var</span> sHtml = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> len = data.length;</div><div class="line"><span class="keyword">var</span> i,li;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++ )&#123;</div><div class="line">  sHtml += <span class="string">'&lt;li&gt;'</span>+ data[i] +<span class="string">'&lt;/li&gt;'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">oMain.innerHTMl = sHtml; <span class="comment">// 最后一次性添加到页面中，只出发浏览器一次重排</span></div></pre></td></tr></table></figure>
<p><strong>虽然这样做效率有所提升，但是当页面的DOM结构一旦复杂起来，拼接字符串便会变成一件相当恶心的事情</strong></p>
<h2 id="4-使用事件代理批量处理事件"><a href="#4-使用事件代理批量处理事件" class="headerlink" title="4. 使用事件代理批量处理事件"></a>4. 使用事件代理批量处理事件</h2><blockquote>
<p>事件代理本质上就是将原本自己该干的事情，委托给别人( 这里是指父节点或者祖先节点 )做。<br><strong>还是用上面的例子，假设我们现在要给每个li都添加上一个点击事件，可能会写出下面的代码</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oMain = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</div><div class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment </div><div class="line"><span class="keyword">var</span> len = data.length;</div><div class="line"><span class="keyword">var</span> i,li;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++ )&#123;</div><div class="line">  li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">  li.innerText = data[i];</div><div class="line">  li.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">  &#125;,<span class="literal">false</span>)</div><div class="line">  frag.appendChild(li); </div><div class="line">&#125;</div><div class="line"></div><div class="line">oMain.appendChild(frag);</div></pre></td></tr></table></figure>
<p><strong>很显然data的lenth有多大，循环就得执行多少次addEventListener这个函数多少次，当数据量很大的时候效率自然低了不少，所以我们可以尝试使用事件代理的形式将事件委托到main元素上</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oMain = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</div><div class="line"><span class="keyword">var</span> sHtml = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> len = data.length;</div><div class="line"><span class="keyword">var</span> i,li,target;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++ )&#123;</div><div class="line">  sHtml += <span class="string">'&lt;li&gt;'</span>+ data[i] +<span class="string">'&lt;/li&gt;'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">oMain.innerHTMl = sHtml; <span class="comment">// 最后一次性添加到页面中，只出发浏览器一次重排</span></div><div class="line">oMain.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</div><div class="line">  target = ev.target || ev.srcElement;</div><div class="line">  <span class="keyword">if</span>(target.tagName.toLowerCase() == <span class="string">'li'</span>)&#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">  &#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<h2 id="5-通过className来批量修改元素样式"><a href="#5-通过className来批量修改元素样式" class="headerlink" title="5. 通过className来批量修改元素样式"></a>5. 通过className来批量修改元素样式</h2><blockquote>
<p>经常有这样的场景，我们需要在js中批量的修改元素的样式，比如</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ele.style.width = <span class="number">100</span> + <span class="string">'px'</span>;</div><div class="line">ele.style.height = <span class="number">100</span> + <span class="string">'px'</span>;</div><div class="line">ele.style.backgrounfColor = <span class="string">'red'</span>;</div><div class="line">ele.style.border = <span class="string">'solid 1px green'</span>;</div></pre></td></tr></table></figure>
<p><strong>以上代码会多次出发浏览器重绘和重排，一种好的方式是将需要修改的样式在样式文件中先写好，通过给元素赋值className的形式批量修改样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.active&#123;</div><div class="line">  <span class="attr">width</span>: <span class="number">100</span>px;</div><div class="line">  height: <span class="number">100</span>px;</div><div class="line">  backgroung-color: red;</div><div class="line">  border: solid <span class="number">1</span>px green;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>给元素赋值className</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ele.className += <span class="string">' active'</span>; <span class="comment">// 注意前面的空格</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dragToSort记一次排序组件开发]]></title>
      <url>https://qianlongo.github.io/2016/04/03/dragToSort%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>有这么一种人，很多地方都会需要他，有这么一种人他一辈子只做一件事，并且做的足够好，在任何地方都能落地生根，服务大众。比如说保洁阿姨，也就是说这里<strong>被需求</strong>的它是大众化的，可被抽象化的，如果我们用程序中的专有名词来形容可以为<strong>组件</strong>,组件的存在就是干<strong>一件事</strong>，有自己存在的目标( <strong>意义</strong> ),有自己的<strong>行为</strong>，自己的<strong>动作</strong>,甚至这里的组件是可以被调用者配置的，就好像保洁阿姨是可以被公司分配到不同的工作地点，薪资也是可配置的。这篇文章就是讲如何将一个组件从0到1的过程( 注意暂时这个组件不会涉及到<strong>配置部分</strong> )</p>
</blockquote>
<a id="more"></a>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><a href="https://github.com/qianlongo/components/tree/master/DragToSort" target="_blank" rel="external">源码地址</a></p>
<p><a href="http://sandbox.runjs.cn/show/yzi77cjc" target="_blank" rel="external">提前感受1</a><br><a href="http://sandbox.runjs.cn/show/yjqcgiun" target="_blank" rel="external">提前感受2</a></p>
<p>你可以点击上面的两个链接提前感受一下这个插件可能要完成的功能，以及点击源码地址查看源代码。其实非常的平常，他要做的事就是允许用户通过鼠标拖拽来改变页面上某些<strong>元素的位置</strong>，从而完成类似排序的功能</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>先引入dragToSort.js文件</p>
<ol>
<li>每个组件都有自己的html结构，所以需要遵循以下的html结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;dragWrap&quot; class=&quot;clear&quot;&gt;</div><div class="line">  &lt;!--将要拖拽的元素放到#dragWrap中  作为他的子元素--&gt;</div><div class="line">  ...</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<ol>
<li>调用 以下两句代码既可以完成以上所诉需求</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dragTS = new DragToSort();</div><div class="line">    dragTS.init();</div></pre></td></tr></table></figure>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><blockquote>
<p>插件以面向对象的形式完成，构造函数内部有一些原型上需要用到的一些数据，挂在到原型上面的方法完成插件的主要功能。</p>
</blockquote>
<p><strong>构造函数</strong></p>
<blockquote>
<p>构造函数 主要存储插件方法中需要用到的数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function DragToSort() &#123;</div><div class="line">  var parent = document.getElementById(&apos;dragWrap&apos;);</div><div class="line">  this.eles = [].slice.call(parent.children);</div><div class="line">  this.elesPos = this.getPos();</div><div class="line">  this.iZIndex = 2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>原型</strong><br>&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">DragToSort.prototype = &#123;</div><div class="line">  constructor: DragToSort, // 重新指向DragToSort</div><div class="line">  init: function  () &#123;</div><div class="line">   //初始化</div><div class="line">  &#125;,</div><div class="line">  getPos: function  () &#123;</div><div class="line">    // 得到需要拖拉排序的位置信息</div><div class="line">  &#125;,</div><div class="line">  css: function  () &#123;</div><div class="line">   // 简易的样式操作函数</div><div class="line">  &#125;,</div><div class="line">  getStyle: function () &#123;</div><div class="line">   // 获取元素的行间样式 封装</div><div class="line">  &#125;,</div><div class="line">  startMove: function ()&#123;</div><div class="line">   // 动画函数封装 用来给拖拽添加动画效果</div><div class="line">  &#125;,</div><div class="line">  setPos: function  () &#123;</div><div class="line">   // 定位转换函数 因初始情况下元素是浮动布局，但是这里的插件要完成的功能需要元素定位( 绝对定位 )</div><div class="line">  &#125;,</div><div class="line">  crash: function  () &#123;</div><div class="line">    // 检查两个物体是否发生碰撞</div><div class="line">  &#125;,</div><div class="line">  distance : function  () &#123;</div><div class="line">   // 计算两个物体之间的距离</div><div class="line">  &#125;,</div><div class="line">  nearObj : function  () &#123;</div><div class="line">   // 寻找与当前拖拽元素相碰正的元素中最近的元素</div><div class="line">  &#125;,</div><div class="line">  drag : function  () &#123;</div><div class="line">   //  拖拽函数封装</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>接下来开始详细解释各段代码</strong></p>
<p><strong>getPos</strong></p>
<blockquote>
<p>通过对需要拖拽的元素，进行遍历，用数组将其位置信息存储起来，并给每个元素设置一个初始的索引值(为什么要用到索引值，后面会说到)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function ()&#123;</div><div class="line">  var pos = [];</div><div class="line">  this.eles.forEach( function  (item ,index) &#123;</div><div class="line">    pos.push(&#123;</div><div class="line">      left : item.offsetLeft,</div><div class="line">      top : item.offsetTop</div><div class="line">    &#125;)</div><div class="line">    item.index = index;</div><div class="line">  &#125;)</div><div class="line">  return pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<blockquote>
<p>设置元素样式的的简易函数封装,接受一个元素对象，和设置css样式的对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function  (objEle, obj) &#123;</div><div class="line">  for(var attr in obj)&#123;</div><div class="line">    objEle[&apos;style&apos;][attr] = obj[attr];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>getStyle</strong></p>
<blockquote>
<p>获取元素样式兼容函数封装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function (obj, attr) &#123;</div><div class="line">  if (obj.currentStyle) &#123;</div><div class="line">   return obj.currentStyle[attr]; // chrome ie ...</div><div class="line">  &#125;else&#123;</div><div class="line">   return getComputedStyle(obj, false)[attr]; // firefox ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>startMove</strong></p>
<blockquote>
<p>动画函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function (obj, json, fnEnd)&#123;</div><div class="line">  var _this = this;</div><div class="line">  clearInterval(obj.timer);</div><div class="line">  obj.timer=setInterval(function ()&#123;</div><div class="line">    var bStop=true;</div><div class="line">    for(var attr in json)&#123;</div><div class="line">       var cur=0;</div><div class="line">       if(attr==&apos;opacity&apos;)&#123;</div><div class="line">          cur=Math.round(parseFloat(_this.getStyle(obj, attr))*100);</div><div class="line">       &#125;else&#123;</div><div class="line">          cur=parseInt(_this.getStyle(obj, attr));</div><div class="line">       &#125;</div><div class="line">       var speed=(json[attr]-cur)/6;</div><div class="line">       speed=speed&gt;0?Math.ceil(speed):Math.floor(speed);</div><div class="line"></div><div class="line">       if(cur!=json[attr])&#123;</div><div class="line">          bStop=false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if(attr==&apos;opacity&apos;)&#123;</div><div class="line">          obj.style.filter=&apos;alpha(opacity:&apos;+(cur+speed)+&apos;)&apos;;</div><div class="line">          obj.style.opacity=(cur+speed)/100;</div><div class="line">        &#125;else&#123;</div><div class="line">          obj.style[attr]=cur+speed+&apos;px&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(bStop)&#123;</div><div class="line">        clearInterval(obj.timer);</div><div class="line">        if(fnEnd)fnEnd();</div><div class="line">    &#125;</div><div class="line">  &#125;, 30);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>setPos</strong></p>
<blockquote>
<p>将浮动布局转化为定位布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function  () &#123;</div><div class="line">  //定位转换 absolute</div><div class="line">  var _this = this;</div><div class="line">  _this.eles.forEach( function  (item,index) &#123;</div><div class="line">    _this.css(item,&#123;</div><div class="line">      position : &apos;absolute&apos;,</div><div class="line">      left : _this.elesPos[index][&apos;left&apos;] + &apos;px&apos;,</div><div class="line">      top :  _this.elesPos[index][&apos;top&apos;] + &apos;px&apos;,</div><div class="line">      margin : 0</div><div class="line">    &#125;);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>crash</strong></p>
<blockquote>
<p>检查两个物体是否发生碰撞，要检查两个物体是否发生碰撞，值需要检查它们的位置关系就可以，也就是两物体没有重叠区域。如图，另一个物体处于红色圆圈位置便不会发生碰撞，反之</p>
</blockquote>
<p><img src="/2016-4/3/6.png" alt="困"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function  (obj, obj2) &#123;</div><div class="line">  //检查两个物体是否发生碰撞</div><div class="line">  // obj1</div><div class="line">  var t1 = obj.offsetTop;</div><div class="line">  var l1 = obj.offsetLeft;</div><div class="line">  var b1 = obj.offsetHeight + t1;</div><div class="line">  var r1 = obj.offsetWidth + l1;</div><div class="line">  // obj2</div><div class="line">  var t2 = obj2.offsetTop;</div><div class="line">  var l2 = obj2.offsetLeft;</div><div class="line">  var b2 = obj2.offsetHeight + t2;</div><div class="line">  var r2 = obj2.offsetWidth + l2;</div><div class="line">  //检查</div><div class="line">  if( r1&lt;l2 || r2&lt;l1 || b1&lt;t2 || b2&lt;t1 )&#123;</div><div class="line">    return false;//未碰撞</div><div class="line">  &#125;else&#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识js面向对象]]></title>
      <url>https://qianlongo.github.io/2016/04/03/%E5%88%9D%E8%AF%86js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><strong>基于类的对象：</strong>我们都知道面向对象的语言中有一个明显的标志，就是都有类的概念，通过类这个类似模板的东西我们可以创建许多个具有相同的属性和方法的对象。然而在ECMAScript中并没有类的概念，自然它与基于类的语言中的对象也会有所不同。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p><strong>js中的对象：**</strong>无序**的属性的集合，属性可以包含基本值、对象、函数。即js中的对象是一组没有特定顺序的值，对象的每个属性或者方法都有一个自己的名字，而每个名字都与一个值相对应。</p>
</blockquote>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><blockquote>
<p>1 创建一个对象的最简单的方式是创建一个Object实例,之后为其添加属性和方法。</p>
</blockquote>
<p><strong>例如</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">    person.name = &apos;谦龙&apos;;</div><div class="line">    person.sex = &apos;男&apos;;</div><div class="line">    person.sayNameAndSex = function()&#123;</div><div class="line">        console.log(this.name, this.sex);</div><div class="line">    &#125;</div><div class="line">    person.sayNameAndSex(); // 谦龙 男</div></pre></td></tr></table></figure>
<blockquote>
<p>2  使用对象字面量形式</p>
</blockquote>
<p><strong>例如</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name:&apos;谦龙&apos;,</div><div class="line">    sex:&apos;男&apos;,</div><div class="line">    sayNameAndSex:function()&#123;</div><div class="line">        console.log(this.name, this.sex)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> person.sayNameAndSex(); // 谦龙 男</div></pre></td></tr></table></figure>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><blockquote>
<p>ECMAScript有两种数据属性：数据属性和访问器属性。</p>
</blockquote>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><blockquote>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。共有四个描述其行为的特性。</p>
</blockquote>
<p> 1.[[Configurable]]:表示能否通过delete删除属性从而重新定义属性…默认值为true<br> 2.[[Enumerable]]:表示能否通过for in 循环返回属性…默认为true<br> 3.[[Writable]]:表示能否修改属性的值…默认为true<br> 4.[[Value]]:表示这个属性的值.默认为undefined</p>
<p><strong>要修改属性默认的特性，必须使用ES5的Object.defineProperty()方法，而该方法接收三个参数：属性所在的对象、属性的名称、还有一个描述属性特性的对象(configurable、enumerable、writable、value)，设置其中的一个或者多个值可以修改对应的特性</strong></p>
<p><strong>DEMO</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &apos;name&apos;,&#123;</div><div class="line">    configurable:false,//表示不允许通过delete删除属性</div><div class="line">    writable:false,//表示不允许重写</div><div class="line">    ennumerable:false,//表示不允许通过for in遍历</div><div class="line">    value:&apos;谦龙&apos;//设置该对象中属性的值</div><div class="line">&#125;)</div><div class="line">person.name = &apos;谦龙2&apos;;//尝试重新设置  结果不生效</div><div class="line">delete  person.name;//尝试删除  结果不生效</div><div class="line"></div><div class="line">for(var attr in person)&#123;</div><div class="line">    console.log(person[attr]);// false</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(person.name);//谦龙</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>将<strong>configurable</strong>设置为false后 不允许再次修改为true，另外在调用Object.defineProperty()方法的时候，configurable、ennumerable、writable默认值为false。</p>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><blockquote>
<p>访问器属性不包含数据值，它们包含一对getter、setter函数(但是这两个函数并不是必须的)在读取访问器属性的时候，会调用getter函数，这个函数是负责返回有效的值，在写入访问器属性的时候会调用setter函数并传入新值，这个函数负责如何处理数据。</p>
</blockquote>
<p><strong>访问器属性具有如下的特性</strong></p>
<ol>
<li>[[configurable]] 表示能否通过delete来删除属性从而定义新的属性</li>
<li>[[enumerable]] 表示能否通过for in循环来遍历返回属性</li>
<li>[[get]] 在读取属性时候调用的函数，默认为undefined</li>
<li>[[set]] 在写入函数的时候调用的函数，默认的值为undefined</li>
</ol>
<p><strong>注意：</strong>访问器属性不能直接定义，必须通过Object.defineProterty()定义<br><strong>DEMO</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var book=&#123;</div><div class="line">  _year:2015, //这里的下划线是常见的记号，表示只能通过对象的方法才能访问的属性</div><div class="line">  edition:1</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.defineProperty(book, &apos;year&apos;,&#123;</div><div class="line">    get:function()&#123;</div><div class="line">        return this._year; //即默认通过 book.year获取值的时候 返回的是 boot._year的值</div><div class="line">    &#125;,</div><div class="line">    set: function (value) &#123;//在对 boot.year设置值的时候 默认调用的方法 对数据进行处理</div><div class="line">        var _year = this._year;</div><div class="line">        if(value &gt; _year)&#123;</div><div class="line">            this._year = value;</div><div class="line">            this.edition += value - _year;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">book.year = 2016;</div><div class="line">console.log(book.year,book.edition); // 2016  2</div></pre></td></tr></table></figure>
<h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><blockquote>
<p>我们可以通过ES5中的Object.defineProperties()方法来给对象添加多个属性，该方法接受两个<strong>对象</strong>参数,第一个参数是要添加和修改其属性的对象，第二个对象的属性和第一个对象中要添加和修改的属性一一对应。</p>
</blockquote>
<p><strong>DEMO</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var book = &#123;&#125;;</div><div class="line">    Object.defineProperties(book,&#123;</div><div class="line">        _year:&#123;</div><div class="line">            value:2015,</div><div class="line">            writable:true //注意这里设置成true 才可以 &quot;写&quot; 默认是false </div><div class="line">        &#125;,</div><div class="line">        edition:&#123;</div><div class="line">            value:1,</div><div class="line">            writable:true //注意这里设置成true 才可以 &quot;写&quot; 默认是false</div><div class="line">        &#125;,</div><div class="line">        year:&#123;</div><div class="line">            get:function()&#123;</div><div class="line">                return this._year;</div><div class="line">            &#125;,</div><div class="line">            set: function (value) &#123;</div><div class="line">                var _year=this._year;</div><div class="line">                if(value &gt; _year)&#123;</div><div class="line">                    this._year=value;</div><div class="line">                    this.edition+=value-_year;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    book.year = 2016;</div><div class="line">    console.log(book.year,book.edition); // 2016 2</div></pre></td></tr></table></figure>
<h4 id="读取对象属性的特性"><a href="#读取对象属性的特性" class="headerlink" title="读取对象属性的特性"></a>读取对象属性的特性</h4><blockquote>
<p>使用ES5中的Object.getOwnPropertyDescriptor()方法，可以去的给定的属性的描述符。<br>该方法接收两个参数：属性所在的对象和要读取描述符的属性名称。返回的是一个对象，如果是数据属性，则返回的属性有 configurable,enumerable,writable,value.如果是访问器属性则返回的属性有 configurable,enumerable,get,set</p>
</blockquote>
<p><strong>DEMO</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var book=&#123;&#125;;</div><div class="line">Object.defineProperties(book,&#123;</div><div class="line">    _year:&#123;</div><div class="line">        value:2015,</div><div class="line">        writable:true</div><div class="line">    &#125;,</div><div class="line">    edition:&#123;</div><div class="line">        value:1,</div><div class="line">        writable:true</div><div class="line">    &#125;,</div><div class="line">    year:&#123;</div><div class="line">        get:function()&#123;</div><div class="line">            return this._year;</div><div class="line">        &#125;,</div><div class="line">        set: function (value) &#123;</div><div class="line">            var _year = this._year;</div><div class="line">            if(value &gt; _year)&#123;</div><div class="line">                this._year = value;</div><div class="line">                this.edition += value - _year;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//对象遍历函数</div><div class="line">function showAllProperties(obj)&#123;</div><div class="line">    for(var attr in obj)&#123;</div><div class="line">        console.log(attr+&apos;:&apos;+obj[attr]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var descriptor= Object.getOwnPropertyDescriptor(book,&apos;_year&apos;);//数据属性</div><div class="line">var descriptor2= Object.getOwnPropertyDescriptor(book,&apos;year&apos;);//访问器属性</div><div class="line">showAllProperties(descriptor);</div><div class="line">console.log(&apos;============================&apos;);</div><div class="line">showAllProperties(descriptor2);</div></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p><img src="/2016-4/3/5.png" alt="获取属性的特性"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tool.js]]></title>
      <url>https://qianlongo.github.io/2016/04/03/lib-js/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在学习和工作的过程中，我们经常需要一些辅助的东西来帮助我们将一些事情做好，比如写代码你可能需要用到一些判断数据类型的方法、得到某些元素属性的方式等。该篇文章<strong>持续记录</strong>自己在写程序过程中总结和积累的一些工具方法。<a href="https://github.com/qianlongo/tool.js/blob/master/tool.js" title="代码地址" target="_blank" rel="external">代码地址</a></p>
</blockquote>
<a id="more"></a>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><blockquote>
<p>代码的结构大致如下，每产生一个新的工具方法，便会在toll对象下挂载一个函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(function  (win) &#123;</div><div class="line"></div><div class="line">var tool = &#123;&#125;;</div><div class="line"></div><div class="line">// isUndefined 判断一个变量是否已经声明</div><div class="line"></div><div class="line">tool.isUndefined = function  (obj) &#123;</div><div class="line">  return obj === typeof  void 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">win.tool = tool;</div><div class="line"></div><div class="line">&#125;)(window);</div></pre></td></tr></table></figure>
<h2 id="1-isUndefined"><a href="#1-isUndefined" class="headerlink" title="1.  isUndefined()"></a>1.  isUndefined()</h2><blockquote>
<p>判断一个变量是否已经声明或声明但未赋值，返回值是boolean值，true已经声明，false 未声明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tool.isUndefined = function  (obj) &#123;</div><div class="line">  return obj === typeof  void 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong> 测试 </strong><br><img src="/2016-4/3/1.png" alt="isUndefined"></p>
<h2 id="2-random-min-max"><a href="#2-random-min-max" class="headerlink" title="2.  random(min, max)"></a>2.  random(min, max)</h2><blockquote>
<p>得到一个从min ~ max 的整数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">tool.random = function  (min, max) &#123;</div><div class="line">if (min == null &amp;&amp; max == null) &#123;</div><div class="line">  return Math.random();</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (max == null) &#123;</div><div class="line">  max = min;</div><div class="line">  min = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return min + Math.floor(Math.random() * (max - min) + 1);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong> 测试 </strong><br><img src="/2016-4/3/2.png" alt="isUndefined"></p>
<h2 id="3-property-key"><a href="#3-property-key" class="headerlink" title="3. property(key)"></a>3. property(key)</h2><blockquote>
<p> 得到一个获取对象key属性的函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tool.property = function  (key) &#123;</div><div class="line">  return function  (obj) &#123;</div><div class="line">    return obj == null ? &apos;undefined&apos; : obj[key];</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="4-isArray"><a href="#4-isArray" class="headerlink" title="4. isArray"></a>4. isArray</h2><blockquote>
<p>判断一个对象是否是一个数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tool.isArray = Array.isArray || function  (obj) &#123;</div><div class="line">  return  Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong> 测试 </strong></p>
<p><img src="/2016-4/3/3.png" alt="isUndefined"></p>
<h2 id="5-isArrayLike-arr"><a href="#5-isArrayLike-arr" class="headerlink" title="5. isArrayLike(arr)"></a>5. isArrayLike(arr)</h2><blockquote>
<p>判断一个对象是否是类数组，<strong>类数组</strong>是拥有这样一些特征的数据结构，具有类似数组length的属性，可以通过下标 0, 1, 2来访问类数组中的元素，在js中通常我们把他叫做集合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tool.isArrayLike=  function  (arr) &#123;</div><div class="line">var getLength = this.property(&apos;length&apos;);</div><div class="line">var len = getLength(arr);</div><div class="line"></div><div class="line">return !this.isArray(arr) &amp;&amp; typeof len == &apos;number&apos; &amp;&amp; len &gt;= 0 &amp;&amp; length &lt;= Number.MAX_SAFE_INTEGER;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong> 测试 </strong><br><img src="/2016-4/3/4.png" alt="isUndefined"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端神器emmet语法语法gif形式详解]]></title>
      <url>https://qianlongo.github.io/2016/04/02/%E5%89%8D%E7%AB%AF%E7%A5%9E%E5%99%A8emmet%E8%AF%AD%E6%B3%95%E8%AF%AD%E6%B3%95gif%E5%BD%A2%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>工欲善其事，必先利其器，好的神器可以给我们的生活和工作带来事半功倍的效率，这篇文章就是介绍和演示一前端神器  <strong>emmet</strong>,它最大的特点就是用来帮我们前端同学快速书写html。</p>
</blockquote>
<p>要完成下面这段html结构，在原始的刀耕火种时代我们是这样写的……<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;1&lt;/li&gt;</div><div class="line">  &lt;li&gt;2&lt;/li&gt;</div><div class="line">  &lt;li&gt;3&lt;/li&gt;</div><div class="line">  &lt;li&gt;4&lt;/li&gt;</div><div class="line">  &lt;li&gt;5&lt;/li&gt;</div><div class="line">  &lt;li&gt;6&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p><img src="/2016-4/1/1.gif" alt="原始html写法">;</p>
<p><strong> 然而科技是第一生产力，在程序员的世界里，生产力也是必不可少的，为了提高我们的代码产出率，emmet便诞生了，于是同样为了完成上述工作，emmet可以以下面简洁而又高效的方式完成，简直帅呆了，有木有 </strong></p>
<p><img src="/2016-4/1/2.gif" alt="原始html写法">;</p>
<p>看到这里小伙伴是不是开始鸡冻了呢！ 有木有想自己亲自撸一把的冲动呢！！！接下来我们开始看一下emmet的语法吧，至于emmet，该怎么使用，各大编辑器里面插件怎么安装，大家百度google一把就可以知道，开始吧，骚年。</p>
<h2 id="1-基础语法-标签-id-class-tagName"><a href="#1-基础语法-标签-id-class-tagName" class="headerlink" title="1. 基础语法 标签 id class ( tagName # . )"></a>1. 基础语法 标签 id class ( tagName # . )</h2><p><img src="/2016-4/1/3.gif" alt="emmet语法">;</p>
<h2 id="2-后代-兄弟-父级-gt"><a href="#2-后代-兄弟-父级-gt" class="headerlink" title="2. 后代 兄弟 父级 ( &gt; + ^ )"></a>2. 后代 兄弟 父级 ( &gt; + ^ )</h2><p><img src="/2016-4/1/4.gif" alt="emmet语法">;</p>
<h2 id="3-乘号-分组"><a href="#3-乘号-分组" class="headerlink" title="3. 乘号 分组 ( () )"></a>3. 乘号<em> 分组 (</em> () )</h2><p><img src="/2016-4/1/5.gif" alt="emmet语法">;</p>
<h2 id="4-自增-自减"><a href="#4-自增-自减" class="headerlink" title="4. 自增 自减 ( $ $@- )"></a>4. 自增 自减 ( $ $@- )</h2><p><img src="/2016-4/1/6.gif" alt="emmet语法">;</p>
<h2 id="5-自定义属性-key-value"><a href="#5-自定义属性-key-value" class="headerlink" title="5. 自定义属性 ( [key=value] )"></a>5. 自定义属性 ( [key=value] )</h2><p><img src="/2016-4/1/7.gif" alt="emmet语法">;</p>
<h2 id="6-文本"><a href="#6-文本" class="headerlink" title="6. 文本 ( {} )"></a>6. 文本 ( {} )</h2><p><img src="/2016-4/1/8.gif" alt="emmet语法">;</p>
<h2 id="7-隐式标签"><a href="#7-隐式标签" class="headerlink" title="7. 隐式标签"></a>7. 隐式标签</h2><blockquote>
<p>隐式标签指的是例如在一般情况下 ul 的子元素是 li，在使用emmet语法的时候，我们可以直接写<code>ul.list</code> 而不用去指定子元素的标签名 <code>ul&gt;li.list</code></p>
</blockquote>
<p><img src="/2016-4/1/9.gif" alt="emmet语法">;</p>
<h2 id="8-缩写"><a href="#8-缩写" class="headerlink" title="8. 缩写 :"></a>8. 缩写 :</h2><p><img src="/2016-4/1/10.gif" alt="emmet语法">;</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>日常的工作可以将上述的各种方式混合使用，最终让我们的编码从速度和质量上得到较大的提升。 </p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js中多行字符串编辑，你会哪些方式]]></title>
      <url>https://qianlongo.github.io/2016/03/28/js%E4%B8%AD%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%EF%BC%8C%E4%BD%A0%E4%BC%9A%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们会经常遇到这样的场景，需要拼接多行字符串，在字符串中动态插入一些数据以达到业务的需求。但是js中并没有标准的多行编辑的函数，于是聪明的程序员们便脑洞大开，书写出许多有趣的方法。</p>
</blockquote>
<p><img src="/img/2016-03-28-1.png" alt="多行字符串拼接方式"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"links"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://qianlongo.github.io/"</span>&gt;</span>谦龙的博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://aximario.github.io/"</span>&gt;</span>阿希的博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://lingyu.wang/"</span>&gt;</span>天镶的博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong> 对于上图的dom结构如果要在js中拼接，你会用什么组织方式呢？ </strong></p>
<h2 id="1-常规方式"><a href="#1-常规方式" class="headerlink" title="1.  常规方式"></a>1.  常规方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var str = &apos;&lt;div class=&quot;links&quot;&gt;&lt;a href=&quot;http://qianlongo.github.io/&quot;&gt;谦龙的博客&lt;/a&gt;&lt;a href=&quot;http://aximario.github.io/&quot;&gt;阿希的博客&lt;/a&gt;&lt;a href=&quot;http://lingyu.wang/&quot;&gt;天镶的博客&lt;/a&gt;&lt;/div&gt;&apos;</div></pre></td></tr></table></figure>
<p><strong>看到上面那一坨的代码，不知道您的心情是怎样的，反正我是完全没有心情看下去了，可读性太差了，于是乎为了写出可读性强的代码我们开始了下面的征程</strong></p>
<h2 id="2-字符串相加形式"><a href="#2-字符串相加形式" class="headerlink" title="2. 字符串相加形式"></a>2. 字符串相加形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'&lt;div class="links"&gt;'</span> +</div><div class="line">	    <span class="string">'&lt;a href="http://qianlongo.github.io/"&gt;谦龙的博客&lt;/a&gt;'</span> +</div><div class="line">	    <span class="string">'&lt;a href="http://aximario.github.io/"&gt;阿希的博客&lt;/a&gt;'</span> +</div><div class="line">	    <span class="string">'&lt;a href="http://lingyu.wang/"&gt;天镶的博客&lt;/a&gt;'</span> +</div><div class="line">	  <span class="string">'&lt;/div&gt;'</span></div></pre></td></tr></table></figure>
<p><strong>这种也许是我们用的很多的一种方式，简单灵活，可以直观地看出dom结构，但是写出来的代码犹如满天繁星一般，有些头晕目眩</strong></p>
<h2 id="3-反斜杠"><a href="#3-反斜杠" class="headerlink" title="3. 反斜杠"></a>3. 反斜杠</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'&lt;div class="links"&gt;\</span></div><div class="line">  &lt;a href="http://qianlongo.github.io/"&gt;谦龙的博客&lt;/a&gt;\</div><div class="line">  &lt;a href="http://aximario.github.io/"&gt;阿希的博客&lt;/a&gt;\</div><div class="line">  &lt;a href="http://lingyu.wang/"&gt;天镶的博客&lt;/a&gt;\</div><div class="line">&lt;/div&gt;'</div></pre></td></tr></table></figure>
<h2 id="4-数组切割方式"><a href="#4-数组切割方式" class="headerlink" title="4. 数组切割方式"></a>4. 数组切割方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ <span class="string">'&lt;div class="links"&gt;'</span>,<span class="string">'&lt;a href="http://qianlongo.github.io/"&gt;谦龙的博客&lt;/a&gt;'</span>,<span class="string">'&lt;a href="http://aximario.github.io/"&gt;阿希的博客&lt;/a&gt;'</span>,<span class="string">'&lt;a href="http://lingyu.wang/"&gt;天镶的博客&lt;/a&gt;'</span>,<span class="string">'&lt;/div&gt;'</span>].join(<span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
<h2 id="5-es6-方式"><a href="#5-es6-方式" class="headerlink" title="5. es6 方式"></a>5. es6 方式</h2><blockquote>
<p>es6的到来给我们带来许多新的特性，其中有一部分是关于模板字符串的，专门可以用来解决多行编辑的问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">`&lt;div class="links"&gt;</span></div><div class="line">  &lt;a href="http://qianlongo.github.io/"&gt;谦龙的博客&lt;/a&gt;</div><div class="line">  &lt;a href="http://aximario.github.io/"&gt;阿希的博客&lt;/a&gt;</div><div class="line">  &lt;a href="http://lingyu.wang/"&gt;天镶的博客&lt;/a&gt;</div><div class="line">&lt;/div&gt;`</div></pre></td></tr></table></figure>
<p>注意第一个和最后一个” <strong>`</strong> “符号,整段代码干净简洁，太舒服了有木有</p>
<h2 id="6-黑魔法-function-toString"><a href="#6-黑魔法-function-toString" class="headerlink" title="6. 黑魔法 function.toString()"></a>6. 黑魔法 function.toString()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toSting</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> fn.toString().split(<span class="string">'\n'</span>).slice(<span class="number">1</span>,<span class="number">-1</span>).join(<span class="string">'\n'</span>) + <span class="string">'\n'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.innerHTML = toString(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*</span></div><div class="line">	&lt;div class="links"&gt;</div><div class="line">		&lt;a href="http://qianlongo.github.io/"&gt;谦龙的博客&lt;/a&gt;</div><div class="line">		&lt;a href="http://aximario.github.io/"&gt;阿希的博客&lt;/a&gt;</div><div class="line">		&lt;a href="http://lingyu.wang/"&gt;天镶的博客&lt;/a&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">*/&#125;)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>方法会有很多，适合自己的，适合解决实际问题的方法才是最好的方法。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript数组浅析]]></title>
      <url>https://qianlongo.github.io/2016/03/27/javascript%E6%95%B0%E7%BB%84%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Array是js中的引用数据类型，除了Object外，Array几乎是日常开发中最常用的数据类型，这边文章旨在将js相关的api分类汇总，备作学习笔记。</p>
</blockquote>
<h2 id="js中的数组与其他语言的不同之处"><a href="#js中的数组与其他语言的不同之处" class="headerlink" title="js中的数组与其他语言的不同之处"></a>js中的数组与其他语言的不同之处</h2><ol>
<li>可以保存<code>任意的</code>数据类型</li>
<li>数组长度动态调整</li>
</ol>
<a id="more"></a>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><blockquote>
<p>ECMAScript中提供了让数组的行为类似于栈的方法，即可以让数组表现的如同栈的LIFO数据结构一般，方法分别是push，pop</p>
</blockquote>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><blockquote>
<p>用法：该方法接收任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后数组的长度</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var nums = [];</div><div class="line">var len = nums.push(1,2,3);//一次性添加三个元素 返回修改后的数组长度3</div><div class="line">    console.log(nums,&apos;len=&apos; + len);</div><div class="line">    len = nums.push(4);//添加一个元素 返回数组修改后的数组长度4</div><div class="line">    console.log(nums,&apos;len=&apos; + len);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-1.png" alt="push"></p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><blockquote>
<p>用法：该方法删除数组最后一项，<code>减少</code>length的值，并且返回<code>被删除</code>的元素</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var nums = [1,2,3,4];</div><div class="line">    var returnNum = nums.pop();//删除最后一项 并返回</div><div class="line">    console.log(&apos;len=&apos; + nums.length,&apos;returnNum=&apos; + returnNum);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-2.png" alt="pop"></p>
<h3 id="栈常见应用之数制转换"><a href="#栈常见应用之数制转换" class="headerlink" title="栈常见应用之数制转换"></a>栈常见应用之数制转换</h3><p>进行数制之间的相互转换是是编程中经常遇见的问题，我们可以利用数组栈的这个特性来完成这个操作</p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//该函数接收一个整型数字，以及要转化的数制基数</div><div class="line"> function mulBase(num,base)&#123;</div><div class="line">    var numArr = [];</div><div class="line">    do&#123;</div><div class="line">       numArr.push(num%base);//入栈</div><div class="line">       num = Math.floor((num/base))</div><div class="line">    &#125;while(num&gt;0);</div><div class="line">    var converted = &apos;&apos;;</div><div class="line">    while(numArr.length&gt;0)&#123;</div><div class="line">       converted += numArr.pop();//出栈</div><div class="line">    &#125;</div><div class="line">    return converted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-3.png" alt="数值转换"></p>
<p><strong>未完待续zZZ</strong></p>
<h3 id="栈常见运用之回文判断"><a href="#栈常见运用之回文判断" class="headerlink" title="栈常见运用之回文判断"></a>栈常见运用之回文判断</h3><blockquote>
<p><strong>回文</strong>：回文是指这样的一种现象 一个单词、短语、或者数字，<strong>从前往后</strong>写和<strong>从后往前</strong>写都是一样的。例如单词”dad”、”racecar”。</p>
<p><code>code</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function isPalindrome(word)&#123;</div><div class="line">var word = &apos;&apos;+word;</div><div class="line">var wordArr = [];</div><div class="line">    for(var i=0;i&lt;word.length;i++)&#123;</div><div class="line">      wordArr.push(word.charAt(i));//入栈</div><div class="line">    &#125;</div><div class="line">var reWord=&apos;&apos;;</div><div class="line">    while(wordArr.length&gt;0)&#123;</div><div class="line">      reWord += wordArr.pop();//出栈</div><div class="line">    &#125;</div><div class="line">    return reWord == word ? true : false;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="/img/2016-03-27-4.png" alt="回文判断"></p>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><blockquote>
<p>栈数据结构的访问规则是LIFO(后进先出),而队列数据结构的访问规则是FIFO(先进先出),即队列在末端添加项，在前端移除项。实现这一结构的方法是push(末端添加),shift(前端移除),前面已经说过push，接下来主要说shift</p>
</blockquote>
<h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><blockquote>
<p>shift方法能够移除数组的第一项并且返回该项，同时将数组的长度减一</p>
<p><code>code</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var reNum = arr.shift();//1</div><div class="line">    console.log(reNum,arr.length)//1,3</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-5.png" alt="shift"></p>
<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h3><blockquote>
<p>unshift与shift<strong>作用相反</strong>，在数组的前端添加任意个项，并且返回该数组的长度。<br><code>code</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var reLen = arr.unshift(0);//5</div><div class="line">    reLen2 = arr.unshift(-2,-1);//7</div><div class="line">    console.log(&apos;reLen=&apos; + reLen,&apos;reLen2=&apos; + reLen2,&apos;arr=&apos; + arr);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-6.png" alt="unshift"></p>
<h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><blockquote>
<p>数组中存在两个直接用来排序的方法：reverse和sort，其中reverse用来逆反数组，sort则默认按照字母顺序进行排序。</p>
</blockquote>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><blockquote>
<p>reverse 将对原来的数组进行反转，并返回改变后的数组，其会<code>改变原数组的值</code>。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [5,4,3,2,1];</div><div class="line">var reverseArr = arr.reverse();</div><div class="line">    console.log(&apos;arr:&apos; + arr,&apos;reverseArr:&apos; + reverseArr);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-7.png" alt="reverse"></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote>
<p>在默认情况下，sort方法按照升序排列数组项，为了实现排序，sort会调用每个数组项的<strong>toString</strong>方法，然后比较得到的字符串，以确定如何进行排序。故sort方法是通过字符串进行比较的，即使数组的每一项是数字类型亦是如此。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sortArr=[0,1,5,10,15];</div><div class="line">    sortArr.sort();</div><div class="line">    console.log(sortArr);//0,1,10,15,5</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-8.png" alt="sort"></p>
<p><strong>为了能够对数组进行我们想要的排序，可以给sort传一个比较函数作为参数</strong></p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var sortArr=[0,1,5,10,15];</div><div class="line">    sortArr.sort(function(a,b)&#123;</div><div class="line">       return a-b//升序</div><div class="line">      /*</div><div class="line">        return b-a//降序</div><div class="line">      */</div><div class="line">   &#125;);</div><div class="line">   console.log(sortArr);//[0,1,5,10,15]</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-9.png" alt="sort数字排序"></p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><blockquote>
<p>所有对象都有toLocalString()、toString()、valueOf()方法。</p>
</blockquote>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><blockquote>
<p>将一个值转换成一个字符串有两种方法，一是使用toString()方法，二是使用转型函数String()<br><strong>(当然还有添加空字符串的方式)</strong></p>
</blockquote>
<p><strong>以下几点需要注意</strong></p>
<ol>
<li>几乎所有值都有toString方法，说明有的值是没有的，比如null、undefined<br><strong>推荐观看</strong> <a href="https://msdn.microsoft.com/zh-cn/library/k6xhc6yc%28v=vs.94%29.aspx" target="_blank" rel="external">toString</a></li>
</ol>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var boolean1 = true;</div><div class="line">var str = &apos;谦龙&apos;;</div><div class="line">var obj = &#123;&quot;name&quot;:&quot;谦龙&quot;&#125;;</div><div class="line">var arr = [1,2,3,4];</div><div class="line">var nul = null;</div><div class="line">var undefined1 = undefined;</div><div class="line"></div><div class="line">console.log( num.toString())</div><div class="line">console.log( boolean1.toString())</div><div class="line">console.log( str.toString())</div><div class="line">console.log( obj.toString())</div><div class="line">console.log( arr.toString())</div><div class="line">console.log( nul.toString())</div><div class="line">console.log( undefined1.toString())</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-10.png" alt="toString"></p>
<ol>
<li>对于字符串类型的数值也可以使用toString方法，返回值是该字符串的副本</li>
<li>toString方法接收一个参数，表示将要转换的数值的基数(默认是10)，<strong>注意</strong>只最<strong>数值</strong>起作用</li>
</ol>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">var num2 = &apos;10&apos;;</div><div class="line">console.log(num.toString()) // &apos;10&apos;</div><div class="line">console.log(num.toString(2))// &apos;1010&apos;</div><div class="line">console.log(num.toString(8))// &apos;12&apos;</div><div class="line">console.log(num.toString(16))//&apos;a&apos;</div><div class="line">console.log(num2.toString(2)) // &apos;10&apos;不是1010  只对数值起作用</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-11.png" alt="toString ">   </p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><blockquote>
<p>返回指定对象的基元值。</p>
</blockquote>
<p><strong>推荐观看</strong><a href="https://msdn.microsoft.com/zh-cn/library/ftx8swz5%28v=vs.94%29.aspx" target="_blank" rel="external">valueOf</a></p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var bl = true;</div><div class="line">function fn()&#123;console.log(&apos;谦龙&apos;)&#125;;</div><div class="line">var num = 10;</div><div class="line">var str = &apos;谦龙&apos;;</div><div class="line">var obj = /\d/;</div><div class="line">console.log(arr.valueOf(),typeof( arr.valueOf()));</div><div class="line">console.log(bl.valueOf(),typeof( bl.valueOf()));</div><div class="line">console.log(fn.valueOf(),typeof( fn.valueOf()));</div><div class="line">console.log(num.valueOf(),typeof( num.valueOf()));</div><div class="line">console.log(str.valueOf(),typeof( str.valueOf()))</div><div class="line">console.log(obj.valueOf(),typeof( obj.valueOf()));</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-12.png" alt="valueOf描述"></p>
<h3 id="toLocalString"><a href="#toLocalString" class="headerlink" title="toLocalString"></a>toLocalString</h3><blockquote>
<p>toLocalString方法作用几乎和toString相同</p>
</blockquote>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>将数组中的元素用不同的分隔符连接成字符串（默认是”，”号）</p>
</blockquote>
<p><code>code</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">    console.log(arr.join());</div><div class="line">    console.log(arr.join(&apos;&apos;));</div><div class="line">    console.log(arr.join(&apos;+&apos;))</div></pre></td></tr></table></figure></p>
<p><img src="/img/2016-03-27-13.png" alt="join"></p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><blockquote>
<p>concat方法可以基于当前数组中的所有项创建一个<strong>新的数组</strong>，具体来说：</p>
</blockquote>
<ol>
<li>该方法会先创建一个当前数组的副本，然后将接收到的参数添加到这个数组的末尾，最后返回新构建的数组。</li>
<li>如果传递的是一个或者多个数组，则会将这些数组中的每一项都添加到结果数组中。</li>
<li>如果传递的不是数组，这些值就会被简单的添加到结果数组的末尾。</li>
</ol>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sourceArr = [0];</div><div class="line">var reArr = sourceArr.concat(1,[2,3],[4,5]);</div><div class="line">    console.log(&apos;sourceArr&apos;+sourceArr,&apos;reArr&apos;+reArr);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-14.png" alt="join"></p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote>
<p>基于当前数组的一项或者多项创建一个<strong>新的数组</strong>，slice方法接受一个或者两个参数。<strong>一个参数时</strong>：返回该参数<strong>指定的位置</strong>到当前数组末尾的所有项。<strong>两个参数时</strong>：返回起始位置到结束位置之间的项（不包括结束位置并且该方法不影响原来的数组）</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var arr2 = arr.slice(0);// 0-末尾所有元素</div><div class="line">var arr3 = arr.slice(0,3)// 0-3 不包括3的位置的元素</div><div class="line">var arr4 = arr.slice(-3,-1);//即最后一个元素是-1 以此往左类推 所以得到的结果是[3,4]</div><div class="line">console.log(arr2);</div><div class="line">console.log(arr3);</div><div class="line">console.log(arr4);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-15.png" alt="slice"></p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><blockquote>
<p>slice方式可以说是数组中功能最强大的方法，可以完成任意位置的<strong>插入</strong>，<strong>删除</strong>和<strong>替换</strong>操作</p>
<p><strong>插入</strong>：可以向任意位置插入任意数量的项，提供三个参数–插入的起始位置、0（删除元素的个数）、插入的元素（如果要插入多个元素，再传入第四第五…个参数），返回被删除的项目（如果没有被删除的元素返回的是[]空数组）。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var reArr = arr.splice(1,0,&apos;谦龙&apos;,&apos;谦龙2&apos;,&apos;谦龙3&apos;);</div><div class="line">console.log(arr,reArr);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-16.png" alt="splice插入"></p>
<p><strong>删除</strong>：可以删除任意数量的项，需要指定2个参数，要删除的第一项的位置和要删除的项数。</p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var reArr = arr.splice(0,2);</div><div class="line">    console.log(arr,reArr);</div><div class="line"></div><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var reArr = arr.splice(5,2);//注意这里的5不在数组的范围内</div><div class="line">    console.log(arr,reArr)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-17.png" alt="splice删除"></p>
<p><strong>替换</strong>:可以向指定的位置插入任意数量的项，且同时删除任意数量的项，需要提供三个参数</p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var reArr = arr.splice(0,2,&apos;谦龙&apos;);</div><div class="line">console.log(arr,reArr)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-18.png" alt="splice删除替换"></p>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><blockquote>
<p>数组中有两个位置方法：indexOf和lastIndexOf。都接收两个参数—要查找的项和表示查找起点的索引（可选）。其中indexOf从数组开头开始往后查找，lastIndexOf从后往前查找，返回值是项在数组中的位置或者-1（没有找到）</p>
</blockquote>
<h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf 和 lastIndexOf"></a>indexOf 和 lastIndexOf</h3><p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,&apos;谦龙&apos;,4,5,&apos;谦龙&apos;,6];</div><div class="line">console.log(arr.indexOf(&apos;谦龙&apos;));//3</div><div class="line">console.log(arr.indexOf(&apos;帅哥&apos;));//-1</div><div class="line">console.log(arr.lastIndexOf(&apos;谦龙&apos;));//6</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-19.png" alt="位置方法"></p>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><blockquote>
<p>ECMAScript为数组定义了5个迭代的方法，每个方法都可以接受两个参数，要在每一项运行的函数和（可选）运行该函数的作用域对象—影响的是this的值。而传入的函数有三个参数分别是：数组项的值，索引，数组本身。</p>
</blockquote>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><blockquote>
<p>对数组的每一项运行给定的函数，没有返回值。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">    arr.forEach(function(item,index,arr)&#123;</div><div class="line">        console.log(item,index,arr);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-20.png" alt="forEach测试"></p>
<p><strong>特别注意：</strong>除了以上的基本用法，forEach中默认的this指的是window对象，所以其可以接受一个用来改变this的参数。</p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">arr.forEach(function(item,index,arr)&#123;</div><div class="line">   console.log(this)</div><div class="line">&#125;,arr);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-21.png" alt="forEach this指向发生改变"></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote>
<p>对数组的每一项运行有返回值的函数，最后映射成一个新的数组。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">arr.map(function(item,index,arr)&#123;</div><div class="line">console.log(this);</div><div class="line">return item*item;</div><div class="line">&#125;,arr)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-22.png" alt="map测试"></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote>
<p>有过滤筛选的含义，接收一个有返回值为<strong>弱==true</strong>的函数，最后返回一个过滤后的新数组。关于this指向的问题与上面的forEach和map是一样的</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7];</div><div class="line">var newArr=arr.filter(function(item)&#123;</div><div class="line"> if(item%2==0)&#123;</div><div class="line">    return true;//返回值为布尔</div><div class="line">  &#125;</div><div class="line">  //也可以直接写成 return item%2;</div><div class="line">&#125;)</div><div class="line">console.log(newArr)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-23.png" alt="图片描述"></p>
<h3 id="every-和some"><a href="#every-和some" class="headerlink" title="every 和some"></a>every 和some</h3><blockquote>
<p>接收一个返回值为布尔值的函数，如果对于数组中的每一项，该函数都是返回true则，该方法返回true。<strong>注意</strong>该方法和前面的几个方法不同，不会返回数组，而是返回一个布尔值。some也是如此</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3,4,5];</div><div class="line"> var b=arr.every(function(item)&#123;</div><div class="line">     return item%2==0?true:false;</div><div class="line"> &#125;);</div><div class="line"> console.log(b) </div><div class="line"> </div><div class="line"> ar arr=[1,2,3,4,5];</div><div class="line"> var b=arr.some(function(item)&#123;</div><div class="line">     return item%2==0?true:false;</div><div class="line"> &#125;);</div><div class="line"> console.log(b)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-24.png" alt="every some应用"></p>
<h2 id="减小方法"><a href="#减小方法" class="headerlink" title="减小方法"></a>减小方法</h2><blockquote>
<p>ES5中对数组新增了两个”缩小”方法(ps:缩小是相对的)，这两个方法都会迭代数组中的每一项，然后构建一个最终的返回值。reduce从第0项开始，ruduceRight从末尾开始。</p>
</blockquote>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><blockquote>
<p>该函数接收一个函数参数，函数接受4个参数：之前值、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。若指定，则当作最初使用的previous值；如果缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位，相比有initialValue值少一次迭代。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var sum = arr.reduce(function(pre,cur,index,arr)&#123;</div><div class="line">    return pre+cur;</div><div class="line">&#125;);</div><div class="line">console.log(sum)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-25.png" alt="reduece"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 初始设置</div><div class="line">pre = initialValue = 1, cur = 2</div><div class="line"></div><div class="line">// 第一次迭代</div><div class="line">pre = (1 + 2) =  3, cur = 3</div><div class="line"></div><div class="line">// 第二次迭代</div><div class="line">pre = (3 + 3) =  6, cur = 4</div><div class="line"></div><div class="line">// 第三次迭代</div><div class="line">pre = (6 + 4) =  10, cur = undefined (退出)</div></pre></td></tr></table></figure>
<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h3><blockquote>
<p>该函数接收一个函数参数，函数接受4个参数：之前值、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。若指定，则当作最初使用的previous值；如果缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位，相比有initialValue值少一次迭代。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var reNum = arr.reduceRight(function(pre,cur,idnex,arr)&#123;</div><div class="line">return pre+cur;</div><div class="line">&#125;)</div><div class="line">console.log(reNum)</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-27-26.png" alt="reduceRight测试"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 初始设置</div><div class="line">pre = initialValue = 4, cur = 3</div><div class="line"></div><div class="line">// 第一次迭代</div><div class="line">pre = (4 +3) =  7, cur = 2</div><div class="line"></div><div class="line">// 第二次迭代</div><div class="line">pre = (7 + 2) =  9, cur = 1</div><div class="line"></div><div class="line">// 第三次迭代</div><div class="line">pre = (9 + 1) =  10, cur = undefined (退出)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[只用一个div,我们能做什么？]]></title>
      <url>https://qianlongo.github.io/2016/03/27/%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AAdiv-%E6%88%91%E4%BB%AC%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现在都流行用纯css实现一些非常有趣的事情，比如纯css实现”暖男大白”啦( <a href="http://www.17sucai.com/pins/demoshow/9598" target="_blank" rel="external">戳这里</a> )，纯css实现哆啦a梦啦( <a href="http://www.w3cfuns.com/notes/20156/9afc0fe168cc0747bd632da963687973" target="_blank" rel="external">戳这里</a> )等等，还有只用一个div我们能做哪些有趣的事情啦，今天我也准备写一篇文章( 持续更新 )，记录自己平时学习和工作过程中只用一个div来完成的一些应用和好玩的东西。</p>
</blockquote>
<a id="more"></a>
<p>以后陆续更新会将demo保存在<a href="http://sandbox.runjs.cn/show/5yl6lwbv" target="_blank" rel="external">这里</a></p>
<p><strong>html</strong>结构都是一个div所以不会展示其部分代码，只会分析和展示css部分</p>
<h3 id="1-画一个伸缩展开菜单按钮"><a href="#1-画一个伸缩展开菜单按钮" class="headerlink" title="1. 画一个伸缩展开菜单按钮"></a>1. 画一个伸缩展开菜单按钮</h3><blockquote>
<p>首先我们来画一个前端工作中经常要用到的一个icon图标，<strong>伸缩展开菜单按钮*</strong>,他的主要作用就是将隐藏的菜单展开以显示或者伸缩以隐藏。如下图所示,或者请戳你的浏览器右上角…Go。</p>
</blockquote>
<p><img src="/img/2016-03-27-27.png" alt="伸缩展开按钮"></p>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.hamburger &#123;</div><div class="line">  position: relative;</div><div class="line">  width: 50px;</div><div class="line">  height: 50px;</div><div class="line">  cursor: pointer;</div><div class="line">  border: solid 1px #68EA58;</div><div class="line">&#125;</div><div class="line">.hamburger:before,.hamburger:after&#123;</div><div class="line">  display: block;;</div><div class="line">  content: &apos;&apos;;</div><div class="line">  width: 60%;</div><div class="line">  position: absolute;</div><div class="line">  left: 50%;</div><div class="line">  top: 50%;</div><div class="line">  -webkit-transform: translate(-50%,-50%);</div><div class="line">  -ms-transform: translate(-50%,-50%);</div><div class="line">  -o-transform: translate(-50%,-50%);</div><div class="line">  transform: translate(-50%,-50%);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">.hamburger:before &#123;</div><div class="line">  border-top: 4px solid #68EA58;</div><div class="line">  border-bottom: 4px solid #68EA58;</div><div class="line">  height: 14px;</div><div class="line">&#125;</div><div class="line">.hamburger:after &#123;</div><div class="line">  background: #68EA58;</div><div class="line">  height: 4px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看效果，点击<a href="http://sandbox.runjs.cn/show/5yl6lwbv" target="_blank" rel="external">这里</a></p>
<h2 id="2-回到顶部"><a href="#2-回到顶部" class="headerlink" title="2. 回到顶部"></a>2. 回到顶部</h2><blockquote>
<p>几乎每一张网页都有一个回到顶部的按钮，方便用户随浏览时，回到网页顶部进行其他的操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*回到顶部*/</div><div class="line"></div><div class="line">.to-top&#123;</div><div class="line">  border-radius: 50%;</div><div class="line">&#125;</div><div class="line">.to-top:after,.to-top:before&#123;</div><div class="line">  display: block;;</div><div class="line">  content: &apos;&apos;;</div><div class="line">  position: absolute;</div><div class="line">  left: 50%;</div><div class="line">  -webkit-transform: translateX(-50%);</div><div class="line">  -ms-transform: translateX(-50%);</div><div class="line">  -o-transform: translateX(-50%);</div><div class="line">  transform: translateX(-50%);</div><div class="line">&#125;</div><div class="line"></div><div class="line">.to-top:before&#123;</div><div class="line">  border: solid 14px #68EA58;</div><div class="line">  border-left-color: transparent;</div><div class="line">  border-top-color: transparent;</div><div class="line">  border-right-color: transparent;</div><div class="line">&#125;</div><div class="line">.to-top:after&#123;</div><div class="line">  width: 12px;</div><div class="line">  height: 12px;</div><div class="line">  background-color: #68EA58;</div><div class="line">  top:28px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看效果，点击<a href="http://sandbox.runjs.cn/show/5yl6lwbv" target="_blank" rel="external">这里</a></p>
<h2 id="3-消息提示框"><a href="#3-消息提示框" class="headerlink" title="3. 消息提示框"></a>3. 消息提示框</h2><blockquote>
<p>一般前端工作中会有这样的需求，鼠标进行某些操作，进而给到用户一些提示信息，这些提示信息的载体是一个提示框。</p>
</blockquote>
<p><code>code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*信息提示*/</div><div class="line">.message&#123;</div><div class="line">  border-radius: 4px;</div><div class="line">  height: 30px !important;</div><div class="line">&#125;</div><div class="line">.message:after&#123;</div><div class="line">  display: block;</div><div class="line">  content: &apos;&apos;;</div><div class="line">  position: absolute;</div><div class="line">  border-bottom: 6px solid transparent;</div><div class="line">  border-left:6px solid  #68EA58;;</div><div class="line">  bottom: -6px;</div><div class="line">  left: 20%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看效果，点击<a href="http://sandbox.runjs.cn/show/5yl6lwbv" target="_blank" rel="external">这里</a></p>
<h2 id="4-搜索按钮"><a href="#4-搜索按钮" class="headerlink" title="4. 搜索按钮"></a>4. 搜索按钮</h2><blockquote>
<p>搜索按钮对于我们来说在熟悉不过，几乎涉及到搜索的地方都会有一个搜索按钮，用来提示用户这一块是用于搜索信息用的</p>
</blockquote>
<p><code>code</code></p>
<pre><code>

.search{
  width: 24px !important;
  height: 4px !important;
  background-color:  #68EA58;
  -webkit-transform: rotate(45deg) translateX(14px) ;
  -ms-transform: rotate(45deg) translateX(14px) ;
  -o-transform: rotate(45deg) translateX(14px) ;
  transform: rotate(45deg) translateX(14px);
}

.search:before{
  display: block;
  content: &apos;&apos;;
  width: 20px;
  height: 20px;
  border: 4px solid #68EA58;
  border-radius: 50%;
  position: absolute;
  left: -28px;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  -o-transform: translateY(-50%);
  transform: translateY(-50%);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面对数组去重，我们用什么方式]]></title>
      <url>https://qianlongo.github.io/2016/03/26/%E9%9D%A2%E5%AF%B9%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%EF%BC%8C%E6%88%91%E4%BB%AC%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>不管是面试还是平时写程序的过程中我们经常会遇到要对<strong>数组进行去重</strong>的问题，该文总结了一些常见的数组去重的方法。</p>
<h2 id="对象键值对法"><a href="#对象键值对法" class="headerlink" title="对象键值对法"></a>对象键值对法</h2><p><strong>思路：</strong>新建一js对象json以及新数组reArr，遍历数组元素是否为json的键，不是则创建，是则判断元素的类型在键对应的值中是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    function unique(array)&#123;</div><div class="line">      var json = &#123;&#125;, reArr = [], len = array.length, val, type;</div><div class="line">        for (var i = 0; i &lt; len ; i++) &#123;</div><div class="line">            val = array[i];</div><div class="line">            type = Object.prototype.toString.call(val);</div><div class="line">            if (!json[val]) &#123;//如果键对应的值不存在则是第一次存取</div><div class="line">                json[val] = [type];//设置该键为数组，并赋值元素类型</div><div class="line">                reArr.push(val);//往reArr中添加元素</div><div class="line">            &#125; else if (json[val].indexOf(type) &lt; 0) &#123;</div><div class="line">                json[val].push(type);</div><div class="line">                reArr.push(val);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return reArr;</div><div class="line">    &#125;</div><div class="line">//该方法有bug，当有多个&#123;&#125;时，只能保存一个&#123;&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>测试</strong><br><img src="/img/2016-03-26-13.png" alt="unique1测试"></p>
<h2 id="遍历数组法"><a href="#遍历数组法" class="headerlink" title="遍历数组法"></a>遍历数组法</h2><p><strong>思路：</strong>新建一新数组，遍历传入的数组，值不在新数组就加入该新数组中；该方法最主要的是要使用ES5中的indexOf方法。但是ie8一下不支持，所以需要做一些兼容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    if (!Array.prototype.indexOf)&#123;</div><div class="line">      Array.prototype.indexOf = function(item)&#123;</div><div class="line">        if (this.length == 0)&#123;</div><div class="line">          return -1;</div><div class="line">        &#125;</div><div class="line">        for(var i = 0, len = this.length; i &lt; len; i++)&#123;</div><div class="line">          if (this[i] === item)&#123;//注意是三个等号</div><div class="line">            return i</div><div class="line">            break;</div><div class="line">          &#125;  </div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>去重代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function unique(array)&#123;</div><div class="line">  var reArr = []; </div><div class="line">  for(var i = 0; i &lt; array.length; i++)&#123;</div><div class="line">    if (reArr.indexOf(array[i]) == -1)&#123;//判断元素是否在数组中已经存在</div><div class="line">       reArr.push(array[i]);</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  return reArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>测试</strong><br><img src="/img/2016-03-26-14.png" alt="遍历数组法测试"></p>
<h2 id="数组下标判断法"><a href="#数组下标判断法" class="headerlink" title="数组下标判断法"></a>数组下标判断法</h2><p><strong>思路：</strong>将传入的数组的第一项目添加到一个新的数组，后遍历传入的数组中的元素利用indexOf方法，若返回值与循环中的索引不同则是重复的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function unique(array)&#123;</div><div class="line">    var reArr=[];</div><div class="line">        reArr[0]=array[0];</div><div class="line">    for(var i=1;i&lt;array.length;i++)&#123;</div><div class="line">        if(array.indexOf(array[i])==i)&#123;</div><div class="line">            reArr.push(arrar[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return reArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>测试</strong><br><img src="/img/2016-03-26-15.png" alt="遍历数组下表法测试"></p>
<h2 id="排序后相邻去除法"><a href="#排序后相邻去除法" class="headerlink" title="排序后相邻去除法"></a>排序后相邻去除法</h2><p><strong>思路：</strong>先将数组经过sort排序，这时候相同的元素处于相邻的位置,所以在便利数组的时候我们只将与前一值不重复的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function unique(array)&#123;</div><div class="line">    var reArr=[array[0]];</div><div class="line">    var len=array.length;</div><div class="line">        array.sort();</div><div class="line">    for(var i=1;i&lt;len;i++)&#123;</div><div class="line">        if(array[i]!=reArr[reArr.length-1])&#123;//注意这里</div><div class="line">            reArr.push(array[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return reArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-16.png" alt="排序后相邻去除法"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[几个js开发过程中的小技巧]]></title>
      <url>https://qianlongo.github.io/2016/03/26/%E5%87%A0%E4%B8%AAjs%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>javascript是一门非常灵活的语言，实际的开发过程中我们也可以灵活的使用它而给我们的工作带来便利，这篇文章记录了自己平时学习过程中经常用到的一些小技巧，整理出来作为笔记，也希望对感兴趣的同学有所帮助。( 持续更新… )</p>
</blockquote>
<h2 id="1-获取指定范围内的随机数"><a href="#1-获取指定范围内的随机数" class="headerlink" title="1 获取指定范围内的随机数"></a>1 获取指定范围内的随机数</h2><blockquote>
<p>当我们需要获取指定范围(min,max)内的整数的时候，下面的代码非常适合。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRadomNum</span>(<span class="params">min,max</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span>  <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>测试</strong><br><img src="/img/2016-03-26-2.png" alt="测试"></p>
<h2 id="2-随机获取数组中的元素"><a href="#2-随机获取数组中的元素" class="headerlink" title="2 随机获取数组中的元素"></a>2 随机获取数组中的元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRadomFromArr</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*arr.length)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-3.png" alt="测试"></p>
<h2 id="3-生成从0到指定值的数字数组"><a href="#3-生成从0到指定值的数字数组" class="headerlink" title="3 生成从0到指定值的数字数组"></a>3 生成从0到指定值的数字数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[],length=<span class="number">100</span>,i=<span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(;arr.push(i++)&lt;length;)&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(arr)</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-4.png" alt="测试"></p>
<h2 id="4-打乱数字数组的顺序"><a href="#4-打乱数字数组的顺序" class="headerlink" title="4 打乱数字数组的顺序"></a>4 打乱数字数组的顺序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="string">'a'</span>,<span class="string">'dsfs'</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="string">'v'</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">Math</span>.random()<span class="number">-0.5</span>&#125;);</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-5.png" alt="测试"></p>
<h2 id="5-对象转换为数组"><a href="#5-对象转换为数组" class="headerlink" title="5 对象转换为数组"></a>5 对象转换为数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意对象必须是以下格式的才可以通过此方式转化为数组</span></div><div class="line"><span class="comment">//获取的DOM集合，以及函数的arguments也可以通过此方式转化为数组</span></div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="number">0</span>:<span class="string">'qian'</span>,</div><div class="line">	<span class="number">1</span>:<span class="string">'long'</span>,</div><div class="line">	<span class="number">2</span>:<span class="string">'chu'</span>,</div><div class="line">	<span class="number">3</span>:<span class="string">'tian'</span>,</div><div class="line">	<span class="attr">length</span>:<span class="number">4</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> _slice=[].slice;</div><div class="line"><span class="keyword">var</span> objArr=_slice.call(obj);</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-6.png" alt="图片描述"></p>
<h2 id="6-验证是否为数组"><a href="#6-验证是否为数组" class="headerlink" title="6 验证是否为数组"></a>6 验证是否为数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>  <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p><img src="/img/2016-03-26-7.png" alt="图片描述"></p>
<h2 id="7-获取数组中最大或者最小值"><a href="#7-获取数组中最大或者最小值" class="headerlink" title="7 获取数组中最大或者最小值"></a>7 获取数组中最大或者最小值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxAndMin</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">   <span class="attr">max</span>:<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr.join(<span class="string">','</span>).split(<span class="string">','</span>)),</div><div class="line">   <span class="attr">min</span>:<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr.join(<span class="string">','</span>).split(<span class="string">','</span>))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>该方法适合一维或者多维数组求最大最小值的情况</strong></p>
<p><strong>测试</strong><br><img src="/img/2016-03-26-8.png" alt="图片描述"></p>
<h2 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8 清空数组"></a>8 清空数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方式一 通过将长度设置为0</span></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.length=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//方式二 通过splice方法</span></div><div class="line"> <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.splice(<span class="number">0</span>,arr.length);</div><div class="line"></div><div class="line"><span class="comment">//方式三 通过将空数组 [] 赋值给数组(严格意义来说这只是将ary重新赋值为空数组，之前的数组如果没有引用在指向它将等待垃圾回收。)</span></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr=[];</div></pre></td></tr></table></figure>
<h2 id="9-保留指定小数位"><a href="#9-保留指定小数位" class="headerlink" title="9 保留指定小数位"></a>9 保留指定小数位</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num =<span class="number">4.345678</span>;</div><div class="line">num = num.toFixed(<span class="number">4</span>);  <span class="comment">// 4.3457 第四位小数位以四舍五入计算</span></div></pre></td></tr></table></figure>
<h2 id="10-不要直接使用delete来删除数组中的元素"><a href="#10-不要直接使用delete来删除数组中的元素" class="headerlink" title="10 不要直接使用delete来删除数组中的元素"></a>10 不要直接使用delete来删除数组中的元素</h2><blockquote>
<p>数组在js中也是对象，有时候我们可能会通过delete来删除数组中的元素，但是其实仅仅是将数组的元素的值赋值为了undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'谦龙'</span>,<span class="string">'雏田'</span>];</div><div class="line">    <span class="keyword">delete</span> arr[<span class="number">5</span>];</div><div class="line">    <span class="built_in">console</span>.log(arr,arr[<span class="number">5</span>],arr.length);</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>测试</strong></p>
<p><img src="/img/2016-03-26-9.png" alt="图片描述"></p>
<p><strong>可以通过splice来删除数组中的某一项</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'谦龙'</span>,<span class="string">'雏田'</span>];</div><div class="line">    arr.splice(<span class="number">5</span>,<span class="number">1</span>);</div><div class="line">    <span class="built_in">console</span>.log(arr,arr[<span class="number">5</span>],arr.length);</div></pre></td></tr></table></figure></p>
<p><strong>测试</strong></p>
<p><img src="/img/2016-03-26-10.png" alt="图片描述"></p>
<h2 id="11-生成指定长度的随机字母数字字符串"><a href="#11-生成指定长度的随机字母数字字符串" class="headerlink" title="11 生成指定长度的随机字母数字字符串"></a>11 生成指定长度的随机字母数字字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomStr</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span>( ; str.length &lt; len; str  += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>));</div><div class="line">    <span class="keyword">return</span>  str.substr(<span class="number">0</span>, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试</strong><br><img src="/img/2016-03-26-11.png" alt="图片描述"></p>
<h2 id="12-null-与-undefined"><a href="#12-null-与-undefined" class="headerlink" title="12 null 与 undefined"></a>12 null 与 undefined</h2><blockquote>
<p>null == undefined,null == null 返回true,有时候我们为了排除null 和 undefined可以使用如下的代码</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(obj!=<span class="literal">null</span>)&#123;<span class="comment">// obj除了undefined 和 null 之外都会走这里</span></div><div class="line">        ....这里写代码逻辑</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="13-找出数组中出现次数最的元素，并给出其出现过的位置"><a href="#13-找出数组中出现次数最的元素，并给出其出现过的位置" class="headerlink" title="13 找出数组中出现次数最的元素，并给出其出现过的位置"></a>13 找出数组中出现次数最的元素，并给出其出现过的位置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxAndIndex</span>(<span class="params"> arr </span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(!obj[item])&#123;</div><div class="line">                obj[item]= &#123;<span class="attr">indexs</span>: [index]&#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                obj[item][<span class="string">'indexs'</span>].push(index);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">var</span> num=<span class="number">0</span>;<span class="comment">//记录出现次数最大值</span></div><div class="line">        <span class="keyword">var</span> str=<span class="string">''</span>;<span class="comment">//记录出现次数最多的字符</span></div><div class="line">        <span class="keyword">var</span> reArr;<span class="comment">//返回最大值的位置数组</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj)&#123;</div><div class="line">            <span class="keyword">var</span> temp=obj[attr][<span class="string">'indexs'</span>];</div><div class="line">            <span class="keyword">if</span>(temp.length&gt;num)&#123;</div><div class="line">                num=temp.length;</div><div class="line">                str=attr;</div><div class="line">                reArr=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">maxStr</span>:str,</div><div class="line">            <span class="attr">indexs</span>:reArr</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>测试结果</strong><br><img src="/img/2016-03-26-12.png" alt="图片描述"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery中$()函数的7种用法汇总]]></title>
      <url>https://qianlongo.github.io/2016/03/26/jQuery%E4%B8%AD-%E5%87%BD%E6%95%B0%E7%9A%847%E7%A7%8D%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>jQuery对象是一个<strong>类数组</strong>的对象，含有连续的整形属性以及一系列的jQuery方法。它把所有的操作都包装在一个jQuery()函数中，形成了统一(也是惟一)的操作入口。<br>其中我们用的非常频繁的一个函数是$()或者说是jQuery()，当我们调用他的时候会根据传入的参数的不同而达到不同的效果。</p>
</blockquote>
<p>接下来会一一说一下这7中用法，欢迎大家指正其中不正确的地方。</p>
<a id="more"></a>
<h2 id="1-jQuery-selector-context"><a href="#1-jQuery-selector-context" class="headerlink" title="1 jQuery(selector,context)"></a>1 jQuery(selector,context)</h2><blockquote>
<p>简要的说是：接收一个css选择器表达式(selector)和可选的选择器上下文(context),返回一个包含了匹配的DOM元素的jQuery对象。</p>
</blockquote>
<p>默认情况下，对匹配元素的查找都是从<strong>根元素ducument对象</strong>开始，也就是说查找范围是整棵文档树。但是如果给定了上下文context，则在指定上下文中查找</p>
<p><strong>html</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;body span&lt;/span&gt;</div><div class="line">&lt;span&gt;body span&lt;/span&gt;</div><div class="line">&lt;span&gt;body span&lt;/span&gt;</div><div class="line">&lt;div class=&quot;wrap&quot;&gt;</div><div class="line">    &lt;span&gt;wrap span&lt;/span&gt;</div><div class="line">    &lt;span&gt;wrap span&lt;/span&gt;</div><div class="line">    &lt;span&gt;wrap span&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>js</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&apos;span&apos;).css(&apos;background-color&apos;,&apos;red&apos;);//所有的span都会变红</div><div class="line">$(&apos;span&apos;,&apos;.wrap&apos;).css(&apos;background-color&apos;,&apos;red&apos;);//只有.wrap中的span会变红</div></pre></td></tr></table></figure></p>
<h2 id="2-jQuery-html-ownerDocument-、jQuery-html-props"><a href="#2-jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="2 jQuery(html,ownerDocument) 、jQuery(html,props)"></a>2 jQuery(html,ownerDocument) 、jQuery(html,props)</h2><blockquote>
<p>用所提供的html代码创建DOM元素<br>对于jQuery(html,ownerDocument)，参数html可以是单标签或者是多层标签之间的嵌套。第二个参数用于创建新DOM元素的<strong>文档对象</strong>，如果不传入则默认为当前的文档对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//单标签  两种方式都可以往body中插入div</div><div class="line">/*</div><div class="line"> *   1  $(&apos;&lt;div&gt;&apos;).appendTo(&apos;body&apos;);</div><div class="line"> *   2  $(&apos;&lt;div&gt;&lt;/div&gt;&apos;).appendTo(&apos;body&apos;);</div><div class="line"> */</div><div class="line">// 多标签嵌套</div><div class="line"> $(&apos;&lt;div&gt;&lt;span&gt;dfsg&lt;/span&gt;&lt;/div&gt;&apos;).appendTo(&apos;body&apos;);</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>另外:</strong>对于单标签，jQuery(html,props)，props是一个包含属性和事件的普通的对象，用法如下。(<strong>该用法有待考证，请知道这一用法的童鞋告知一下，感激不尽</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&apos;&lt;div&gt;我是div&lt;/div&gt;&apos;,&#123;</div><div class="line">    title:&apos;我是新的div&apos;,</div><div class="line">    click:function()&#123;</div><div class="line">        $(this).css(&apos;color&apos;,&apos;red&apos;);</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">&#125;).appendTo(&apos;body&apos;);</div></pre></td></tr></table></figure>
<h2 id="3-jQuery-element-or-elementsArray"><a href="#3-jQuery-element-or-elementsArray" class="headerlink" title="3 jQuery(element or elementsArray)"></a>3 jQuery(element or elementsArray)</h2><blockquote>
<p>如果传入一个DOM元素或者是DOM元素的数组，则把DOM元素封装到jQuery对象中并返回。<br><strong>html</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;1&lt;/li&gt;</div><div class="line">    &lt;li&gt;2&lt;/li&gt;</div><div class="line">    &lt;li&gt;3&lt;/li&gt;</div><div class="line">    &lt;li&gt;4&lt;/li&gt;</div><div class="line">    &lt;li&gt;5&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>js</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> // 传入DOM元素</div><div class="line"> $(&apos;li&apos;).each(function(index,ele)&#123;</div><div class="line">        $(ele).on(&apos;click&apos;,function()&#123;</div><div class="line">            $(this).css(&apos;background&apos;,&apos;red&apos;);//这里的DOM元素就是this</div><div class="line">        &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//传入DOM数组</div><div class="line">var aLi=document.getElementsByTagName(&apos;li&apos;);</div><div class="line">    aLi=[].slice.call(aLi);//集合转数组</div><div class="line">    var $aLi=$(aLi);</div><div class="line">    $aLi.html(&apos;我是jQuery对象&apos;);//所有的li的内容都变成&apos;我是jQuery对象&apos;</div></pre></td></tr></table></figure></p>
<h2 id="4-jQuery-object"><a href="#4-jQuery-object" class="headerlink" title="4 jQuery(object)"></a>4 jQuery(object)</h2><blockquote>
<p>如果传入的是一个object对象，则把该对象封装到jQuery对象中并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;name:&apos;谦龙&apos;&#125;;</div><div class="line">var $obj=$(obj);//封装成jQuery对象</div><div class="line">//绑定自定义事件</div><div class="line">$obj.on(&apos;say&apos;,function()&#123;</div><div class="line">    console.log(this.name)//输出谦龙</div><div class="line">&#125;);</div><div class="line">$obj.trigger(&apos;say&apos;);</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="5-jQuery-callback"><a href="#5-jQuery-callback" class="headerlink" title="5 jQuery(callback)"></a>5 jQuery(callback)</h2><blockquote>
<p>当传进去的参数是函数的时候，则在document对象上绑定一个ready事件监听函数，当DOM结构加载完成的时候执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line">//以上代码和下面的效果是一样的</div><div class="line">$(document).ready(function()&#123;</div><div class="line">    ...//代码</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="6-jQuery-jQuery-object"><a href="#6-jQuery-jQuery-object" class="headerlink" title="6 jQuery(jQuery object)"></a>6 jQuery(jQuery object)</h2><blockquote>
<p>当传进去的参数是一个jQuery对象的时候，则创建该jQuery对象的一个副本并返回。副本与传入的jQuery对象引用完全相同的元素</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var aLi=$(&apos;li&apos;);</div><div class="line">var copyLi=$(aLi);//创建一个aLi的副本</div><div class="line">console.log(aLi);</div><div class="line">console.log(copyLi);</div><div class="line">console.log(copyLi===aLi);</div></pre></td></tr></table></figure>
<p><img src="/img/2016-03-26-1.png" alt="jQuery"></p>
<h2 id="7-jQuery"><a href="#7-jQuery" class="headerlink" title="7 jQuery()"></a>7 jQuery()</h2><blockquote>
<p>如果不传入任何的参数，则返回一个空的jQuery对象，属性length为0<br>注意这个功能可以用来复用jQuery对象，例如可以创建一个空的jQuery对象，然后在需要的时候先手动修改其中的元素，然后在调用jQuery方法。从而避免重复创建jQuery对象。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tip 移动端子元素scroll，父元素不跟随滚动js实现]]></title>
      <url>https://qianlongo.github.io/2016/03/24/tip-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AD%90%E5%85%83%E7%B4%A0scroll%EF%BC%8C%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%8D%E8%B7%9F%E9%9A%8F%E6%BB%9A%E5%8A%A8js%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[用css美化你的浏览器滚动条]]></title>
      <url>https://qianlongo.github.io/2016/03/22/%E7%94%A8css%E7%BE%8E%E5%8C%96%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>总所周知，各大浏览器自带的滚动条样式在pc端比较单调无趣，爱美的童鞋也许不会喜欢这样的默认设置，有没有什么办法可以让我们随心所欲的定制属于自己的滚动条样式呢？好消息是<strong>有办法滴</strong>，但是还有一个坏消息，那就是到目前为止，几乎只有webkit内核的浏览器支持定制滚动条，其他浏览器要么完全不支持自定义，要么就是只支持自定义部分滚动条属性，所以本文暂时只谈怎么在webkit内核浏览器中修改滚动条</p>
</blockquote>
<a id="more"></a>
<h2 id="滚动条构造初体验"><a href="#滚动条构造初体验" class="headerlink" title="滚动条构造初体验"></a>滚动条构造初体验</h2><p>首先让我们来看一下滚动条大致由哪些部分组成，留图不留种，菊花万人捅，一图胜千言，请看下图。</p>
<p><img src="/img/2016-03-22-1.png" alt="困"></p>
<p><strong>构造说明</strong></p>
<ol>
<li>::-webkit-scrollbar        滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样）等。</li>
<li>::-webkit-scrollbar-button      滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。</li>
<li>::-webkit-scrollbar-track         外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。</li>
<li>::-webkit-scrollbar-track-piece        内层轨道，滚动条中间部分（除去）。</li>
<li>::-webkit-scrollbar-thumb               滚动条里面可以拖动的那部分</li>
<li>::-webkit-scrollbar-corner               边角</li>
<li>::-webkit-resizer                       定义右下角拖动块的样式</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>我们运用上面的伪类来修改webkit内核的滚动条，可以先预览一下一个简单的demo</p>
</blockquote>
<p><a href="http://runjs.cn/detail/esdf8ncr" target="_blank" rel="external">点击预览</a></p>
<p><strong>开始分析</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;box&quot;&gt;</div><div class="line">  &lt;div class=&quot;inner&quot;&gt;</div><div class="line">    我是默认的滚动条</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;box demo&quot;&gt;</div><div class="line">  &lt;div class=&quot;inner&quot;&gt;</div><div class="line">    我是自定义的滚动条</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>html</strong>的结构非常简单，就是为了演示例子准备的两个div滚动容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  width: 400px;</div><div class="line">  height: 400px;</div><div class="line">  border: solid 1px green;</div><div class="line">  float: left;</div><div class="line">  margin-right: 30px;</div><div class="line">  overflow: scroll;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.inner&#123;</div><div class="line">  height: 700px;</div><div class="line">  width: 700px;</div><div class="line">  font: 40px/400px &quot;微软雅黑&quot;;</div><div class="line">  text-align: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*滚动条整体部分*/</div><div class="line">.demo::-webkit-scrollbar&#123;</div><div class="line">  width: 7px;</div><div class="line">  height: 7px;</div><div class="line">  border-radius: 4px;</div><div class="line">  background-color: #f0f0f0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*滚动条两端的箭头*/</div><div class="line">.demo::-webkit-scrollbar-button&#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*经测试好像并不能控制什么*/</div><div class="line">.demo::-webkit-scroll-track&#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*滚动条内侧部分 去掉*/</div><div class="line">.demo::-webkit-scrollbar-track-piece &#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*滚动条中可以拖动的那部分*/</div><div class="line">.demo::-webkit-scrollbar-thumb&#123;</div><div class="line">  background-color: green;</div><div class="line">  border-radius: 4px;</div><div class="line">&#125;</div><div class="line">/*变角部分*/</div><div class="line">.demo::-webkit-scrollbar-corner &#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div><div class="line">.demo::-webkit-resizer&#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>最后得到效果如下图</strong>  图丑莫怪</p>
<p><img src="/img/2016-03-22-2.png" alt="困"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>虽然webkit内核浏览器允许我们自定义滚动条样式，但是这是不兼容的，其他浏览器下该是什么样子就是什么样子，所以想要滚动条一致性体验，还是用<strong>元素模拟</strong>的形式把，而且用css自定义样式的情况会产生一个新的问题，那就是会<strong>覆盖移动端下滚动条样式</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客搭建总结]]></title>
      <url>https://qianlongo.github.io/2016/03/06/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>一直想拥有一个自己独立的博客，在那里写自己的生活、感悟、学习积累和自己的心事…今天终于愿望成真了，博客初步搭建成型，而我也困成狗了。</p>
</blockquote>
<p><img src="/img/sleep.gif" alt="困"></p>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[事件流详解]]></title>
      <url>https://qianlongo.github.io/2016/03/05/%E4%BA%8B%E4%BB%B6%E6%B5%81%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>第一次</strong>在segmentfault写文章，希望通过这种方式来巩固所学的知识，也欢迎童鞋们指正其中有不对和错误的地方。^+^</p>
<ol>
<li><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2></li>
</ol>
<p><strong>事件流</strong>：页面中接收事件的顺序,即当一个事件发生时，该事件的传播过程便叫做事件流</p>
<h3 id="事件流的种类"><a href="#事件流的种类" class="headerlink" title="事件流的种类"></a>事件流的种类</h3><p>  <strong> 事件冒泡</strong></p>
<p>事件由最具体的元素开始<strong>逐级向上</strong>传播至较为不具体的节点(文档)</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;box&quot;&gt;点我&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>当我们点击id为box的div时，该点击事件传播顺序如下</p>
<p><strong>div –&gt; body –&gt; html –&gt;document</strong></p>
<p><strong>特别说明</strong>：IE5.5及更早的版本将绕过html节点直接到document，IE9，Firefox，chrome和safari将冒泡到window对象</p>
<p>   <strong>事件捕获</strong></p>
<p>事件捕获和事件冒泡似乎截然相反，由不太具体的节点先接收到事件 –&gt;再到最具体的节点。同样还是用上面冒泡例子，则事件的传播顺序则是：</p>
<p><strong>document –&gt; html –&gt;body –&gt;div</strong></p>
<p><strong>特别说明</strong>：ie8之前不支持事件捕获，IE9，safari，chrome，opera，firefox目前支持良好。并且这些浏览器不是从document开始捕获，而是从window对象开始。</p>
<h3 id="DOM事件流阶段"><a href="#DOM事件流阶段" class="headerlink" title="DOM事件流阶段"></a>DOM事件流阶段</h3><ol>
<li>捕获阶段</li>
<li>目标阶段</li>
<li>冒泡阶段</li>
</ol>
<p><img src="/img/sjl.png" alt="事件流图解"></p>
<p>以上面的代码为例子，由图可以很清晰地看出首先发生的是<strong>事件捕获</strong>–&gt;实际的目标接收事件–&gt;事件冒泡</p>
<p><strong>特别说明</strong>:在DOM事件流中，实际的目标不会在捕获阶段接收到事件，即捕获阶段到body就停止，”下一阶段”是目标阶段，该阶段可以看成是事件冒泡的一部分，最终事件又被传播会document。<br><strong>BUT</strong> :我们的各大浏览器总是不喜欢按照规范来，IE9，Safari，chrome，firefox及其更高的版本中都会在捕获阶段出发事件对象上的事件，最后导致有两个机会在目标对象上操作事件。</p>
<ol>
<li>##事件处理程序<br><strong>事件</strong>：用户或者浏览器自身执行的某个动作，比如load，click，mousemove等<br><strong>事件处理程序</strong>：相应某个事件的函数叫做事件处理函数（也叫做<strong>事件侦听器</strong>）<h3 id="事件处理程序类别"><a href="#事件处理程序类别" class="headerlink" title="事件处理程序类别"></a>事件处理程序类别</h3><strong>1 html事件处理程序</strong>：某个元素支持的某个事件可以用与事件处理程序同名的html特性来指定，该特性的值是能够执行的javascript代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;alert(&apos;我被点击了&apos;)&quot; /&gt;</div><div class="line"></div><div class="line">/*</div><div class="line">   当点击该按钮的时候，浏览器会弹出&apos;我被点击了&apos;;</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当然也可以给<strong>onclick</strong>赋值页面中其他地方定义的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function show()&#123;</div><div class="line">        alert(&apos;我被点击了&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">/*</div><div class="line">  点击后也会弹出 &apos;我被点击了&apos;</div><div class="line">*/</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;show()&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p><strong>优点</strong>：简单明了，省去获取元素等一系列前提操作<br><strong>缺点</strong>：html代码与js代码高度耦合，不符合分离原则</p>
<hr>
<p><strong>2 DOM0级别事件处理函数</strong>：使用 element.on[eventname]=fn的方式给元素添加事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;click&quot; /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var oBtn=document.getElementById(&apos;click&apos;);</div><div class="line">        //该方式被认为是元素的方法，即事件处理程序在元素的作用域中进行，this即该元素本身</div><div class="line">        oBtn.onclick=function()&#123;</div><div class="line">            alert(this.id);//click</div><div class="line">        &#125;</div><div class="line">        //注意：删除该事件处理程序可以用如下方法</div><div class="line">        oBtn.onclick=null;//即点击后不再有任何反应</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>3 DOM2级事件处理程序</strong>：DOM2级添加了addEventListener（添加事件处理程序）和removeEventListener(移除事件处理程序)<br><strong>添加事件处理函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;click&quot; /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var oBtn=document.getElementById(&apos;click&apos;);</div><div class="line">        /* 参数1 指定事件名称...click mouseover mouseout</div><div class="line">           参数2 事件处理程序（匿名函数或者有名函数）</div><div class="line">           参数3 true（捕获阶段发生） or false（冒泡阶段发生）</div><div class="line">        */</div><div class="line">        oBtn.addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">            alert(this.id)//click  this指的是该元素作用域内</div><div class="line">        &#125;,false)</div><div class="line">        //注意该种方式可以给一个函数添加多个事件处理函数，执行顺序与添加顺序相同</div><div class="line">        oBtn.addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">            alert(&apos;Hello World&apos;)//click</div><div class="line">        &#125;,false)</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>移除事件处理函数</strong>：如果事件处理函数是有名函数，则可以通过名字来移除，匿名函数无法移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;click&quot; /&gt;</div><div class="line">&lt;script&gt;</div><div class="line"> var oBtn=document.getElementById(&apos;click&apos;);</div><div class="line">        function showId()&#123;</div><div class="line">            alert(this.id);</div><div class="line">        &#125;;</div><div class="line">        function HellowWorld()&#123;</div><div class="line">            alert(&apos;HellowWorld&apos;);</div><div class="line">        &#125;</div><div class="line">        oBtn.removeEventListener(&apos;click&apos;,showId,false)</div><div class="line">        //最后只能弹出HellowWorld</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>4IE事件处理程序</strong>：ie实现了与dom类似的两个方法，attachEvent（添加），detachEvent（删除）<br><strong>添加事件处理函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;click&quot; /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var oBtn=document.getElementById(&apos;click&apos;);</div><div class="line">            function showId()&#123;</div><div class="line">                alert(this.id);</div><div class="line">            &#125;;</div><div class="line">        oBtn.attachEvent(&apos;onclick&apos;,showId);//这时候会报错，因为这里的是在window</div><div class="line">        的作用域内</div><div class="line">        //修改如下</div><div class="line">        oBtn.attachEvent(&apos;onclick&apos;,function()&#123;</div><div class="line">            showId.call(this);//改变this指向</div><div class="line">        &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>删除事件处理函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;click&quot; /&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var oBtn=document.getElementById(&apos;click&apos;);</div><div class="line">            function showId()&#123;</div><div class="line">                alert(&apos;HelloWorld&apos;);</div><div class="line">            &#125;;</div><div class="line">        oBtn.attachEvent(&apos;onclick&apos;,showId);//这时候会报错，因为这里的是在window</div><div class="line">        的作用域内</div><div class="line">        //修改如下</div><div class="line">        oBtn.detachEvent(&apos;onclick&apos;,showId) ;//点击没有任何反应</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h3 id="事件函数封装"><a href="#事件函数封装" class="headerlink" title="事件函数封装"></a>事件函数封装</h3><p><strong>绑定</strong> 为了解决attachEvent的this指向问题，并且可以通过有名称的函数来解除事件绑定，现在处理如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">   function bind(obj,eventName,fn)&#123;</div><div class="line">        var _fn=fn;</div><div class="line">        fn=function()&#123;</div><div class="line">            _fn.call(obj);//改变this指向</div><div class="line">        &#125;;</div><div class="line">        if(obj.addEventListener)&#123;</div><div class="line">            obj.addEventListener(eventName,fn,false);</div><div class="line">        &#125;else&#123;</div><div class="line">            obj.attachEvent(&apos;on&apos;+eventName,fn);</div><div class="line">        &#125;</div><div class="line">        return fn;//用于事件解除</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>解除</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> function unbind(obj,eventName,fn)&#123;</div><div class="line">    if(obj.removeEventListener)&#123;</div><div class="line">        obj.removeEventListener(eventName,fn);</div><div class="line">    &#125;else&#123;</div><div class="line">        obj.detachEvent(&apos;on&apos;+eventName,fn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//给input添加和移除事件</div><div class="line">&lt;input type=&quot;button&quot; id=&quot;box&quot; value=&quot;事件封装&quot; /&gt;</div><div class="line">//添加</div><div class="line">function show( )&#123;</div><div class="line">    alert(this);</div><div class="line">&#125;</div><div class="line">function show2( )&#123;</div><div class="line">    alert(this.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var removeFn=bind(&apos;box&apos;,&apos;click&apos;,show);//需要移除的事件处理程序，不是原程序名称show</div><div class="line">bind(&apos;box&apos;,&apos;click&apos;,show2);</div><div class="line">unbind(&apos;box&apos;,&apos;click&apos;,removeFn);</div><div class="line">//最后只会弹出 box</div></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote>
<p>当触发DOM上面的某个事件的时候，会产生一个事件对象event,这个对象中包含着所有与事件对象有关的信息。例如该<strong>事件类型</strong>，<strong>导致事件的元素</strong>等</p>
</blockquote>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><blockquote>
<p>   <strong>DOM中的事件对象</strong>：兼容DOM的浏览器会将event对象传入到事件处理程序中，无论指定事件处理程序用什么方式(html方式，DOM0级方式，DOM2级方式)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> &lt;input type=&quot;button&quot; id=&quot;box&quot; value=&quot;DOM中的事件对象&quot; onclick=&quot;console.log(event.type)&quot;&gt;</div><div class="line"> //html方法  click</div><div class="line">var oBox=document.getElementById(&apos;box&apos;);</div><div class="line"> //DOM0级别方法 click</div><div class="line">     oBox.onclick=function(ev)&#123;</div><div class="line">         console.log(ev.type);//click</div><div class="line">     &#125;</div><div class="line"> ///DOM2级别方法 click</div><div class="line"> oBox.addEventListener(&apos;click&apos;,function(ev)&#123;</div><div class="line">         console.log(ev.type);//click</div><div class="line">     &#125;)</div></pre></td></tr></table></figure>
<p><strong>总的来说event对象包含与创建他的特定事件有关的属性和方法，但是触发的事件类型不同，则可用的属性和方法也不一样。但是都会包含以下成员</strong></p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">读/写</th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>currentTarget</td>
<td style="text-align:center">element</td>
<td style="text-align:right">只读</td>
<td></td>
<td>事件处理程序当前正在处理程序的那个元素，我的理解是事件的直接绑定者</td>
</tr>
<tr>
<td>target</td>
<td style="text-align:center">element</td>
<td style="text-align:right">只读</td>
<td></td>
<td>事件的目标</td>
</tr>
<tr>
<td>cancelable</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>表示是否可以取消事件的默认行为</td>
</tr>
<tr>
<td>preventDefault()</td>
<td style="text-align:center">function</td>
<td style="text-align:right">只读</td>
<td></td>
<td>取消事件的默认行为 ,前提是cancelable为true</td>
</tr>
<tr>
<td>bubbles</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>表明事件是否可以冒泡</td>
</tr>
<tr>
<td>stopPropagation()</td>
<td style="text-align:center">function</td>
<td style="text-align:right">只读</td>
<td></td>
<td>取消事件的进一步冒泡或者捕获，前提是bubbles为true</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>事件类型</td>
</tr>
<tr>
<td>view</td>
<td style="text-align:center">abstractView</td>
<td style="text-align:right">只读</td>
<td></td>
<td>与事件关联的抽象视图，等同于发生事件的window对象</td>
</tr>
<tr>
<td>detail</td>
<td style="text-align:center">integer</td>
<td style="text-align:right">只读</td>
<td></td>
<td>与事件相关的细节信息</td>
</tr>
<tr>
<td>eventPhase</td>
<td style="text-align:center">integer</td>
<td style="text-align:right">只读</td>
<td></td>
<td>调用事件处理程序的阶段，1：:捕获，2：“处于目标”，3：冒泡</td>
</tr>
<tr>
<td>trusted</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>为true表示事件是由浏览器生成的，为false表示事件是由开发人员通过js生成的。(DOM3)</td>
</tr>
<tr>
<td>stopImmediatePropagation()</td>
<td style="text-align:center">function</td>
<td style="text-align:right">只读</td>
<td></td>
<td>取消事件的进一步捕获或者冒泡，同时阻止任何事件处理程序被调用(DOM3)</td>
</tr>
</tbody>
</table>
<p><strong>特别说明</strong>：只有在事件处理程序被执行的期间，event对象才会存在，一旦事件处理程序执行完成，其就会被销毁。</p>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><blockquote>
<p>与访问DOM中的事件对象不同，要访问IE中的event对象有几种不同的方式。取决于指定事件处理程序的方法。</p>
</blockquote>
<ol>
<li>html event</li>
<li>函数参数</li>
<li>window.event</li>
</ol>
<p><strong>同样IE中的event对象也包含着与创建他的事件相关的属性和方法，其中很多的属性和方法都有对应的或者是相关的DOM属性和方法。当然也会事件的不同，其属性和方法也会有所不同，但是都会包含下表内容</strong></p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:right">读/写</th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>srcElement</td>
<td style="text-align:center">element</td>
<td style="text-align:right">只读</td>
<td></td>
<td>事件的目标（与DOM中的target属性相同）</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">string</td>
<td style="text-align:right">只读</td>
<td></td>
<td>事件的类型</td>
</tr>
<tr>
<td>cancelBubble</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>默认为false，设置为true表示取消冒泡(与stopPropagation()作用相同)</td>
</tr>
<tr>
<td>returnValue</td>
<td style="text-align:center">boolean</td>
<td style="text-align:right">只读</td>
<td></td>
<td>默认为true，设置为false就可以取消默认行为（与preventDefault()作用相同）</td>
</tr>
</tbody>
</table>
<h3 id="跨浏览器事件对象封装"><a href="#跨浏览器事件对象封装" class="headerlink" title="跨浏览器事件对象封装"></a>跨浏览器事件对象封装</h3><p>我们为eventUtil添加几个方法，以此来达到有关event对象的常用的跨浏览器的使用目标</p>
<ol>
<li>getEvent() 获取事件对象</li>
<li>getTarget()获取事件源</li>
<li>stopPropagation() 取消冒泡</li>
<li>preventDefault() 阻止默认行为</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var eventUtil=&#123;</div><div class="line">     getEvent:function(ev)&#123;</div><div class="line">         return ev || window.event;//获取事件对象</div><div class="line">     &#125;,</div><div class="line">     getTarget:function(ev)&#123;</div><div class="line">         return ev.target || ev.srcElement;//获取事件源</div><div class="line">     &#125;,</div><div class="line">     stopPropagation:function(ev)&#123;//阻止冒泡</div><div class="line">         if(ev.stopPropagation)&#123;</div><div class="line">             ev.stopPropagation();</div><div class="line">         &#125;else&#123;</div><div class="line">             ev.cancelBubble=true;</div><div class="line">         &#125;</div><div class="line">     &#125;,</div><div class="line">     preventDefault:function(ev)&#123;//阻止默认行为</div><div class="line">         if(ev.preventDefault)&#123;</div><div class="line">             ev.preventDefault();</div><div class="line">         &#125;else&#123;</div><div class="line">             ev.returnValue=true;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="常见应用之事件委托"><a href="#常见应用之事件委托" class="headerlink" title="常见应用之事件委托"></a>常见应用之事件委托</h3><p><strong>说明</strong>：需要给页面中成百上千个li绑定一个事件并且输出当前元素的innerHTML<br><strong>常见做法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;1&lt;/li&gt;</div><div class="line">    &lt;li&gt;2&lt;/li&gt;</div><div class="line">    &lt;li&gt;3&lt;/li&gt;</div><div class="line">    &lt;li&gt;4&lt;/li&gt;</div><div class="line">    &lt;li&gt;5&lt;/li&gt;</div><div class="line">    &lt;li&gt;6&lt;/li&gt;</div><div class="line">    &lt;li&gt;7&lt;/li&gt;</div><div class="line">    &lt;li&gt;8&lt;/li&gt;</div><div class="line">    &lt;li&gt;9&lt;/li&gt;</div><div class="line">    &lt;li&gt;10&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">var aLi  //假设已经获取了这组li元素</div><div class="line">for(var i=0;i&lt;aLi.length;i++)&#123;</div><div class="line">    aLi[i].onclick=function(ev)&#123;</div><div class="line">        console.log(this.innerHTML);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方式通过遍历DOM节点的方式添加事件处理程序有诸多缺点，比如性能大大减低，新添加的li不具备click事件等。</p>
<p><strong>利用事件委托（冒泡原理）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var oUl//假设oUl是li的父节点</div><div class="line">oUL.onclick=fuction(ev)&#123;</div><div class="line">    var ev=eventUtil.getEvent(ev);</div><div class="line">    var target=eventUtil.getTarget(ev);</div><div class="line">        console.log(target.innerHTML);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>利用事件委托可以大大地提高性能，后面随时添加的元素都可以拥有这个点击事件等</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实习月总结]]></title>
      <url>https://qianlongo.github.io/2016/03/05/%E5%AE%9E%E4%B9%A0%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>时间似流水般潺潺而过，不经意便从指尖溜走，于笔尖划过。悄然无声，却迹痕般般。投江至今足月有余，恍然恰似昨日，梦醒犹如初见。席地而坐，所思？所获？何为？…</p>
</blockquote>
<h2 id="印象"><a href="#印象" class="headerlink" title="印象"></a>印象</h2><blockquote>
<p>投江近一个月，切身体会这里的人、事、景、物。30多个小伙伴组成了和睦有爱的前端大家庭，他们身怀过硬的技术专长，对工作用心务实，待新人耐心和善，领导没有高架子，与”平民”同乐，他们日出而”作”,日落而归，没有夜夜加班的bat文化，没有尔虞我诈的勾心斗角，在这里自己开心快乐，充实而饱满。</p>
</blockquote>
<a id="more"></a>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li><strong>熟悉和实践移动端相关技术</strong><br>移动端在web开发中所占的地位不断加重，前端开发不了解其相关技术势必被浪潮拍在<br>沙滩上。</li>
<li><strong>在工作中锻炼技术，提高解决问题和独立学习的能力</strong></li>
</ol>
<h2 id="所获"><a href="#所获" class="headerlink" title="所获"></a>所获</h2><h3 id="主动思考"><a href="#主动思考" class="headerlink" title="主动思考"></a>主动思考</h3><blockquote>
<p>实习收获最大的一件事情就是学会主动思考，主动去思考需求本身是否合理，去思考如何做才能使体验更佳…</p>
</blockquote>
<p>mmp项目中有一个模块用来专门做渠道管理，使应用可以关联相应的渠道，但是产品给出的原型中应用却有一套自己独立的添加渠道操作，该渠道并不是从前面维护的渠道中选出，于是和产品沟通，如果这样渠道管理就失去了维护的意义，后来产品更改需求，交互原型也变成如下图</p>
<p><img src="/img/mmpSource.png" alt="图片描述"></p>
<p><img src="/img/mmpLater.png" alt="图片描述"></p>
<h3 id="前端无需了解需求本身？"><a href="#前端无需了解需求本身？" class="headerlink" title="前端无需了解需求本身？"></a>前端无需了解需求本身？</h3><blockquote>
<p>在之前的一段实习过程中，经常有合作的后端同学说前端无需了解需求本身，但是我觉得这样的看法是不对的。</p>
<p><strong>抛开码农的世界</strong>，无论身处何处，在做什么，首先<strong>知道自己做的是什么</strong>是非常重要的事情，如果只是按部就班的把被安排的事情做好,这与行尸走肉无异，于己而言也就没有什么意义了。</p>
<p><strong>回归码农的世界</strong>，前端除了了解产品界面原型和ui效果图，还应当了解产品的功能需求和业务规则。很多时候，在没有设计或者交互参与的项目中，产品对界面的把控并没有前端仔细，而且在一些交互细节上也无法做到体验最佳。如果前端不去了解业务需求，而只是按照原型将页面实现，那做出来的东西一定不是”更好的”。</p>
</blockquote>
<h3 id="关于编码习惯"><a href="#关于编码习惯" class="headerlink" title="关于编码习惯"></a>关于编码习惯</h3><p>好的编码习惯可以提高我们的代码质量，增强团规开发协作效，减少bug出现的几率…<br>甚至可以提高自己对曾经写过的代码的理解力(时间一长，如果编码习惯不好，哪怕是自己写的程序，恐怕也不能快速理解)</p>
<blockquote>
<p>与其说师兄有代码洁癖，强迫症，还不如说他养成了良好的编程习惯，有时候他在看自己写的代码的时候，经常会指出一些编程习惯的问题比如</p>
</blockquote>
<ol>
<li>保持分号统一，不要一处有，一处没有</li>
<li>写if while等的时候空一格，这有利于和函数调用区分开</li>
<li>使用两个空格来缩进，这是保证在各大平台上代码缩进都统一办法</li>
<li>将调试以及当前使用但未来需要删除的代码做上标记xxx方便以后将其删除<br>(经常我们的习惯是用console.log等来进行调试，但是调试完成之后使用//注释掉，很有可能在代码上线之前没有将其删除)</li>
<li>做好注释，比如在路由那一块，哪一个模板对应什么业务应该有清晰明显的注释，方便自己和后面维护的童鞋一目了然的知晓其作用。</li>
<li>…<blockquote>
<p>好习惯的养成不是一朝一夕的事情，而是长时间的积累和坚持，现在自己写程序依然会有各种问题存在，这也说明习惯养成之路漫长且待坚持。</p>
</blockquote>
</li>
</ol>
<h3 id="扩展和可配置"><a href="#扩展和可配置" class="headerlink" title="扩展和可配置"></a>扩展和可配置</h3><blockquote>
<p>代码的扩展性是码农都追求的一个目标，我所理解的代码的扩展性一方面是为了应对或者解决需求的时常变更而给开发者带来比较大的开发代价而做的程序设计。</p>
</blockquote>
<p>比如有这么一个常见的导航模块，包含三大板块，每个板块下面会有自己的小模块</p>
<p><img src="/img/mmpNav.png" alt="图片描述"></p>
<p>刚开始做的时候是根据原型完全用<strong>写死的方式在html写好</strong>，但是后来和产品了解需求的时候发现这个项目并没有最后完全敲锤定音，也就是还存在许多可变因素，导航模块完全有可能增加和删除，为了解决这样的问题，我将原先先死的html结构抽象出来，将大模块标题，小模块，图标用数据配置的方式来生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$scope.groups = [</div><div class="line">    &#123;</div><div class="line">      title : &apos;应用管理&apos;,//标题</div><div class="line">      icon : &apos;glyphicon glyphicon-th-list&apos;,//图标</div><div class="line">      isOpen : true,//是否展开</div><div class="line">      lists : [//子模块</div><div class="line">        &#123;</div><div class="line">          title : &apos;应用列表&apos;,</div><div class="line">          ui_sref : &apos;application_list&apos;,</div><div class="line">          icons : &apos;glyphicon glyphicon-paperclip&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          title : &apos;渠道管理&apos;,</div><div class="line">          ui_sref : &apos;channel_management&apos;,</div><div class="line">          icons : &apos;glyphicon glyphicon-paperclip&apos;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ];</div></pre></td></tr></table></figure></p>
<p>再配合这一段模板就可以解决后续模块增加或者删除的问题(只需要在数据模型中增加或者删除对应的字段就可以)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;uib-accordion&gt;</div><div class="line">    &lt;uib-accordion-group  is-open=&quot;group.isOpen&quot; ng-repeat=&quot;group in groups&quot;&gt;</div><div class="line">      &lt;uib-accordion-heading&gt;</div><div class="line">        &#123;&#123; group.title &#125;&#125;  &lt;i class=&quot;&#123;&#123; group.icon &#125;&#125;&quot;&gt;&lt;/i&gt;&lt;span ng-class=&quot;&#123;&apos;triangle&apos;: group.isOpen,&apos;triangle_no&apos;:!group.isOpen&#125;&quot;&gt;&lt;/span&gt;</div><div class="line">      &lt;/uib-accordion-heading&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &lt;li ng-repeat=&quot;item in group.lists&quot; ng-click=&quot;tab.setCurrent(&apos;application_list&apos;)&quot;&gt;</div><div class="line">          &lt;a ui-sref=&quot;.&#123;&#123; item.ui_sref &#125;&#125;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/a&gt;</div><div class="line">          &lt;i class=&quot;&#123;&#123; item.icons &#125;&#125;&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    &lt;/uib-accordion-group&gt;</div><div class="line">  &lt;/uib-accordion&gt;</div></pre></td></tr></table></figure></p>
<h3 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h3><ol>
<li>angular初级开发，可以利用angular提供的特性完成初步的web开发</li>
<li>移动端入门、了解移动端相关知识熟悉flex布局</li>
<li>gulp知识入门，可以编写常见的gulp代码来处理我们的任务</li>
</ol>
<h2 id="计划未完成"><a href="#计划未完成" class="headerlink" title="计划未完成"></a>计划未完成</h2><h3 id="qDrap组件开发"><a href="#qDrap组件开发" class="headerlink" title="qDrap组件开发"></a>qDrap组件开发</h3><p>产生要写这个组件的初始原因是刚来到这里的时候写了一个拖拽排序小组件<a href="https://github.com/qianlongGo/components/blob/master/DragToSort/js/dragToSort.js" target="_blank" rel="external">拖拽排序</a>师兄看了之后提了许多建议</p>
<ol>
<li>在进行碰撞检测的时候无需将所有的元素都检测一遍，只需要将即将可能发生碰撞的元素进行检测即可( 当然前提是需要判断哪些元素可能会与当前元素发生碰撞)</li>
<li>有些行为应该做成可配置，比如拖拽时的动画</li>
<li>组件开发应该尽量满足和契合其他规范，比如amd、cmd</li>
</ol>
<p>后来在mmp需求来了之后，把工作重心都放在mmp上，没有完成这一计划….<br><strong>做事当有始有终，不可以半途而废</strong></p>
<h3 id="mmp项目前端工作未达到预期"><a href="#mmp项目前端工作未达到预期" class="headerlink" title="mmp项目前端工作未达到预期"></a>mmp项目前端工作未达到预期</h3><p>mmp项目期望是年前上线，排除一些前端不可控因素( 比如后端数据接口在29号才部分走通，所提供的数据联调机器在28号才给到… )从自己身上找原因</p>
<ol>
<li>该项目时间绝对够，快20天的时间前端只完成2/3界面编写与逻辑交互，而且现在还没有经过测试。原因何在？虽说自己设计界面从未有过涉及是一个挑战，但是变化是唯一不变的变化，不可能任何时候都让自己做自己熟悉的事情，所以面对这种情况自己花费了比较多的时间去适应，适应能力差。</li>
<li>没有把控好时间节点，页面编写花费时间太多近2周，这是不是从侧面说明一个问题，前端基础知识css布局有待加强。</li>
</ol>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol>
<li><p>不能很好地分配时间，安排工作节点实际工作中对需求的评估并给出相应的完成时间节点是非常重要的一件事情,一方面节点的给出有利于其他童鞋知晓你的工作进度，以方便协调合作，一方面也让自己的时间得到有效的利用，但是在实习过程中自己明显表现出计划不合理，工作效率低的问题，说到底还是不懂的合理有效地安排时间</p>
</li>
<li><p>沟通表达问题团队协作离不开密切地沟通，不同角色之间如何沟通是一个学问。如何用通俗有效的语言与非技术或不懂自己从事的技术与他人沟通，让他人明白我在说什么？这方面自己非常欠缺</p>
</li>
<li><p>知识面宅前端开发的基础知识上还不够具体和全面， “面”很狭窄。需要多加学习和拓展。</p>
</li>
<li><p>“主动性”做的还不够主动思考，主动与伙伴交流，主动承担更多的责任，觉得项目中或生活中不合理的地方，要学会主动去推动他，不能依靠或等待别人来做( 比如在用后端给的数据接口的时候好些接口对前端是不够友好的，甚至于业务而言真的是错误的，刚开始并没有主动去找后端童鞋说清楚缘由，而是觉得后端童鞋自己应该会发觉问题所在 )</p>
</li>
<li><p>前端不懂设计<br>mmp项目实施过程中没有设计和交互的参与，界面需要自己来进行设计，如何搭配颜色，如何布局展示，怎样交互才更加合理，是一次挑战，实践过程中也发现自己缺乏这方面的知识和能力，之前做的东西大多数也是别人设计好的东西。</p>
</li>
</ol>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>感谢这一段实习经历，遇见一个好的团队，里面每个人都是你的师傅，他们热情耐心，毫无距离感。在这里，自己开心快乐，每天都可以学到新的东西，幸福ing。针对这些不足和问题需要一步步改正加强。兄弟们！！！待来年，从头聚。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js面向对象继承浅析]]></title>
      <url>https://qianlongo.github.io/2016/03/05/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B5%85%E6%9E%90--%E7%BB%A7%E6%89%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>js中实现继承的方式只支持<strong>实现继承</strong>，即继承实际的方法，而实现继承主要是依靠<strong>原型链</strong>来完成的。</p>
</blockquote>
<h2 id="原型链式继承"><a href="#原型链式继承" class="headerlink" title="原型链式继承"></a>原型链式继承</h2><blockquote>
<p>该方式实现的本质是重写原型对象，代之以一个<strong>新类型的实例</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">    this.property=true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue=function()&#123;</div><div class="line">    return this.property;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">    this.subproperty=false;</div><div class="line">&#125;</div><div class="line">SubType.prototype = new SuperType();//继承</div><div class="line">SubType.prototype.getSubValue=function()&#123;//额外添加方法</div><div class="line">    return this.subproperty;</div><div class="line">&#125;</div><div class="line">var s = new SubType();</div><div class="line">    console.log(s.getSubValue());//false</div><div class="line">    console.log(s.getSuperValue());//true</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>借用纯原型链的问题：</strong>如果原型中包含引用类型的值，则实例间对该值的修改会相互影响，这不是我们希望看到的。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote>
<p>该方式的基本思想是在<strong>子类型</strong>的构造函数的内部调用超类型构造函数(父函数)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">     this.color=[&apos;green&apos;,&apos;red&apos;,&apos;black&apos;];</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> function SubType()&#123;</div><div class="line">     SuperType.call(this)//改变执行环境 实现继承</div><div class="line"> &#125;</div><div class="line"> var  s = new SubType();</div><div class="line">     s.color.push(&apos;pink&apos;);</div><div class="line">     console.log(s.color);//[ &apos;green&apos;, &apos;red&apos;, &apos;black&apos;, &apos;pink&apos; ]</div><div class="line"> var s1 = new SubType();</div><div class="line">     console.log(s1.color);//[ &apos;green&apos;, &apos;red&apos;, &apos;black&apos; ]</div></pre></td></tr></table></figure>
<p><strong>构造函数的问题：</strong>方法都在构造函数内部定义，则函数复用无从谈起。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote>
<p>基本思路是使用原型链来实现对原型属性和方法的继承，通过构造函数实现实例属性的继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">       this.name=name;</div><div class="line">       this.color=[&apos;green&apos;,&apos;red&apos;,&apos;black&apos;];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   SuperType.prototype.show=function()&#123;</div><div class="line">       console.log(this.name,this.color);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   function SubType(name,age)&#123;</div><div class="line">       SuperType.call(this,name)//改变执行环境 实现实例属性继承</div><div class="line">       this.age=age;</div><div class="line">   &#125;</div><div class="line">   SubType.prototype = new SuperType();//原型属性和方法继承</div><div class="line"></div><div class="line">   var s = new SubType(&apos;谦龙&apos;,100);</div><div class="line">       s.show();//谦龙 [&quot;green&quot;, &quot;red&quot;, &quot;black&quot;]</div><div class="line">   var s = new SubType(&apos;雏田&apos;,14);</div><div class="line">   s.show();//雏田 [&quot;green&quot;, &quot;red&quot;, &quot;black&quot;]</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote>
<p>该方法的特点是借助原型可以基于一个已有的对象创建新的对象，同时还不比因此创建自定义类型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function object(obj)&#123;</div><div class="line">    function F()&#123;&#125;;</div><div class="line">    F.prototype=obj;</div><div class="line">    //F.prototype.constructor=F; 有需要还可以修改constructor指向</div><div class="line">    return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person=&#123;</div><div class="line">    name:&apos;谦龙&apos;,</div><div class="line">    color:[&apos;red&apos;,&apos;green&apos;,&apos;black&apos;]</div><div class="line">&#125;</div><div class="line">var p1 = object(person);</div><div class="line">    p1.color.push(&apos;pink&apos;);</div><div class="line"></div><div class="line">var p2 = object(person);</div><div class="line">p2.color.push(&apos;grey&apos;);</div><div class="line"></div><div class="line">console.log(person.color);//[&quot;red&quot;, &quot;green&quot;, &quot;black&quot;, &quot;pink&quot;, &quot;grey&quot;]</div></pre></td></tr></table></figure>
<p><strong>ES5中的Object.creat()与该方式的行为相同</strong></p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote>
<p>该方式的思路是创建一个仅用来封装继承过程的函数，该函数在内部以某种方式来增强对象，最后将该对象返回。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function object(obj)&#123;</div><div class="line">       function F()&#123;&#125;;</div><div class="line">       F.prototype=obj;</div><div class="line">       //F.prototype.constructor=F; 有需要还可以修改constructor指向</div><div class="line">       return new F();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   function CObject(obj)&#123;</div><div class="line">       var clone=object(obj);</div><div class="line">       clone.sayHi=function()&#123;</div><div class="line">           alert(&apos;HI&apos;);</div><div class="line">       &#125;</div><div class="line">       return clone;</div><div class="line">   &#125;</div><div class="line">   var person=&#123;</div><div class="line">       name:&apos;谦龙&apos;,</div><div class="line">       color:[&apos;red&apos;,&apos;green&apos;,&apos;black&apos;]</div><div class="line">   &#125;</div><div class="line">   var s = CObject(person);</div><div class="line">       s.sayHi();</div></pre></td></tr></table></figure>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><blockquote>
<p>思路是通过借用构造函数来继承属性，通过原型链的混合形式来继承方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.color=[&apos;green&apos;,&apos;red&apos;,&apos;black&apos;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.show=function()&#123;</div><div class="line">    console.log(this.name,this.color);</div><div class="line">&#125;</div><div class="line">function SubType(name,age)&#123;</div><div class="line">    SuperType.call(this,name)//改变执行环境 实现继承</div><div class="line">    this.age=age;</div><div class="line">&#125;</div><div class="line">function object(obj)&#123;</div><div class="line">    function F()&#123;&#125;;</div><div class="line">    F.prototype=obj;</div><div class="line">    //F.prototype.constructor=F; 有需要还可以修改constructor指向</div><div class="line">    return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">    var prototype=object(superType.prototype);</div><div class="line">    prototype.constructor=subType;</div><div class="line">    subType.prototype=prototype;</div><div class="line">&#125;</div><div class="line">inheritPrototype(SubType,SuperType);</div><div class="line">var s = new SubType(&apos;谦龙&apos;,100);</div><div class="line">s.show();//谦龙 [&quot;green&quot;, &quot;red&quot;, &quot;black&quot;]</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h2><blockquote>
<p>该方法思路是将另外一个对象的属性和方法拷贝至另一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function deepCopy(obj)&#123;</div><div class="line">           if(typeof obj !=&apos;object&apos;)&#123;</div><div class="line">               console.trace();</div><div class="line">               return obj;</div><div class="line">           &#125;</div><div class="line">           var newObj=&#123;&#125;;</div><div class="line">               for(var attr in obj)&#123;</div><div class="line">                   newObj[attr]=typeof obj[attr]==&apos;object&apos;?deepCopy(obj[attr]):obj[attr];//使用递归</div><div class="line">               &#125;</div><div class="line">           return newObj;</div><div class="line">       &#125;</div><div class="line">       var obj=&#123;</div><div class="line">           name:&apos;min&apos;,</div><div class="line">           age:20,</div><div class="line">           sex:&apos;boy&apos;,</div><div class="line">           json:&#123;</div><div class="line">               name2:&apos;huihui&apos;,</div><div class="line">               json3:&#123;</div><div class="line">                   name3:&apos;yahui&apos;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       var newObj=deepCopy(obj);</div><div class="line">       console.log(newObj);</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="/img/extend.png" alt="图片描述"></p>
]]></content>
    </entry>
    
  
  
</search>
